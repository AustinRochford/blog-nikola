<meta name="title" content="Density Estimation with Dirichlet Process Mixtures using PyMC3" />
<meta name="tags" content="PyMC3, Dirichlet Processes, Bayesian Nonparametric Statistics, Bayesian Statistics, Nonparametric Statistics" />
<meta name="date" content="2016-02-25" />
<meta name="has_math" content="true" /><style>
.dataframe * {border-color: #c0c0c0 !important;}
.dataframe th{background: #eee;}
.dataframe td{
    background: #fff;
    text-align: right; 
    min-width:5em;
}

/* Format summary rows */
.dataframe-summary-row tr:last-child,
.dataframe-summary-col td:last-child{
background: #eee;
    font-weight: 500;
}
</style>
<p>I have been intrigued by the flexibility of <a href="https://en.wikipedia.org/wiki/Nonparametric_statistics">nonparametric statistics</a> for many years. As I have developed an understanding and appreciation of Bayesian modeling both personally and professionally over the last two or three years, I naturally developed an interest in Bayesian nonparametric statistics. I am pleased to begin a planned series of posts on Bayesian nonparametrics with this post on Dirichlet process mixtures for density estimation.</p>
<h4 id="dirichlet-processes">Dirichlet processes</h4>
<p>The <a href="https://en.wikipedia.org/wiki/Dirichlet_process">Dirichlet process</a> is a flexible probability distribution over the space of distributions. Most generally, a probability distribution, <span class="math inline">\(P\)</span>, on a set <span class="math inline">\(\Omega\)</span> is a <a href="https://en.wikipedia.org/wiki/Measure_(mathematics)">measure</a> that assigns measure one to the entire space (<span class="math inline">\(P(\Omega) = 1\)</span>). A Dirichlet process <span class="math inline">\(P \sim \textrm{DP}(\alpha, P_0)\)</span> is a measure that has the property that, for every finite <a href="https://en.wikipedia.org/wiki/Disjoint_sets">disjoint</a> partition <span class="math inline">\(S_1, \ldots, S_n\)</span> of <span class="math inline">\(\Omega\)</span>,</p>
<p><span class="math display">\[(P(S_1), \ldots, P(S_n)) \sim \textrm{Dir}(\alpha P_0(S_1), \ldots, \alpha P_0(S_n)).\]</span></p>
<p>Here <span class="math inline">\(P_0\)</span> is the base probability measure on the space <span class="math inline">\(\Omega\)</span>. The precision parameter <span class="math inline">\(\alpha &gt; 0\)</span> controls how close samples from the Dirichlet process are to the base measure, <span class="math inline">\(P_0\)</span>. As <span class="math inline">\(\alpha \to \infty\)</span>, samples from the Dirichlet process approach the base measure <span class="math inline">\(P_0\)</span>.</p>
<p>Dirichlet processes have several properties that make then quite suitable to <a href="https://en.wikipedia.org/wiki/Markov_chain_Monte_Carlo">MCMC</a> simulation.</p>
<ol type="1">
<li><p>The posterior given <a href="https://en.wikipedia.org/wiki/Independent_and_identically_distributed_random_variables">i.i.d.</a> observations <span class="math inline">\(\omega_1, \ldots, \omega_n\)</span> from a Dirichlet process <span class="math inline">\(P \sim \textrm{DP}(\alpha, P_0)\)</span> is also a Dirichlet process with</p>
<p><span class="math display">\[P\ |\ \omega_1, \ldots, \omega_n \sim \textrm{DP}\left(\alpha + n, \frac{\alpha}{\alpha + n} P_0 + \frac{1}{\alpha + n} \sum_{i = 1}^n \delta_{\omega_i}\right),\]</span></p></li>
</ol>
<p>where <span class="math inline">\(\delta\)</span> is the <a href="https://en.wikipedia.org/wiki/Dirac_delta_function">Dirac delta measure</a></p>
<p><span class="math display">\[\begin{align*}
    \delta_{\omega}(S)
        &amp; = \begin{cases}
                1 &amp; \textrm{if } \omega \in S \\
                0 &amp; \textrm{if } \omega \not \in S
            \end{cases}
\end{align*}.\]</span></p>
<ol start="2" type="1">
<li><p>The posterior predictive distribution of a new observation is a compromise between the base measure and the observations,</p>
<p><span class="math display">\[\omega\ |\ \omega_1, \ldots, \omega_n \sim \frac{\alpha}{\alpha + n} P_0 + \frac{1}{\alpha + n} \sum_{i = 1}^n \delta_{\omega_i}.\]</span></p></li>
</ol>
<p>We see that the prior precision <span class="math inline">\(\alpha\)</span> can naturally be interpreted as a prior sample size. The form of this posterior predictive distribution also lends itself to Gibbs sampling.</p>
<ol start="2" type="1">
<li><p>Samples, <span class="math inline">\(P \sim \textrm{DP}(\alpha, P_0)\)</span>, from a Dirichlet process are discrete with probability one. That is, there are elements <span class="math inline">\(\omega_1, \omega_2, \ldots\)</span> in <span class="math inline">\(\Omega\)</span> and weights <span class="math inline">\(w_1, w_2, \ldots\)</span> with <span class="math inline">\(\sum_{i = 1}^{\infty} w_i = 1\)</span> such that</p>
<p><span class="math display">\[P = \sum_{i = 1}^\infty w_i \delta_{\omega_i}.\]</span></p></li>
<li><p>The <a href="https://en.wikipedia.org/wiki/Dirichlet_process#The_stick-breaking_process">stick-breaking process</a> gives an explicit construction of the weights <span class="math inline">\(w_i\)</span> and samples <span class="math inline">\(\omega_i\)</span> above that is straightforward to sample from. If <span class="math inline">\(\beta_1, \beta_2, \ldots \sim \textrm{Beta}(1, \alpha)\)</span>, then <span class="math inline">\(w_i = \beta_i \prod_{j = 1}^{j - 1} (1 - \beta_j)\)</span>. The relationship between this representation and stick breaking may be illustrated as follows:</p>
<ol type="1">
<li>Start with a stick of length one.</li>
<li>Break the stick into two portions, the first of proportion <span class="math inline">\(w_1 = \beta_1\)</span> and the second of proportion <span class="math inline">\(1 - w_1\)</span>.</li>
<li>Further break the second portion into two portions, the first of proportion <span class="math inline">\(\beta_2\)</span> and the second of proportion <span class="math inline">\(1 - \beta_2\)</span>. The length of the first portion of this stick is <span class="math inline">\(\beta_2 (1 - \beta_1)\)</span>; the length of the second portion is <span class="math inline">\((1 - \beta_1) (1 - \beta_2)\)</span>.</li>
<li>Continue breaking the second portion from the previous break in this manner forever. If <span class="math inline">\(\omega_1, \omega_2, \ldots \sim P_0\)</span>, then</li>
</ol>
<p><span class="math display">\[P = \sum_{i = 1}^\infty w_i \delta_{\omega_i} \sim \textrm{DP}(\alpha, P_0).\]</span></p></li>
</ol>
<p>We can use the stick-breaking process above to easily sample from a Dirichlet process in Python. For this example, <span class="math inline">\(\alpha = 2\)</span> and the base distribution is <span class="math inline">\(N(0, 1)\)</span>.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="op">%</span>matplotlib inline</span></code></pre></div>
<div class="sourceCode" id="cb2"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> __future__ <span class="im">import</span> division</span></code></pre></div>
<div class="sourceCode" id="cb3"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> matplotlib <span class="im">import</span> pyplot <span class="im">as</span> plt</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pymc3 <span class="im">as</span> pm</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> scipy <span class="im">as</span> sp</span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> seaborn <span class="im">as</span> sns</span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> statsmodels.datasets <span class="im">import</span> get_rdataset</span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> theano <span class="im">import</span> tensor <span class="im">as</span> T</span></code></pre></div>
<pre><code>Couldn&#39;t import dot_parser, loading of dot files will not be possible.</code></pre>
<div class="sourceCode" id="cb5"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a>blue <span class="op">=</span> sns.color_palette()[<span class="dv">0</span>]</span></code></pre></div>
<div class="sourceCode" id="cb6"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a>np.random.seed(<span class="dv">462233</span>) <span class="co"># from random.org</span></span></code></pre></div>
<div class="sourceCode" id="cb7"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a>N <span class="op">=</span> <span class="dv">20</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>K <span class="op">=</span> <span class="dv">30</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>alpha <span class="op">=</span> <span class="fl">2.</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>P0 <span class="op">=</span> sp.stats.norm</span></code></pre></div>
<p>We draw and plot samples from the stick-breaking process.</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a>beta <span class="op">=</span> sp.stats.beta.rvs(<span class="dv">1</span>, alpha, size<span class="op">=</span>(N, K))</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>w <span class="op">=</span> np.empty_like(beta)</span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>w[:, <span class="dv">0</span>] <span class="op">=</span> beta[:, <span class="dv">0</span>]</span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>w[:, <span class="dv">1</span>:] <span class="op">=</span> beta[:, <span class="dv">1</span>:] <span class="op">*</span> (<span class="dv">1</span> <span class="op">-</span> beta[:, :<span class="op">-</span><span class="dv">1</span>]).cumprod(axis<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a>omega <span class="op">=</span> P0.rvs(size<span class="op">=</span>(N, K))</span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a>x_plot <span class="op">=</span> np.linspace(<span class="op">-</span><span class="dv">3</span>, <span class="dv">3</span>, <span class="dv">200</span>)</span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a>sample_cdfs <span class="op">=</span> (w[..., np.newaxis] <span class="op">*</span> np.less.outer(omega, x_plot)).<span class="bu">sum</span>(axis<span class="op">=</span><span class="dv">1</span>)</span></code></pre></div>
<div class="sourceCode" id="cb9"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots(figsize<span class="op">=</span>(<span class="dv">8</span>, <span class="dv">6</span>))</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>ax.plot(x_plot, sample_cdfs[<span class="dv">0</span>], c<span class="op">=</span><span class="st">&#39;gray&#39;</span>, alpha<span class="op">=</span><span class="fl">0.75</span>,</span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>        label<span class="op">=</span><span class="st">&#39;DP sample CDFs&#39;</span>)<span class="op">;</span></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>ax.plot(x_plot, sample_cdfs[<span class="dv">1</span>:].T, c<span class="op">=</span><span class="st">&#39;gray&#39;</span>, alpha<span class="op">=</span><span class="fl">0.75</span>)<span class="op">;</span></span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a>ax.plot(x_plot, P0.cdf(x_plot), c<span class="op">=</span><span class="st">&#39;k&#39;</span>, label<span class="op">=</span><span class="st">&#39;Base CDF&#39;</span>)<span class="op">;</span></span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a>ax.set_title(<span class="vs">r&#39;$\alpha = </span><span class="sc">{}</span><span class="vs">$&#39;</span>.<span class="bu">format</span>(alpha))<span class="op">;</span></span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a>ax.legend(loc<span class="op">=</span><span class="dv">2</span>)<span class="op">;</span></span></code></pre></div>
<center>
<img src="/resources/dpm_density/Density%20Estimation%20with%20Dirichlet%20Process%20Mixtures%20using%20PyMC3_10_0.png">
</center>
<p>As stated above, as <span class="math inline">\(\alpha \to \infty\)</span>, samples from the Dirichlet process converge to the base distribution.</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a>fig, (l_ax, r_ax) <span class="op">=</span> plt.subplots(ncols<span class="op">=</span><span class="dv">2</span>, sharex<span class="op">=</span><span class="va">True</span>, sharey<span class="op">=</span><span class="va">True</span>, figsize<span class="op">=</span>(<span class="dv">16</span>, <span class="dv">6</span>))</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>K <span class="op">=</span> <span class="dv">50</span></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>alpha <span class="op">=</span> <span class="fl">10.</span></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a>beta <span class="op">=</span> sp.stats.beta.rvs(<span class="dv">1</span>, alpha, size<span class="op">=</span>(N, K))</span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a>w <span class="op">=</span> np.empty_like(beta)</span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a>w[:, <span class="dv">0</span>] <span class="op">=</span> beta[:, <span class="dv">0</span>]</span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a>w[:, <span class="dv">1</span>:] <span class="op">=</span> beta[:, <span class="dv">1</span>:] <span class="op">*</span> (<span class="dv">1</span> <span class="op">-</span> beta[:, :<span class="op">-</span><span class="dv">1</span>]).cumprod(axis<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true" tabindex="-1"></a>omega <span class="op">=</span> P0.rvs(size<span class="op">=</span>(N, K))</span>
<span id="cb10-12"><a href="#cb10-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-13"><a href="#cb10-13" aria-hidden="true" tabindex="-1"></a>sample_cdfs <span class="op">=</span> (w[..., np.newaxis] <span class="op">*</span> np.less.outer(omega, x_plot)).<span class="bu">sum</span>(axis<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb10-14"><a href="#cb10-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-15"><a href="#cb10-15" aria-hidden="true" tabindex="-1"></a>l_ax.plot(x_plot, sample_cdfs[<span class="dv">0</span>], c<span class="op">=</span><span class="st">&#39;gray&#39;</span>, alpha<span class="op">=</span><span class="fl">0.75</span>,</span>
<span id="cb10-16"><a href="#cb10-16" aria-hidden="true" tabindex="-1"></a>          label<span class="op">=</span><span class="st">&#39;DP sample CDFs&#39;</span>)<span class="op">;</span></span>
<span id="cb10-17"><a href="#cb10-17" aria-hidden="true" tabindex="-1"></a>l_ax.plot(x_plot, sample_cdfs[<span class="dv">1</span>:].T, c<span class="op">=</span><span class="st">&#39;gray&#39;</span>, alpha<span class="op">=</span><span class="fl">0.75</span>)<span class="op">;</span></span>
<span id="cb10-18"><a href="#cb10-18" aria-hidden="true" tabindex="-1"></a>l_ax.plot(x_plot, P0.cdf(x_plot), c<span class="op">=</span><span class="st">&#39;k&#39;</span>, label<span class="op">=</span><span class="st">&#39;Base CDF&#39;</span>)<span class="op">;</span></span>
<span id="cb10-19"><a href="#cb10-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-20"><a href="#cb10-20" aria-hidden="true" tabindex="-1"></a>l_ax.set_title(<span class="vs">r&#39;$\alpha = </span><span class="sc">{}</span><span class="vs">$&#39;</span>.<span class="bu">format</span>(alpha))<span class="op">;</span></span>
<span id="cb10-21"><a href="#cb10-21" aria-hidden="true" tabindex="-1"></a>l_ax.legend(loc<span class="op">=</span><span class="dv">2</span>)<span class="op">;</span></span>
<span id="cb10-22"><a href="#cb10-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-23"><a href="#cb10-23" aria-hidden="true" tabindex="-1"></a>K <span class="op">=</span> <span class="dv">200</span></span>
<span id="cb10-24"><a href="#cb10-24" aria-hidden="true" tabindex="-1"></a>alpha <span class="op">=</span> <span class="fl">50.</span></span>
<span id="cb10-25"><a href="#cb10-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-26"><a href="#cb10-26" aria-hidden="true" tabindex="-1"></a>beta <span class="op">=</span> sp.stats.beta.rvs(<span class="dv">1</span>, alpha, size<span class="op">=</span>(N, K))</span>
<span id="cb10-27"><a href="#cb10-27" aria-hidden="true" tabindex="-1"></a>w <span class="op">=</span> np.empty_like(beta)</span>
<span id="cb10-28"><a href="#cb10-28" aria-hidden="true" tabindex="-1"></a>w[:, <span class="dv">0</span>] <span class="op">=</span> beta[:, <span class="dv">0</span>]</span>
<span id="cb10-29"><a href="#cb10-29" aria-hidden="true" tabindex="-1"></a>w[:, <span class="dv">1</span>:] <span class="op">=</span> beta[:, <span class="dv">1</span>:] <span class="op">*</span> (<span class="dv">1</span> <span class="op">-</span> beta[:, :<span class="op">-</span><span class="dv">1</span>]).cumprod(axis<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb10-30"><a href="#cb10-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-31"><a href="#cb10-31" aria-hidden="true" tabindex="-1"></a>omega <span class="op">=</span> P0.rvs(size<span class="op">=</span>(N, K))</span>
<span id="cb10-32"><a href="#cb10-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-33"><a href="#cb10-33" aria-hidden="true" tabindex="-1"></a>sample_cdfs <span class="op">=</span> (w[..., np.newaxis] <span class="op">*</span> np.less.outer(omega, x_plot)).<span class="bu">sum</span>(axis<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb10-34"><a href="#cb10-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-35"><a href="#cb10-35" aria-hidden="true" tabindex="-1"></a>r_ax.plot(x_plot, sample_cdfs[<span class="dv">0</span>], c<span class="op">=</span><span class="st">&#39;gray&#39;</span>, alpha<span class="op">=</span><span class="fl">0.75</span>,</span>
<span id="cb10-36"><a href="#cb10-36" aria-hidden="true" tabindex="-1"></a>          label<span class="op">=</span><span class="st">&#39;DP sample CDFs&#39;</span>)<span class="op">;</span></span>
<span id="cb10-37"><a href="#cb10-37" aria-hidden="true" tabindex="-1"></a>r_ax.plot(x_plot, sample_cdfs[<span class="dv">1</span>:].T, c<span class="op">=</span><span class="st">&#39;gray&#39;</span>, alpha<span class="op">=</span><span class="fl">0.75</span>)<span class="op">;</span></span>
<span id="cb10-38"><a href="#cb10-38" aria-hidden="true" tabindex="-1"></a>r_ax.plot(x_plot, P0.cdf(x_plot), c<span class="op">=</span><span class="st">&#39;k&#39;</span>, label<span class="op">=</span><span class="st">&#39;Base CDF&#39;</span>)<span class="op">;</span></span>
<span id="cb10-39"><a href="#cb10-39" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-40"><a href="#cb10-40" aria-hidden="true" tabindex="-1"></a>r_ax.set_title(<span class="vs">r&#39;$\alpha = </span><span class="sc">{}</span><span class="vs">$&#39;</span>.<span class="bu">format</span>(alpha))<span class="op">;</span></span>
<span id="cb10-41"><a href="#cb10-41" aria-hidden="true" tabindex="-1"></a>r_ax.legend(loc<span class="op">=</span><span class="dv">2</span>)<span class="op">;</span></span></code></pre></div>
<center>
<img src="/resources/dpm_density/Density%20Estimation%20with%20Dirichlet%20Process%20Mixtures%20using%20PyMC3_12_0.png">
</center>
<h3 id="dirichlet-process-mixtures">Dirichlet process mixtures</h3>
<p>For the task of density estimation, the (almost sure) discreteness of samples from the Dirichlet process is a significant drawback. This problem can be solved with another level of indirection by using Dirichlet process mixtures for density estimation. A Dirichlet process mixture uses component densities from a parametric family <span class="math inline">\(\mathcal{F} = \{f_{\theta}\ |\ \theta \in \Theta\}\)</span> and represents the mixture weights as a Dirichlet process. If <span class="math inline">\(P_0\)</span> is a probability measure on the parameter space <span class="math inline">\(\Theta\)</span>, a Dirichlet process mixture is the hierarchical model</p>
<p><span class="math display">\[
\begin{align*}
    x_i\ |\ \theta_i
        &amp; \sim f_{\theta_i} \\
    \theta_1, \ldots, \theta_n
        &amp; \sim P \\
    P
        &amp; \sim \textrm{DP}(\alpha, P_0).
\end{align*}
\]</span></p>
<p>To illustrate this model, we simulate draws from a Dirichlet process mixture with <span class="math inline">\(\alpha = 2\)</span>, <span class="math inline">\(\theta \sim N(0, 1)\)</span>, <span class="math inline">\(x\ |\ \theta \sim N(\theta, (0.3)^2)\)</span>.</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a>N <span class="op">=</span> <span class="dv">5</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>K <span class="op">=</span> <span class="dv">30</span></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a>alpha <span class="op">=</span> <span class="dv">2</span></span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a>P0 <span class="op">=</span> sp.stats.norm</span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a>f <span class="op">=</span> <span class="kw">lambda</span> x, theta: sp.stats.norm.pdf(x, theta, <span class="fl">0.3</span>)</span></code></pre></div>
<div class="sourceCode" id="cb12"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a>beta <span class="op">=</span> sp.stats.beta.rvs(<span class="dv">1</span>, alpha, size<span class="op">=</span>(N, K))</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>w <span class="op">=</span> np.empty_like(beta)</span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>w[:, <span class="dv">0</span>] <span class="op">=</span> beta[:, <span class="dv">0</span>]</span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>w[:, <span class="dv">1</span>:] <span class="op">=</span> beta[:, <span class="dv">1</span>:] <span class="op">*</span> (<span class="dv">1</span> <span class="op">-</span> beta[:, :<span class="op">-</span><span class="dv">1</span>]).cumprod(axis<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a>theta <span class="op">=</span> P0.rvs(size<span class="op">=</span>(N, K))</span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a>dpm_pdf_components <span class="op">=</span> f(x_plot[np.newaxis, np.newaxis, :], theta[..., np.newaxis])</span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true" tabindex="-1"></a>dpm_pdfs <span class="op">=</span> (w[..., np.newaxis] <span class="op">*</span> dpm_pdf_components).<span class="bu">sum</span>(axis<span class="op">=</span><span class="dv">1</span>)</span></code></pre></div>
<div class="sourceCode" id="cb13"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots(figsize<span class="op">=</span>(<span class="dv">8</span>, <span class="dv">6</span>))</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>ax.plot(x_plot, dpm_pdfs.T, c<span class="op">=</span><span class="st">&#39;gray&#39;</span>)<span class="op">;</span></span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a>ax.set_yticklabels([])<span class="op">;</span></span></code></pre></div>
<center>
<img src="/resources/dpm_density/Density%20Estimation%20with%20Dirichlet%20Process%20Mixtures%20using%20PyMC3_16_0.png">
</center>
<p>We now focus on a single mixture and decompose it into its individual (weighted) mixture components.</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots(figsize<span class="op">=</span>(<span class="dv">8</span>, <span class="dv">6</span>))</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>ix <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a>ax.plot(x_plot, dpm_pdfs[ix], c<span class="op">=</span><span class="st">&#39;k&#39;</span>, label<span class="op">=</span><span class="st">&#39;Density&#39;</span>)<span class="op">;</span></span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a>ax.plot(x_plot, (w[..., np.newaxis] <span class="op">*</span> dpm_pdf_components)[ix, <span class="dv">0</span>],</span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true" tabindex="-1"></a>        <span class="st">&#39;--&#39;</span>, c<span class="op">=</span><span class="st">&#39;k&#39;</span>, label<span class="op">=</span><span class="st">&#39;Mixture components (weighted)&#39;</span>)<span class="op">;</span></span>
<span id="cb14-8"><a href="#cb14-8" aria-hidden="true" tabindex="-1"></a>ax.plot(x_plot, (w[..., np.newaxis] <span class="op">*</span> dpm_pdf_components)[ix].T,</span>
<span id="cb14-9"><a href="#cb14-9" aria-hidden="true" tabindex="-1"></a>        <span class="st">&#39;--&#39;</span>, c<span class="op">=</span><span class="st">&#39;k&#39;</span>)<span class="op">;</span></span>
<span id="cb14-10"><a href="#cb14-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-11"><a href="#cb14-11" aria-hidden="true" tabindex="-1"></a>ax.set_yticklabels([])<span class="op">;</span></span>
<span id="cb14-12"><a href="#cb14-12" aria-hidden="true" tabindex="-1"></a>ax.legend(loc<span class="op">=</span><span class="dv">1</span>)<span class="op">;</span></span></code></pre></div>
<center>
<img src="/resources/dpm_density/Density%20Estimation%20with%20Dirichlet%20Process%20Mixtures%20using%20PyMC3_18_0.png">
</center>
<p>Sampling from these stochastic processes is fun, but these ideas become truly useful when we fit them to data. The discreteness of samples and the stick-breaking representation of the Dirichlet process lend themselves nicely to Markov chain Monte Carlo simulation of posterior distributions. We will perform this sampling using <a href="https://pymc-devs.github.io/pymc3/"><code>pymc3</code></a>.</p>
<p>Our first example uses a Dirichlet process mixture to estimate the density of waiting times between eruptions of the <a href="https://en.wikipedia.org/wiki/Old_Faithful">Old Faithful</a> geyser in <a href="https://en.wikipedia.org/wiki/Yellowstone_National_Park">Yellowstone National Park</a>.</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a>old_faithful_df <span class="op">=</span> get_rdataset(<span class="st">&#39;faithful&#39;</span>, cache<span class="op">=</span><span class="va">True</span>).data[[<span class="st">&#39;waiting&#39;</span>]]</span></code></pre></div>
<p>For convenience in specifying the prior, we standardize the waiting time between eruptions.</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a>old_faithful_df[<span class="st">&#39;std_waiting&#39;</span>] <span class="op">=</span> (old_faithful_df.waiting <span class="op">-</span> old_faithful_df.waiting.mean()) <span class="op">/</span> old_faithful_df.waiting.std()</span></code></pre></div>
<div class="sourceCode" id="cb17"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a>old_faithful_df.head()</span></code></pre></div>
<center>
<div>
<table border="1" class="dataframe">
<thead>
<tr style="text-align: right;">
<th>
</th>
<th>
waiting
</th>
<th>
std_waiting
</th>
</tr>
</thead>
<tbody>
<tr>
<th>
0
</th>
<td>
79
</td>
<td>
0.596025
</td>
</tr>
<tr>
<th>
1
</th>
<td>
54
</td>
<td>
-1.242890
</td>
</tr>
<tr>
<th>
2
</th>
<td>
74
</td>
<td>
0.228242
</td>
</tr>
<tr>
<th>
3
</th>
<td>
62
</td>
<td>
-0.654437
</td>
</tr>
<tr>
<th>
4
</th>
<td>
85
</td>
<td>
1.037364
</td>
</tr>
</tbody>
</table>
</div>
</center>
<p><br/></p>
<div class="sourceCode" id="cb18"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots(figsize<span class="op">=</span>(<span class="dv">8</span>, <span class="dv">6</span>))</span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a>n_bins <span class="op">=</span> <span class="dv">20</span></span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a>ax.hist(old_faithful_df.std_waiting, bins<span class="op">=</span>n_bins, color<span class="op">=</span>blue, lw<span class="op">=</span><span class="dv">0</span>, alpha<span class="op">=</span><span class="fl">0.5</span>)<span class="op">;</span></span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true" tabindex="-1"></a>ax.set_xlabel(<span class="st">&#39;Standardized waiting time between eruptions&#39;</span>)<span class="op">;</span></span>
<span id="cb18-7"><a href="#cb18-7" aria-hidden="true" tabindex="-1"></a>ax.set_ylabel(<span class="st">&#39;Number of eruptions&#39;</span>)<span class="op">;</span></span></code></pre></div>
<center>
<img src="/resources/dpm_density/Density%20Estimation%20with%20Dirichlet%20Process%20Mixtures%20using%20PyMC3_24_0.png">
</center>
<p>Observant readers will have noted that we have not been continuing the stick-breaking process indefinitely as indicated by its definition, but rather have been truncating this process after a finite number of breaks. Obviously, when computing with Dirichlet processes, it is necessary to only store a finite number of its point masses and weights in memory. This restriction is not terribly onerous, since with a finite number of observations, it seems quite likely that the number of mixture components that contribute non-neglible mass to the mixture will grow slower than the number of samples. This intuition can be formalized to show that the (expected) number of components that contribute non-negligible mass to the mixture approaches <span class="math inline">\(\alpha \log N\)</span>, where <span class="math inline">\(N\)</span> is the sample size.</p>
<p>There are various clever <a href="https://en.wikipedia.org/wiki/Gibbs_sampling">Gibbs sampling</a> techniques for Dirichlet processes that allow the number of components stored to grow as needed. <a href="http://danroy.org/papers/RoyManGooTen-ICMLNPB-2008.pdf">Stochastic memoization</a> is another powerful technique for simulating Dirichlet processes while only storing finitely many components in memory. In this introductory post, we take the much less sophistocated approach of simple truncating the Dirichlet process components that are stored after a fixed number, <span class="math inline">\(K\)</span>, of components. Importantly, this approach is compatible with some of <code>pymc3</code>â€™s (current) technical limitations. <a href="http://fisher.osu.edu/~schroeder.9/AMIS900/Ohlssen2006.pdf">Ohlssen, et al.</a> provide justification for truncation, showing that <span class="math inline">\(K &gt; 5 \alpha + 2\)</span> is most likely sufficient to capture almost all of the mixture weights (<span class="math inline">\(\sum_{i = 1}^{K} w_i &gt; 0.99\)</span>). We can practically verify the suitability of our truncated approximation to the Dirichlet process by checking the number of components that contribute non-negligible mass to the mixture. If, in our simulations, all components contribute non-negligible mass to the mixture, we have truncated our Dirichlet process too early.</p>
<p>Our Dirichlet process mixture model for the standardized waiting times is</p>
<p><span class="math display">\[
\begin{align*}
    x_i\ |\ \mu_i, \lambda_i, \tau_i
        &amp; \sim N\left(\mu, (\lambda_i \tau_i)^{-1}\right) \\
    \mu_i\ |\ \lambda_i, \tau_i
        &amp; \sim N\left(0, (\lambda_i \tau_i)^{-1}\right) \\
    (\lambda_1, \tau_1), (\lambda_2, \tau_2), \ldots
        &amp; \sim P \\
    P
        &amp; \sim \textrm{DP}(\alpha, U(0, 5) \times \textrm{Gamma}(1, 1)) \\
    \alpha
        &amp; \sim \textrm{Gamma}(1, 1).
\end{align*}
\]</span></p>
<p>Note that instead of fixing a value of <span class="math inline">\(\alpha\)</span>, as in our previous simulations, we specify a prior on <span class="math inline">\(\alpha\)</span>, so that we may learn its posterior distribution from the observations. This model is therefore actually a mixture of Dirichlet process mixtures, since each fixed value of <span class="math inline">\(\alpha\)</span> results in a Dirichlet process mixture.</p>
<p>We now construct this model using <code>pymc3</code>.</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a>N <span class="op">=</span> old_faithful_df.shape[<span class="dv">0</span>]</span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a>K <span class="op">=</span> <span class="dv">30</span></span></code></pre></div>
<div class="sourceCode" id="cb20"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="cf">with</span> pm.Model() <span class="im">as</span> model:</span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a>    alpha <span class="op">=</span> pm.Gamma(<span class="st">&#39;alpha&#39;</span>, <span class="fl">1.</span>, <span class="fl">1.</span>)</span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a>    beta <span class="op">=</span> pm.Beta(<span class="st">&#39;beta&#39;</span>, <span class="fl">1.</span>, alpha, shape<span class="op">=</span>K)</span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a>    w <span class="op">=</span> pm.Deterministic(<span class="st">&#39;w&#39;</span>, beta <span class="op">*</span> T.concatenate([[<span class="dv">1</span>], T.extra_ops.cumprod(<span class="dv">1</span> <span class="op">-</span> beta)[:<span class="op">-</span><span class="dv">1</span>]]))</span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true" tabindex="-1"></a>    component <span class="op">=</span> pm.Categorical(<span class="st">&#39;component&#39;</span>, w, shape<span class="op">=</span>N)</span>
<span id="cb20-6"><a href="#cb20-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-7"><a href="#cb20-7" aria-hidden="true" tabindex="-1"></a>    tau <span class="op">=</span> pm.Gamma(<span class="st">&#39;tau&#39;</span>, <span class="fl">1.</span>, <span class="fl">1.</span>, shape<span class="op">=</span>K)</span>
<span id="cb20-8"><a href="#cb20-8" aria-hidden="true" tabindex="-1"></a>    lambda_ <span class="op">=</span> pm.Uniform(<span class="st">&#39;lambda&#39;</span>, <span class="dv">0</span>, <span class="dv">5</span>, shape<span class="op">=</span>K)</span>
<span id="cb20-9"><a href="#cb20-9" aria-hidden="true" tabindex="-1"></a>    mu <span class="op">=</span> pm.Normal(<span class="st">&#39;mu&#39;</span>, <span class="dv">0</span>, lambda_ <span class="op">*</span> tau, shape<span class="op">=</span>K)</span>
<span id="cb20-10"><a href="#cb20-10" aria-hidden="true" tabindex="-1"></a>    obs <span class="op">=</span> pm.Normal(<span class="st">&#39;obs&#39;</span>, mu[component], lambda_[component] <span class="op">*</span> tau[component],</span>
<span id="cb20-11"><a href="#cb20-11" aria-hidden="true" tabindex="-1"></a>                    observed<span class="op">=</span>old_faithful_df.std_waiting.values)</span></code></pre></div>
<pre><code>Applied log-transform to alpha and added transformed alpha_log to model.
Applied logodds-transform to beta and added transformed beta_logodds to model.
Applied log-transform to tau and added transformed tau_log to model.
Applied interval-transform to lambda and added transformed lambda_interval to model.</code></pre>
<p>We sample from the posterior distribution 20,000 times, burn the first 10,000 samples, and thin to every tenth sample.</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span class="cf">with</span> model:</span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a>    step1 <span class="op">=</span> pm.Metropolis(<span class="bu">vars</span><span class="op">=</span>[alpha, beta, w, lambda_, tau, mu, obs])</span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a>    step2 <span class="op">=</span> pm.ElemwiseCategoricalStep([component], np.arange(K))</span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb22-5"><a href="#cb22-5" aria-hidden="true" tabindex="-1"></a>    trace_ <span class="op">=</span> pm.sample(<span class="dv">20000</span>, [step1, step2])</span>
<span id="cb22-6"><a href="#cb22-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-7"><a href="#cb22-7" aria-hidden="true" tabindex="-1"></a>trace <span class="op">=</span> trace_[<span class="dv">10000</span>::<span class="dv">10</span>]</span></code></pre></div>
<pre><code> [-----------------100%-----------------] 20000 of 20000 complete in 139.3 sec</code></pre>
<p>The posterior distribution of <span class="math inline">\(\alpha\)</span> is concentrated between 0.4 and 1.75.</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a>pm.traceplot(trace, varnames<span class="op">=</span>[<span class="st">&#39;alpha&#39;</span>])<span class="op">;</span></span></code></pre></div>
<center>
<img src="/resources/dpm_density/Density%20Estimation%20with%20Dirichlet%20Process%20Mixtures%20using%20PyMC3_31_0.png">
</center>
<p>To verify that our truncation point is not biasing our results, we plot the distribution of the number of mixture components used.</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a>n_components_used <span class="op">=</span> np.apply_along_axis(<span class="kw">lambda</span> x: np.unique(x).size, <span class="dv">1</span>, trace[<span class="st">&#39;component&#39;</span>])</span></code></pre></div>
<div class="sourceCode" id="cb26"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots(figsize<span class="op">=</span>(<span class="dv">8</span>, <span class="dv">6</span>))</span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true" tabindex="-1"></a>bins <span class="op">=</span> np.arange(n_components_used.<span class="bu">min</span>(), n_components_used.<span class="bu">max</span>() <span class="op">+</span> <span class="dv">1</span>)</span>
<span id="cb26-4"><a href="#cb26-4" aria-hidden="true" tabindex="-1"></a>ax.hist(n_components_used <span class="op">+</span> <span class="dv">1</span>, bins<span class="op">=</span>bins, normed<span class="op">=</span><span class="va">True</span>, lw<span class="op">=</span><span class="dv">0</span>, alpha<span class="op">=</span><span class="fl">0.75</span>)<span class="op">;</span></span>
<span id="cb26-5"><a href="#cb26-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-6"><a href="#cb26-6" aria-hidden="true" tabindex="-1"></a>ax.set_xticks(bins <span class="op">+</span> <span class="fl">0.5</span>)<span class="op">;</span></span>
<span id="cb26-7"><a href="#cb26-7" aria-hidden="true" tabindex="-1"></a>ax.set_xticklabels(bins)<span class="op">;</span></span>
<span id="cb26-8"><a href="#cb26-8" aria-hidden="true" tabindex="-1"></a>ax.set_xlim(bins.<span class="bu">min</span>(), bins.<span class="bu">max</span>() <span class="op">+</span> <span class="dv">1</span>)<span class="op">;</span></span>
<span id="cb26-9"><a href="#cb26-9" aria-hidden="true" tabindex="-1"></a>ax.set_xlabel(<span class="st">&#39;Number of mixture components used&#39;</span>)<span class="op">;</span></span>
<span id="cb26-10"><a href="#cb26-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-11"><a href="#cb26-11" aria-hidden="true" tabindex="-1"></a>ax.set_ylabel(<span class="st">&#39;Posterior probability&#39;</span>)<span class="op">;</span></span></code></pre></div>
<center>
<img src="/resources/dpm_density/Density%20Estimation%20with%20Dirichlet%20Process%20Mixtures%20using%20PyMC3_34_0.png">
</center>
<p>We see that the vast majority of samples use five mixture components, and the largest number of mixture components used by any sample is eight. Since we truncated our Dirichlet process mixture at thirty components, we can be quite sure that truncation did not bias our results.</p>
<p>We now compute and plot our posterior density estimate.</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a>post_pdf_contribs <span class="op">=</span> sp.stats.norm.pdf(np.atleast_3d(x_plot),</span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a>                                      trace[<span class="st">&#39;mu&#39;</span>][:, np.newaxis, :],</span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true" tabindex="-1"></a>                                      <span class="fl">1.</span> <span class="op">/</span> np.sqrt(trace[<span class="st">&#39;lambda&#39;</span>] <span class="op">*</span> trace[<span class="st">&#39;tau&#39;</span>])[:, np.newaxis, :])</span>
<span id="cb27-4"><a href="#cb27-4" aria-hidden="true" tabindex="-1"></a>post_pdfs <span class="op">=</span> (trace[<span class="st">&#39;w&#39;</span>][:, np.newaxis, :] <span class="op">*</span> post_pdf_contribs).<span class="bu">sum</span>(axis<span class="op">=-</span><span class="dv">1</span>)</span>
<span id="cb27-5"><a href="#cb27-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-6"><a href="#cb27-6" aria-hidden="true" tabindex="-1"></a>post_pdf_low, post_pdf_high <span class="op">=</span> np.percentile(post_pdfs, [<span class="fl">2.5</span>, <span class="fl">97.5</span>], axis<span class="op">=</span><span class="dv">0</span>)</span></code></pre></div>
<div class="sourceCode" id="cb28"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots(figsize<span class="op">=</span>(<span class="dv">8</span>, <span class="dv">6</span>))</span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-3"><a href="#cb28-3" aria-hidden="true" tabindex="-1"></a>n_bins <span class="op">=</span> <span class="dv">20</span></span>
<span id="cb28-4"><a href="#cb28-4" aria-hidden="true" tabindex="-1"></a>ax.hist(old_faithful_df.std_waiting.values, bins<span class="op">=</span>n_bins, normed<span class="op">=</span><span class="va">True</span>,</span>
<span id="cb28-5"><a href="#cb28-5" aria-hidden="true" tabindex="-1"></a>        color<span class="op">=</span>blue, lw<span class="op">=</span><span class="dv">0</span>, alpha<span class="op">=</span><span class="fl">0.5</span>)<span class="op">;</span></span>
<span id="cb28-6"><a href="#cb28-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-7"><a href="#cb28-7" aria-hidden="true" tabindex="-1"></a>ax.fill_between(x_plot, post_pdf_low, post_pdf_high,</span>
<span id="cb28-8"><a href="#cb28-8" aria-hidden="true" tabindex="-1"></a>                color<span class="op">=</span><span class="st">&#39;gray&#39;</span>, alpha<span class="op">=</span><span class="fl">0.45</span>)<span class="op">;</span></span>
<span id="cb28-9"><a href="#cb28-9" aria-hidden="true" tabindex="-1"></a>ax.plot(x_plot, post_pdfs[<span class="dv">0</span>],</span>
<span id="cb28-10"><a href="#cb28-10" aria-hidden="true" tabindex="-1"></a>        c<span class="op">=</span><span class="st">&#39;gray&#39;</span>, label<span class="op">=</span><span class="st">&#39;Posterior sample densities&#39;</span>)<span class="op">;</span></span>
<span id="cb28-11"><a href="#cb28-11" aria-hidden="true" tabindex="-1"></a>ax.plot(x_plot, post_pdfs[::<span class="dv">100</span>].T, c<span class="op">=</span><span class="st">&#39;gray&#39;</span>)<span class="op">;</span></span>
<span id="cb28-12"><a href="#cb28-12" aria-hidden="true" tabindex="-1"></a>ax.plot(x_plot, post_pdfs.mean(axis<span class="op">=</span><span class="dv">0</span>),</span>
<span id="cb28-13"><a href="#cb28-13" aria-hidden="true" tabindex="-1"></a>        c<span class="op">=</span><span class="st">&#39;k&#39;</span>, label<span class="op">=</span><span class="st">&#39;Posterior expected density&#39;</span>)<span class="op">;</span></span>
<span id="cb28-14"><a href="#cb28-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-15"><a href="#cb28-15" aria-hidden="true" tabindex="-1"></a>ax.set_xlabel(<span class="st">&#39;Standardized waiting time between eruptions&#39;</span>)<span class="op">;</span></span>
<span id="cb28-16"><a href="#cb28-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-17"><a href="#cb28-17" aria-hidden="true" tabindex="-1"></a>ax.set_yticklabels([])<span class="op">;</span></span>
<span id="cb28-18"><a href="#cb28-18" aria-hidden="true" tabindex="-1"></a>ax.set_ylabel(<span class="st">&#39;Density&#39;</span>)<span class="op">;</span></span>
<span id="cb28-19"><a href="#cb28-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-20"><a href="#cb28-20" aria-hidden="true" tabindex="-1"></a>ax.legend(loc<span class="op">=</span><span class="dv">2</span>)<span class="op">;</span></span></code></pre></div>
<center>
<img src="/resources/dpm_density/Density%20Estimation%20with%20Dirichlet%20Process%20Mixtures%20using%20PyMC3_37_0.png">
</center>
<p>As above, we can decompose this density estimate into its (weighted) mixture components.</p>
<div class="sourceCode" id="cb29"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots(figsize<span class="op">=</span>(<span class="dv">8</span>, <span class="dv">6</span>))</span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-3"><a href="#cb29-3" aria-hidden="true" tabindex="-1"></a>n_bins <span class="op">=</span> <span class="dv">20</span></span>
<span id="cb29-4"><a href="#cb29-4" aria-hidden="true" tabindex="-1"></a>ax.hist(old_faithful_df.std_waiting.values, bins<span class="op">=</span>n_bins, normed<span class="op">=</span><span class="va">True</span>,</span>
<span id="cb29-5"><a href="#cb29-5" aria-hidden="true" tabindex="-1"></a>        color<span class="op">=</span>blue, lw<span class="op">=</span><span class="dv">0</span>, alpha<span class="op">=</span><span class="fl">0.5</span>)<span class="op">;</span></span>
<span id="cb29-6"><a href="#cb29-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-7"><a href="#cb29-7" aria-hidden="true" tabindex="-1"></a>ax.plot(x_plot, post_pdfs.mean(axis<span class="op">=</span><span class="dv">0</span>),</span>
<span id="cb29-8"><a href="#cb29-8" aria-hidden="true" tabindex="-1"></a>        c<span class="op">=</span><span class="st">&#39;k&#39;</span>, label<span class="op">=</span><span class="st">&#39;Posterior expected density&#39;</span>)<span class="op">;</span></span>
<span id="cb29-9"><a href="#cb29-9" aria-hidden="true" tabindex="-1"></a>ax.plot(x_plot, (trace[<span class="st">&#39;w&#39;</span>][:, np.newaxis, :] <span class="op">*</span> post_pdf_contribs).mean(axis<span class="op">=</span><span class="dv">0</span>)[:, <span class="dv">0</span>],</span>
<span id="cb29-10"><a href="#cb29-10" aria-hidden="true" tabindex="-1"></a>        <span class="st">&#39;--&#39;</span>, c<span class="op">=</span><span class="st">&#39;k&#39;</span>, label<span class="op">=</span><span class="st">&#39;Posterior expected mixture</span><span class="ch">\n</span><span class="st">components</span><span class="ch">\n</span><span class="st">(weighted)&#39;</span>)<span class="op">;</span></span>
<span id="cb29-11"><a href="#cb29-11" aria-hidden="true" tabindex="-1"></a>ax.plot(x_plot, (trace[<span class="st">&#39;w&#39;</span>][:, np.newaxis, :] <span class="op">*</span> post_pdf_contribs).mean(axis<span class="op">=</span><span class="dv">0</span>),</span>
<span id="cb29-12"><a href="#cb29-12" aria-hidden="true" tabindex="-1"></a>        <span class="st">&#39;--&#39;</span>, c<span class="op">=</span><span class="st">&#39;k&#39;</span>)<span class="op">;</span></span>
<span id="cb29-13"><a href="#cb29-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-14"><a href="#cb29-14" aria-hidden="true" tabindex="-1"></a>ax.set_xlabel(<span class="st">&#39;Standardized waiting time between eruptions&#39;</span>)<span class="op">;</span></span>
<span id="cb29-15"><a href="#cb29-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-16"><a href="#cb29-16" aria-hidden="true" tabindex="-1"></a>ax.set_yticklabels([])<span class="op">;</span></span>
<span id="cb29-17"><a href="#cb29-17" aria-hidden="true" tabindex="-1"></a>ax.set_ylabel(<span class="st">&#39;Density&#39;</span>)<span class="op">;</span></span>
<span id="cb29-18"><a href="#cb29-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-19"><a href="#cb29-19" aria-hidden="true" tabindex="-1"></a>ax.legend(loc<span class="op">=</span><span class="dv">2</span>)<span class="op">;</span></span></code></pre></div>
<center>
<img src="/resources/dpm_density/Density%20Estimation%20with%20Dirichlet%20Process%20Mixtures%20using%20PyMC3_39_0.png">
</center>
<p>The Dirichlet process mixture model is incredibly flexible in terms of the family of parametric component distributions <span class="math inline">\(\{f_{\theta}\ |\ f_{\theta} \in \Theta\}\)</span>. We illustrate this flexibility below by using Poisson component distributions to estimate the density of sunspots per year.</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a>sunspot_df <span class="op">=</span> get_rdataset(<span class="st">&#39;sunspot.year&#39;</span>, cache<span class="op">=</span><span class="va">True</span>).data</span></code></pre></div>
<div class="sourceCode" id="cb31"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a>sunspot_df.head()</span></code></pre></div>
<center>
<div>
<table border="1" class="dataframe">
<thead>
<tr style="text-align: right;">
<th>
</th>
<th>
time
</th>
<th>
sunspot.year
</th>
</tr>
</thead>
<tbody>
<tr>
<th>
0
</th>
<td>
1700
</td>
<td>
5
</td>
</tr>
<tr>
<th>
1
</th>
<td>
1701
</td>
<td>
11
</td>
</tr>
<tr>
<th>
2
</th>
<td>
1702
</td>
<td>
16
</td>
</tr>
<tr>
<th>
3
</th>
<td>
1703
</td>
<td>
23
</td>
</tr>
<tr>
<th>
4
</th>
<td>
1704
</td>
<td>
36
</td>
</tr>
</tbody>
</table>
</div>
</center>
<p>For this problem, the model is</p>
<p><span class="math display">\[
\begin{align*}
    x_i\ |\ \lambda_i
        &amp; \sim \textrm{Poisson}(\lambda_i) \\
    \lambda_1, \lambda_2, \ldots
        &amp; \sim P \\
    P
        &amp; \sim \textrm{DP}(\alpha, U(0, 300)) \\
    \alpha
        &amp; \sim \textrm{Gamma}(1, 1).
\end{align*}
\]</span></p>
<div class="sourceCode" id="cb32"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a>N <span class="op">=</span> sunspot_df.shape[<span class="dv">0</span>]</span>
<span id="cb32-2"><a href="#cb32-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-3"><a href="#cb32-3" aria-hidden="true" tabindex="-1"></a>K <span class="op">=</span> <span class="dv">30</span></span></code></pre></div>
<div class="sourceCode" id="cb33"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a><span class="cf">with</span> pm.Model() <span class="im">as</span> model:</span>
<span id="cb33-2"><a href="#cb33-2" aria-hidden="true" tabindex="-1"></a>    alpha <span class="op">=</span> pm.Gamma(<span class="st">&#39;alpha&#39;</span>, <span class="fl">1.</span>, <span class="fl">1.</span>)</span>
<span id="cb33-3"><a href="#cb33-3" aria-hidden="true" tabindex="-1"></a>    beta <span class="op">=</span> pm.Beta(<span class="st">&#39;beta&#39;</span>, <span class="dv">1</span>, alpha, shape<span class="op">=</span>K)</span>
<span id="cb33-4"><a href="#cb33-4" aria-hidden="true" tabindex="-1"></a>    w <span class="op">=</span> pm.Deterministic(<span class="st">&#39;beta&#39;</span>, beta <span class="op">*</span> T.concatenate([[<span class="dv">1</span>], T.extra_ops.cumprod(<span class="dv">1</span> <span class="op">-</span> beta[:<span class="op">-</span><span class="dv">1</span>])]))</span>
<span id="cb33-5"><a href="#cb33-5" aria-hidden="true" tabindex="-1"></a>    component <span class="op">=</span> pm.Categorical(<span class="st">&#39;component&#39;</span>, w, shape<span class="op">=</span>N)</span>
<span id="cb33-6"><a href="#cb33-6" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb33-7"><a href="#cb33-7" aria-hidden="true" tabindex="-1"></a>    mu <span class="op">=</span> pm.Uniform(<span class="st">&#39;mu&#39;</span>, <span class="fl">0.</span>, <span class="fl">300.</span>, shape<span class="op">=</span>K)</span>
<span id="cb33-8"><a href="#cb33-8" aria-hidden="true" tabindex="-1"></a>    obs <span class="op">=</span> pm.Poisson(<span class="st">&#39;obs&#39;</span>, mu[component], observed<span class="op">=</span>sunspot_df[<span class="st">&#39;sunspot.year&#39;</span>])</span></code></pre></div>
<pre><code>Applied log-transform to alpha and added transformed alpha_log to model.
Applied logodds-transform to beta and added transformed beta_logodds to model.
Applied interval-transform to mu and added transformed mu_interval to model.</code></pre>
<div class="sourceCode" id="cb35"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true" tabindex="-1"></a><span class="cf">with</span> model:</span>
<span id="cb35-2"><a href="#cb35-2" aria-hidden="true" tabindex="-1"></a>    step1 <span class="op">=</span> pm.Metropolis(<span class="bu">vars</span><span class="op">=</span>[alpha, beta, w, mu, obs])</span>
<span id="cb35-3"><a href="#cb35-3" aria-hidden="true" tabindex="-1"></a>    step2 <span class="op">=</span> pm.ElemwiseCategoricalStep([component], np.arange(K))</span>
<span id="cb35-4"><a href="#cb35-4" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb35-5"><a href="#cb35-5" aria-hidden="true" tabindex="-1"></a>    trace_ <span class="op">=</span> pm.sample(<span class="dv">20000</span>, [step1, step2])</span></code></pre></div>
<pre><code> [-----------------100%-----------------] 20000 of 20000 complete in 111.9 sec</code></pre>
<div class="sourceCode" id="cb37"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true" tabindex="-1"></a>trace <span class="op">=</span> trace_[<span class="dv">10000</span>::<span class="dv">10</span>]</span></code></pre></div>
<p>For the sunspot model, the posterior distribution of <span class="math inline">\(\alpha\)</span> is concentrated between one and three, indicating that we should expect more components to contribute non-negligible amounts to the mixture than for the Old Faithful waiting time model.</p>
<div class="sourceCode" id="cb38"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb38-1"><a href="#cb38-1" aria-hidden="true" tabindex="-1"></a>pm.traceplot(trace, varnames<span class="op">=</span>[<span class="st">&#39;alpha&#39;</span>])<span class="op">;</span></span></code></pre></div>
<center>
<img src="/resources/dpm_density/Density%20Estimation%20with%20Dirichlet%20Process%20Mixtures%20using%20PyMC3_49_0.png">
</center>
<p>Indeed, we see that there are (on average) about ten to fifteen components used by this model.</p>
<div class="sourceCode" id="cb39"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb39-1"><a href="#cb39-1" aria-hidden="true" tabindex="-1"></a>n_components_used <span class="op">=</span> np.apply_along_axis(<span class="kw">lambda</span> x: np.unique(x).size, <span class="dv">1</span>, trace[<span class="st">&#39;component&#39;</span>])</span></code></pre></div>
<div class="sourceCode" id="cb40"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb40-1"><a href="#cb40-1" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots(figsize<span class="op">=</span>(<span class="dv">8</span>, <span class="dv">6</span>))</span>
<span id="cb40-2"><a href="#cb40-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-3"><a href="#cb40-3" aria-hidden="true" tabindex="-1"></a>bins <span class="op">=</span> np.arange(n_components_used.<span class="bu">min</span>(), n_components_used.<span class="bu">max</span>() <span class="op">+</span> <span class="dv">1</span>)</span>
<span id="cb40-4"><a href="#cb40-4" aria-hidden="true" tabindex="-1"></a>ax.hist(n_components_used <span class="op">+</span> <span class="dv">1</span>, bins<span class="op">=</span>bins, normed<span class="op">=</span><span class="va">True</span>, lw<span class="op">=</span><span class="dv">0</span>, alpha<span class="op">=</span><span class="fl">0.75</span>)<span class="op">;</span></span>
<span id="cb40-5"><a href="#cb40-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-6"><a href="#cb40-6" aria-hidden="true" tabindex="-1"></a>ax.set_xticks(bins <span class="op">+</span> <span class="fl">0.5</span>)<span class="op">;</span></span>
<span id="cb40-7"><a href="#cb40-7" aria-hidden="true" tabindex="-1"></a>ax.set_xticklabels(bins)<span class="op">;</span></span>
<span id="cb40-8"><a href="#cb40-8" aria-hidden="true" tabindex="-1"></a>ax.set_xlim(bins.<span class="bu">min</span>(), bins.<span class="bu">max</span>() <span class="op">+</span> <span class="dv">1</span>)<span class="op">;</span></span>
<span id="cb40-9"><a href="#cb40-9" aria-hidden="true" tabindex="-1"></a>ax.set_xlabel(<span class="st">&#39;Number of mixture components used&#39;</span>)<span class="op">;</span></span>
<span id="cb40-10"><a href="#cb40-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-11"><a href="#cb40-11" aria-hidden="true" tabindex="-1"></a>ax.set_ylabel(<span class="st">&#39;Posterior probability&#39;</span>)<span class="op">;</span></span></code></pre></div>
<center>
<img src="/resources/dpm_density/Density%20Estimation%20with%20Dirichlet%20Process%20Mixtures%20using%20PyMC3_52_0.png">
</center>
<p>We now calculate and plot the fitted density estimate.</p>
<div class="sourceCode" id="cb41"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb41-1"><a href="#cb41-1" aria-hidden="true" tabindex="-1"></a>x_plot <span class="op">=</span> np.arange(<span class="dv">250</span>)</span></code></pre></div>
<div class="sourceCode" id="cb42"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb42-1"><a href="#cb42-1" aria-hidden="true" tabindex="-1"></a>post_pmf_contribs <span class="op">=</span> sp.stats.poisson.pmf(np.atleast_3d(x_plot),</span>
<span id="cb42-2"><a href="#cb42-2" aria-hidden="true" tabindex="-1"></a>                                         trace[<span class="st">&#39;mu&#39;</span>][:, np.newaxis, :])</span>
<span id="cb42-3"><a href="#cb42-3" aria-hidden="true" tabindex="-1"></a>post_pmfs <span class="op">=</span> (trace[<span class="st">&#39;beta&#39;</span>][:, np.newaxis, :] <span class="op">*</span> post_pmf_contribs).<span class="bu">sum</span>(axis<span class="op">=-</span><span class="dv">1</span>)</span>
<span id="cb42-4"><a href="#cb42-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-5"><a href="#cb42-5" aria-hidden="true" tabindex="-1"></a>post_pmf_low, post_pmf_high <span class="op">=</span> np.percentile(post_pmfs, [<span class="fl">2.5</span>, <span class="fl">97.5</span>], axis<span class="op">=</span><span class="dv">0</span>)</span></code></pre></div>
<div class="sourceCode" id="cb43"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb43-1"><a href="#cb43-1" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots(figsize<span class="op">=</span>(<span class="dv">8</span>, <span class="dv">6</span>))</span>
<span id="cb43-2"><a href="#cb43-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb43-3"><a href="#cb43-3" aria-hidden="true" tabindex="-1"></a>ax.hist(sunspot_df[<span class="st">&#39;sunspot.year&#39;</span>].values, bins<span class="op">=</span><span class="dv">40</span>, normed<span class="op">=</span><span class="va">True</span>, lw<span class="op">=</span><span class="dv">0</span>, alpha<span class="op">=</span><span class="fl">0.75</span>)<span class="op">;</span></span>
<span id="cb43-4"><a href="#cb43-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb43-5"><a href="#cb43-5" aria-hidden="true" tabindex="-1"></a>ax.fill_between(x_plot, post_pmf_low, post_pmf_high,</span>
<span id="cb43-6"><a href="#cb43-6" aria-hidden="true" tabindex="-1"></a>                 color<span class="op">=</span><span class="st">&#39;gray&#39;</span>, alpha<span class="op">=</span><span class="fl">0.45</span>)</span>
<span id="cb43-7"><a href="#cb43-7" aria-hidden="true" tabindex="-1"></a>ax.plot(x_plot, post_pmfs[<span class="dv">0</span>],</span>
<span id="cb43-8"><a href="#cb43-8" aria-hidden="true" tabindex="-1"></a>        c<span class="op">=</span><span class="st">&#39;gray&#39;</span>, label<span class="op">=</span><span class="st">&#39;Posterior sample densities&#39;</span>)<span class="op">;</span></span>
<span id="cb43-9"><a href="#cb43-9" aria-hidden="true" tabindex="-1"></a>ax.plot(x_plot, post_pmfs[::<span class="dv">200</span>].T, c<span class="op">=</span><span class="st">&#39;gray&#39;</span>)<span class="op">;</span></span>
<span id="cb43-10"><a href="#cb43-10" aria-hidden="true" tabindex="-1"></a>ax.plot(x_plot, post_pmfs.mean(axis<span class="op">=</span><span class="dv">0</span>),</span>
<span id="cb43-11"><a href="#cb43-11" aria-hidden="true" tabindex="-1"></a>        c<span class="op">=</span><span class="st">&#39;k&#39;</span>, label<span class="op">=</span><span class="st">&#39;Posterior expected density&#39;</span>)<span class="op">;</span></span>
<span id="cb43-12"><a href="#cb43-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb43-13"><a href="#cb43-13" aria-hidden="true" tabindex="-1"></a>ax.legend(loc<span class="op">=</span><span class="dv">1</span>)<span class="op">;</span></span></code></pre></div>
<center>
<img src="/resources/dpm_density/Density%20Estimation%20with%20Dirichlet%20Process%20Mixtures%20using%20PyMC3_56_0.png">
</center>
<p>Again, we can decompose the posterior expected density into weighted mixture densities.</p>
<div class="sourceCode" id="cb44"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb44-1"><a href="#cb44-1" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots(figsize<span class="op">=</span>(<span class="dv">8</span>, <span class="dv">6</span>))</span>
<span id="cb44-2"><a href="#cb44-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb44-3"><a href="#cb44-3" aria-hidden="true" tabindex="-1"></a>ax.hist(sunspot_df[<span class="st">&#39;sunspot.year&#39;</span>].values, bins<span class="op">=</span><span class="dv">40</span>, normed<span class="op">=</span><span class="va">True</span>, lw<span class="op">=</span><span class="dv">0</span>, alpha<span class="op">=</span><span class="fl">0.75</span>)<span class="op">;</span></span>
<span id="cb44-4"><a href="#cb44-4" aria-hidden="true" tabindex="-1"></a>ax.plot(x_plot, post_pmfs.mean(axis<span class="op">=</span><span class="dv">0</span>),</span>
<span id="cb44-5"><a href="#cb44-5" aria-hidden="true" tabindex="-1"></a>        c<span class="op">=</span><span class="st">&#39;k&#39;</span>, label<span class="op">=</span><span class="st">&#39;Posterior expected density&#39;</span>)<span class="op">;</span></span>
<span id="cb44-6"><a href="#cb44-6" aria-hidden="true" tabindex="-1"></a>ax.plot(x_plot, (trace[<span class="st">&#39;beta&#39;</span>][:, np.newaxis, :] <span class="op">*</span> post_pmf_contribs).mean(axis<span class="op">=</span><span class="dv">0</span>)[:, <span class="dv">0</span>],</span>
<span id="cb44-7"><a href="#cb44-7" aria-hidden="true" tabindex="-1"></a>        <span class="st">&#39;--&#39;</span>, c<span class="op">=</span><span class="st">&#39;k&#39;</span>, label<span class="op">=</span><span class="st">&#39;Posterior expected</span><span class="ch">\n</span><span class="st">mixture components</span><span class="ch">\n</span><span class="st">(weighted)&#39;</span>)<span class="op">;</span></span>
<span id="cb44-8"><a href="#cb44-8" aria-hidden="true" tabindex="-1"></a>ax.plot(x_plot, (trace[<span class="st">&#39;beta&#39;</span>][:, np.newaxis, :] <span class="op">*</span> post_pmf_contribs).mean(axis<span class="op">=</span><span class="dv">0</span>),</span>
<span id="cb44-9"><a href="#cb44-9" aria-hidden="true" tabindex="-1"></a>        <span class="st">&#39;--&#39;</span>, c<span class="op">=</span><span class="st">&#39;k&#39;</span>)<span class="op">;</span></span>
<span id="cb44-10"><a href="#cb44-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb44-11"><a href="#cb44-11" aria-hidden="true" tabindex="-1"></a>ax.legend(loc<span class="op">=</span><span class="dv">1</span>)<span class="op">;</span></span></code></pre></div>
<center>
<img src="/resources/dpm_density/Density%20Estimation%20with%20Dirichlet%20Process%20Mixtures%20using%20PyMC3_58_0.png">
</center>
<p>We have only scratched the surface in terms of applications of the Dirichlet process and Bayesian nonparametric statistics in general. This post is the first in a series I have planned on Bayesian nonparametrics, so stay tuned.</p>
<p>This post is available as an <a href="http://ipython.org/">IPython</a> notebook <a href="https://nbviewer.jupyter.org/gist/AustinRochford/62c283a3f0fae90b5e39">here</a>.</p>
