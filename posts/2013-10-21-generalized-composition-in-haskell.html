<meta name="title" content="Generalized Composition in Haskell" />
<meta name="tags" content="Haskell, Functional Programming" />
<meta name="date" content="2013-10-21" />
<meta name="has_math" content="true" /><p>To me, the most beautiful Haskell code is <a href="http://www.haskell.org/haskellwiki/Pointfree">point-free</a>. As an example of the point-free style, consider the following function which determines the length of a list.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="ot">length&#39; ::</span> [a] <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>length&#39; <span class="ot">=</span> <span class="fu">sum</span> <span class="op">.</span> <span class="fu">map</span> (<span class="fu">const</span> <span class="dv">1</span>)</span></code></pre></div>
<p>As my knowledge of Haskell has deepened, my appreciation for the ability of the combinators provided by libraries such as <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Control-Arrow.html"><code>Control.Arrow</code></a>, <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Control-Monad.html"><code>Control.Monad</code></a>, <a href="http://www.haskell.org/ghc/docs/latest/html/libraries/base/Control-Applicative.html"><code>Control.Applicative</code></a>, <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Either.html"><code>Data.Either</code></a>, and <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Maybe.html"><code>Data.Maybe</code></a>, to express more complicated functions in the point-free style has grown. (Note that all of these libraries are also important for reasons other than writing point-free code.)</p>
<p>Point-free Haskell makes liberal use of the composition operator, <code>(.)</code>. Recall that the definition of composition is</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="ot">(.) ::</span> (b <span class="ot">-&gt;</span> c) <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> c</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>(f <span class="op">.</span> g) x <span class="ot">=</span> f <span class="op">$</span> g x</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>          <span class="ot">=</span> f (g x)</span></code></pre></div>
<p>While this operator is immensely useful, it cannot express all forms of composition. For example, consider the problem of determining whether nor not any elements of a list satisfy a predicate (like <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-List.html#g:4"><code>any</code></a> from <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-List.html"><code>Data.List</code></a>). Written in the pointed style, such a function is simple.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="ot">any&#39; ::</span> (a <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>any&#39; p xs <span class="ot">=</span> <span class="fu">not</span> <span class="op">$</span> <span class="fu">null</span> <span class="op">$</span> <span class="fu">filter</span> p xs</span></code></pre></div>
<p>This function is an excellent candidate to be refactored to be point-free. In fact, whenever the last argument of a function <em>only</em> appears in the last (rightmost) place in its definition, it may be refactored to be point free. For <code>any'</code>, we refactor as</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a>any&#39; p <span class="ot">=</span> <span class="fu">not</span> <span class="op">.</span> <span class="fu">null</span> <span class="op">.</span> <span class="fu">filter</span> p</span></code></pre></div>
<p>We see again that, by our heuristic, this function should be able to be refactored to be completely point-free by removing the predicate <code>p</code>.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a>any&#39; <span class="ot">=</span> <span class="fu">not</span> <span class="op">.</span> <span class="fu">null</span> <span class="op">.</span> <span class="fu">filter</span></span></code></pre></div>
<p>Unfortunately, this implementation of <code>any'</code> will not type-check, giving the following error.</p>
<pre><code>Couldn&#39;t match expected type `[a0]&#39; with actual type `[a1] -&gt; [a1]&#39;
    Expected type: (a1 -&gt; Bool) -&gt; [a0]
      Actual type: (a1 -&gt; Bool) -&gt; [a1] -&gt; [a1]
    In the second argument of `(.)&#39;, namely `filter&#39;
    In the second argument of `(.)&#39;, namely `null . filter&#39;</code></pre>
<p>There problem is that <code>filter :: (a -&gt; Bool) -&gt; [a] -&gt; [a]</code> is a function of two arguments, but composition, <code>(.)</code>, expects a function of one argument. It is simple enough to define a function that does the sort of composition we need,</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="ot">(##) ::</span> (c <span class="ot">-&gt;</span> d) <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> c) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> d</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>(f <span class="op">##</span> g) x y <span class="ot">=</span> f <span class="op">$</span> g x y</span></code></pre></div>
<p>Using this function, we may implement <code>any'</code> in a completely point-free manner as</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a>any&#39; <span class="ot">=</span> (<span class="fu">not</span> <span class="op">.</span> <span class="fu">null</span>) <span class="op">##</span> <span class="fu">filter</span></span></code></pre></div>
<p>This implementation is nice, be we have really just pushed the pointed code into <code>(##)</code>. Before finding a point-free implementation of <code>(##)</code>, letâ€™s rewrite this definition a bit.</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a>(f <span class="op">##</span> g) x y <span class="ot">=</span> f <span class="op">$</span> g x y</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>             <span class="ot">=</span> f <span class="op">$</span> (g x) y</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>             <span class="ot">=</span> f <span class="op">.</span> (g x) <span class="op">$</span> y</span></code></pre></div>
<p>So we may move one step closer to a point-free implementation with</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a>(f <span class="op">##</span> g) x <span class="ot">=</span> f <span class="op">.</span> (g x)</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>           <span class="ot">=</span> (f <span class="op">.</span>) (g x)</span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>           <span class="ot">=</span> (f <span class="op">.</span>) <span class="op">$</span> g x</span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>           <span class="ot">=</span> (f <span class="op">.</span>) <span class="op">.</span> g <span class="op">$</span> x</span></code></pre></div>
<p>Therefore</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a>(f <span class="op">##</span> g) <span class="ot">=</span> (f <span class="op">.</span>) <span class="op">.</span> g</span></code></pre></div>
<p>This implementation is still not quite point-free, so we write</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a>(f <span class="op">##</span> g) <span class="ot">=</span> (f <span class="op">.</span>) <span class="op">.</span> g</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>         <span class="ot">=</span> (<span class="op">.</span>) (f <span class="op">.</span>) g</span></code></pre></div>
<p>so</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a>(<span class="op">##</span>) f <span class="ot">=</span> (<span class="op">.</span>) (f <span class="op">.</span>)</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>       <span class="ot">=</span> (<span class="op">.</span>) ((<span class="op">.</span>) f)</span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>       <span class="ot">=</span> ((<span class="op">.</span>) <span class="op">.</span> (<span class="op">.</span>)) f</span></code></pre></div>
<p>Therefore, the point-free implementation of <code>(##)</code> is</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a>(<span class="op">##</span>) <span class="ot">=</span> ((<span class="op">.</span>) <span class="op">.</span> (<span class="op">.</span>))</span></code></pre></div>
<p>This implementation is a bit mind-bending at first, but really cool once you wrap your head around it.</p>
