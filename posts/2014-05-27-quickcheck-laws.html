<meta name="title" content="Verifying Typeclass Laws in Haskell with QuickCheck" />
<meta name="tags" content="Haskell, Testing" />
<meta name="date" content="2014-05-27" />
<meta name="has_math" content="true" /><p>Recently, I was somewhat idly thinking about how to verify that Haskell typeclasses satisfy the appropriate laws. My first thought was to use equational reasoning to prove that the laws hold. For example, to verify that the left identity law holds for the <code>Maybe</code> monad, we can show that</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="fu">return</span> x <span class="op">&gt;&gt;=</span> f <span class="ot">=</span> <span class="dt">Just</span> x <span class="op">&gt;&gt;=</span> f <span class="ot">=</span> f x</span></code></pre></div>
<p>While this proof is simple (due to the simplicity of the <code>Maybe</code> monad), I wanted a solution expressed in executable Haskell that could be included in a test suite. As with many Haskell testing problems, <a href="http://hackage.haskell.org/package/QuickCheck"><code>QuickCheck</code></a> seemed to be a natural solution. In this post, Iâ€™ll show how to verify typeclass laws using <code>QuickCheck</code> for the classes <code>Monoid</code>, <code>Functor</code>, and <code>Monad</code>.</p>
<h4 id="monoids">Monoids</h4>
<p>The definition of the <code>Monoid</code> typeclass is</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">Monoid</span> a <span class="kw">where</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="ot">  mappend ::</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span class="ot">  mempty ::</span> a</span></code></pre></div>
<p>The module <a href="http://hackage.haskell.org/package/base-4.7.0.0/docs/Data-Monoid.html"><code>Data.Monoid</code></a> defines the infix operator <code>(&lt;&gt;)</code> as a synonym for <code>mappend</code>. We will use the more consise operator form here.</p>
<p>An instance of <code>Monoid</code> must satisy the associative law</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>x <span class="op">&lt;&gt;</span> (y <span class="op">&lt;&gt;</span> z) <span class="op">==</span> (x <span class="op">&lt;&gt;</span> y) <span class="op">&lt;&gt;</span> z</span></code></pre></div>
<p>and the identity laws</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a>x <span class="op">&lt;&gt;</span> <span class="fu">mempty</span> <span class="op">==</span> x</span></code></pre></div>
<p>and</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="fu">mempty</span> <span class="op">&lt;&gt;</span> x <span class="op">==</span> x</span></code></pre></div>
<p>We begin by writing a proposition to test the assocative law, which is fairly straightforward.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE ViewPatterns #-}</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> <span class="dt">Laws</span> <span class="kw">where</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Control.Applicative</span> ((&lt;$&gt;))</span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Monoid</span></span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Test.QuickCheck</span></span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Test.QuickCheck.Function</span></span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Test.QuickCheck.Gen</span></span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true" tabindex="-1"></a><span class="ot">monoidAssocProp ::</span> (<span class="dt">Eq</span> m, <span class="dt">Monoid</span> m) <span class="ot">=&gt;</span> m <span class="ot">-&gt;</span> m <span class="ot">-&gt;</span> m <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb6-14"><a href="#cb6-14" aria-hidden="true" tabindex="-1"></a>monoidAssocProp x y z <span class="ot">=</span> (x <span class="op">&lt;&gt;</span> (y <span class="op">&lt;&gt;</span> z)) <span class="op">==</span> ((x <span class="op">&lt;&gt;</span> y) <span class="op">&lt;&gt;</span> z)</span></code></pre></div>
<p>We can use this code to test the <code>Monoid</code> instance of <code>[Int]</code> as follows.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;</span> quickCheck (<span class="ot">monoidAssocProp ::</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">Bool</span>)</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a><span class="op">+++</span> <span class="dt">OK</span>, passed <span class="dv">100</span> tests<span class="op">.</span></span></code></pre></div>
<p>It is important to include the type annotation, as <code>monoidAssocProp</code> is written to be applicable to any monoid (technically any monoid that is also an instance of <code>Eq</code>, but this restriction is not too onerous).</p>
<p>Similarly, we can test the right and left identity laws as follows.</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="ot">monoidRightIdProp ::</span> (<span class="dt">Eq</span> m, <span class="dt">Monoid</span> m) <span class="ot">=&gt;</span> m <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>monoidRightIdProp x <span class="ot">=</span> x <span class="op">==</span> (x <span class="op">&lt;&gt;</span> <span class="fu">mempty</span>)</span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a><span class="ot">monoidLeftIdProp ::</span> (<span class="dt">Eq</span> m, <span class="dt">Monoid</span> m) <span class="ot">=&gt;</span> m <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>monoidLeftIdProp x <span class="ot">=</span> (<span class="fu">mempty</span> <span class="op">&lt;&gt;</span> x) <span class="op">==</span> x</span></code></pre></div>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;</span> quickCheck (<span class="ot">monoidRightIdProp ::</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">Bool</span>)</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a><span class="op">+++</span> <span class="dt">OK</span>, passed <span class="dv">100</span> tests<span class="op">.</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;</span> quickCheck (<span class="ot">monoidLeftIdProp ::</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">Bool</span>)</span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a><span class="op">+++</span> <span class="dt">OK</span>, passed <span class="dv">100</span> tests<span class="op">.</span></span></code></pre></div>
<p>At this point, we can feel reasonable sure that the <code>Monoid</code> instance of <code>[Int]</code> satisfies the monoid laws. <code>QuickCheck</code> supports testing many monoids out-of-the-box in this manner, but others require more work on our part.</p>
<p>Suppose we would like to check the monoid laws for <code>Sum Int</code>. (Recall that <code>mappend</code> for <code>Sum Int</code> is addition and <code>mempty</code> is zero.)</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;</span> quickCheck (<span class="ot">monoidRightIdProp ::</span> <span class="dt">Sum</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span>)</span></code></pre></div>
<p>Unfortunately, this command fails with the following message.</p>
<pre><code>No instance for (Arbitrary (Sum Int))
  arising from a use of `quickCheck&#39;
Possible fix: add an instance declaration for (Arbitrary (Sum Int))
In the expression:
  quickCheck (monoidRightIdProp :: Sum Int -&gt; Bool)
In an equation for `it&#39;:
    it = quickCheck (monoidRightIdProp :: Sum Int -&gt; Bool)</code></pre>
<p>In order to generate test cases, <code>QuickCheck</code> requires the arguments of our proposition to be instances of the <code>Arbitrary</code> class. Fortunately, since <code>Int</code> is an instance of <code>Arbitrary</code>, we can quickly make <code>Sum Int</code> an instance of arbitrary as well. In fact, for any data type <code>a</code> which is an instance of <code>Arbitrary</code>, we will make <code>Sum a</code> an instance of <code>Arbitrary</code> as well.</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> (<span class="dt">Arbitrary</span> a) <span class="ot">=&gt;</span> <span class="dt">Arbitrary</span> (<span class="dt">Sum</span> a) <span class="kw">where</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>    arbitrary <span class="ot">=</span> <span class="dt">Sum</span> <span class="op">&lt;$&gt;</span> arbitrary</span></code></pre></div>
<p>Now we can verify the monoid laws for <code>Sum Int</code>.</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;</span> quickCheck (<span class="ot">monoidAssocProp ::</span> <span class="dt">Sum</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Sum</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Sum</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span>)</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a><span class="op">+++</span> <span class="dt">OK</span>, passed <span class="dv">100</span> tests<span class="op">.</span></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;</span> quickCheck (<span class="ot">monoidRightIdProp ::</span> <span class="dt">Sum</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span>)</span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a><span class="op">+++</span> <span class="dt">OK</span>, passed <span class="dv">100</span> tests<span class="op">.</span></span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;</span> quickCheck (<span class="ot">monoidLeftIdProp ::</span> <span class="dt">Sum</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span>)</span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true" tabindex="-1"></a><span class="op">+++</span> <span class="dt">OK</span>, passed <span class="dv">100</span> tests<span class="op">.</span></span></code></pre></div>
<h4 id="functors">Functors</h4>
<p>Even considering the need to define <code>Arbitrary</code> instances for some <code>Monoid</code>s, testing the monoid laws was fairly straightforward. Testing the functor laws with <code>QuickCheck</code> is a bit more involved, due to the need to generate random functions between <code>Arbitrary</code> instances.</p>
<p>The definition of the <code>Functor</code> typeclass is</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">Functor</span> f <span class="kw">where</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a><span class="ot">    fmap ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> f b</span></code></pre></div>
<p>An instance of <code>Functor</code> must satisfy the identity law</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="fu">fmap</span> <span class="fu">id</span> <span class="ot">=</span> <span class="fu">id</span></span></code></pre></div>
<p>and the composition law</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="fu">fmap</span> (f <span class="op">.</span> g) <span class="ot">=</span> <span class="fu">fmap</span> f <span class="op">.</span> <span class="fu">fmap</span> g</span></code></pre></div>
<p>Testing the identity law is relatively simple, since it does not involve arbitrary functions.</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="ot">functorIdProp ::</span> (<span class="dt">Functor</span> f, <span class="dt">Eq</span> (f a)) <span class="ot">=&gt;</span> f a <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>functorIdProp x <span class="ot">=</span> (<span class="fu">fmap</span> <span class="fu">id</span> x) <span class="op">==</span> x</span></code></pre></div>
<p>We can test the identity law for the <code>Maybe</code> functor applied to <code>String</code>s.</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;</span> quickCheck (<span class="ot">functorIdProp ::</span> <span class="dt">Maybe</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span>)</span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a><span class="op">+++</span> <span class="dt">OK</span>, passed <span class="dv">100</span> tests<span class="op">.</span></span></code></pre></div>
<p>Testing the composition law is a bit more complicated, as <code>f :: a -&gt; b</code> and <code>g :: b -&gt; c</code> may be arbitrary functions. Fortunately, <a href="http://hackage.haskell.org/package/QuickCheck-2.7.3/docs/Test-QuickCheck-Function.html"><code>Test.QuickCheck.Function</code></a> provides a way to generate arbitrary functions <code>a -&gt; b</code> (as long as <code>a</code> and <code>b</code> are instances of appropriate typeclasses). The <code>Fun</code> data type from this module represents an arbitrary function. With this module, we can write a proposition testing the composition law as follows.</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="ot">functorCompProp ::</span> (<span class="dt">Functor</span> f, <span class="dt">Eq</span> (f c)) <span class="ot">=&gt;</span> f a <span class="ot">-&gt;</span> <span class="dt">Fun</span> a b <span class="ot">-&gt;</span> <span class="dt">Fun</span> b c <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a>functorCompProp x (apply <span class="ot">-&gt;</span> f) (apply <span class="ot">-&gt;</span> g) <span class="ot">=</span> (<span class="fu">fmap</span> (g <span class="op">.</span> f) x) <span class="op">==</span> (<span class="fu">fmap</span> g <span class="op">.</span> <span class="fu">fmap</span> f <span class="op">$</span> x)</span></code></pre></div>
<p>Here we use a <a href="https://www.fpcomplete.com/school/to-infinity-and-beyond/pick-of-the-week/guide-to-ghc-extensions/pattern-and-guard-extensions#viewpatterns">view pattern</a> to extract a function <code>a -&gt; b</code> from the second argument, which has type <code>Fun a b</code>, using the <code>apply</code> function. We similarly use a view pattern to extract a function <code>b -&gt; c</code> from the third argument.</p>
<p>We can use this function to test the composition law for the list functor applied to <code>Int</code> with two functions <code>Int -&gt; Int</code> as follows</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;</span> quickCheck (<span class="ot">functorCompProp ::</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">Fun</span> <span class="dt">Int</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Fun</span> <span class="dt">Int</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span>)</span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a><span class="op">+++</span> <span class="dt">OK</span>, passed <span class="dv">100</span> tests<span class="op">.</span></span></code></pre></div>
<p>The test <code>functorCompProp</code> is rather flexible. We can test the <code>Functor</code> instance of <code>Maybe</code>, staring with <code>Int</code> and involving arbitrary functions <code>Int -&gt; String</code> and <code>String -&gt; Double</code> as follows.</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;</span> quickCheck (<span class="ot">functorCompProp ::</span> <span class="dt">Maybe</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Fun</span> <span class="dt">Int</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Fun</span> <span class="dt">String</span> <span class="dt">Double</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span>)</span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a><span class="op">+++</span> <span class="dt">OK</span>, passed <span class="dv">100</span> tests<span class="op">.</span></span></code></pre></div>
<p>For certain types, this test may take a while to run, as generating arbitrary functions can take some time for the right (or wrong, depending on your point of view) combination of domain and range types.</p>
<h4 id="monads">Monads</h4>
<p>As with functors, testing the monad laws relies heavily on the <code>Arbitrary</code> instance of <code>Fun</code>, with slightly more complicated types.</p>
<p>The definition of the <code>Monad</code> typeclass is</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">Monad</span> m <span class="kw">where</span></span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a><span class="ot">    (&gt;&gt;=) ::</span> m a <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> m b) <span class="ot">-&gt;</span> m b</span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a><span class="ot">    return ::</span> a <span class="ot">-&gt;</span> m a</span></code></pre></div>
<p>An instance of <code>Monad</code> must satisfy three laws. The first is the right identity law,</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a>x <span class="op">&gt;&gt;=</span> <span class="fu">return</span> <span class="ot">=</span> x</span></code></pre></div>
<p>The second is the left identity law,</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a><span class="fu">return</span> x <span class="op">&gt;&gt;=</span> f <span class="ot">=</span> f x</span></code></pre></div>
<p>The third is the associative law,</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a>(x <span class="op">&gt;&gt;=</span> f) <span class="op">&gt;&gt;=</span> g <span class="ot">=</span> x <span class="op">&gt;&gt;=</span> (\x&#39; <span class="ot">-&gt;</span> f x&#39; <span class="op">&gt;&gt;=</span> g)</span></code></pre></div>
<p>Testing the right identity law is fairly straightforward, because it involves no arbitrary functions.</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a><span class="ot">monadRightIdProp ::</span> (<span class="dt">Monad</span> m, <span class="dt">Eq</span> (m a)) <span class="ot">=&gt;</span> m a <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a>monadRightIdProp x <span class="ot">=</span> (x <span class="op">&gt;&gt;=</span> <span class="fu">return</span>) <span class="op">==</span> x</span></code></pre></div>
<p>We can test the right identity law for the type <code>Either String Int</code> (recall that <code>Either a</code> is a monad) as follows</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;</span> quickCheck (<span class="ot">monadRightIdProp ::</span> <span class="dt">Either</span> <span class="dt">String</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span>)</span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a><span class="op">+++</span> <span class="dt">OK</span>, passed <span class="dv">100</span> tests<span class="op">.</span></span></code></pre></div>
<p>Since the left identity law only involves one arbitrary function, it is slightly simpler to test than the associative law.</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a><span class="ot">monadLeftIdProp ::</span> (<span class="dt">Monad</span> m, <span class="dt">Eq</span> (m b)) <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Fun</span> a (m b) <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true" tabindex="-1"></a>monadLeftIdProp x (apply <span class="ot">-&gt;</span> f) <span class="ot">=</span> (<span class="fu">return</span> x <span class="op">&gt;&gt;=</span> f) <span class="op">==</span> (f x)</span></code></pre></div>
<p>We can verify the left identity law for <code>[Int]</code> as follows.</p>
<div class="sourceCode" id="cb29"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;</span> quickCheck (<span class="ot">monadLeftIdProp ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Fun</span> <span class="dt">Int</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">Bool</span>)</span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true" tabindex="-1"></a><span class="op">+++</span> <span class="dt">OK</span>, passed <span class="dv">100</span> tests<span class="op">.</span></span></code></pre></div>
<p>Finally, we write a test for the associative property.</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a><span class="ot">monadAssocProp ::</span> (<span class="dt">Monad</span> m, <span class="dt">Eq</span> (m c)) <span class="ot">=&gt;</span> m a <span class="ot">-&gt;</span> <span class="dt">Fun</span> a (m b) <span class="ot">-&gt;</span> <span class="dt">Fun</span> b (m c) <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true" tabindex="-1"></a>monadAssocProp x (apply <span class="ot">-&gt;</span> f) (apply <span class="ot">-&gt;</span> g) <span class="ot">=</span> ((x <span class="op">&gt;&gt;=</span> f) <span class="op">&gt;&gt;=</span> g) <span class="op">==</span> (x <span class="op">&gt;&gt;=</span> (\x&#39; <span class="ot">-&gt;</span> f x&#39; <span class="op">&gt;&gt;=</span> g))</span></code></pre></div>
<p>We can verify the associative law for the <code>Maybe</code> monad and functions <code>f :: Int -&gt; Maybe [Int]</code> and <code>g :: [Int] -&gt; Maybe String</code> as follows.</p>
<div class="sourceCode" id="cb31"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;</span> quickCheck (<span class="ot">monadAssocProp ::</span> <span class="dt">Maybe</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Fun</span> <span class="dt">Int</span> (<span class="dt">Maybe</span> [<span class="dt">Int</span>]) <span class="ot">-&gt;</span> <span class="dt">Fun</span> [<span class="dt">Int</span>] (<span class="dt">Maybe</span> <span class="dt">String</span>) <span class="ot">-&gt;</span> <span class="dt">Bool</span>)</span>
<span id="cb31-2"><a href="#cb31-2" aria-hidden="true" tabindex="-1"></a><span class="op">+++</span> <span class="dt">OK</span>, passed <span class="dv">100</span> tests<span class="op">.</span></span></code></pre></div>
<p>This post is written in <a href="http://www.haskell.org/haskellwiki/Literate_programming">literate Haskell</a> and the source available on <a href="https://github.com/AustinRochford/quickcheck-laws">GitHub</a>.</p>
