<meta name="title" content="My Most Interesting Interview Problem" />
<meta name="tags" content="Probability, Interviews" />
<meta name="date" content="2013-09-10" />
<meta name="has_math" content="true" /><p>I find most short interview problems quite contrived. This post is devoted to the one interview problem that I have found most interesting, due to the simplicity of its statement and the subtlety of its solution.</p>
<p>Consider the following function, intended to generate points uniformly distributed on the unit circle, <span class="math inline">\(x^2 + y^2 = 1\)</span>.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> scipy.stats <span class="im">import</span> uniform</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> generate(size<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Generate a point uniformly distributed in the square [-1, 1] x [-1, 1]</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>    x <span class="op">=</span> uniform.rvs(loc<span class="op">=-</span><span class="dv">1</span>, scale<span class="op">=</span><span class="dv">2</span>, size<span class="op">=</span>size)</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>    y <span class="op">=</span> uniform.rvs(loc<span class="op">=-</span><span class="dv">1</span>, scale<span class="op">=</span><span class="dv">2</span>, size<span class="op">=</span>size)</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Normalize by the distance from the origin to get a point on the unit circle</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>    r <span class="op">=</span> np.sqrt(x<span class="op">**</span><span class="dv">2</span> <span class="op">+</span> y<span class="op">**</span><span class="dv">2</span>)</span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> np.column_stack([x <span class="op">/</span> r, y <span class="op">/</span> r])</span></code></pre></div>
<p>The question asks whether or not this code does indeed generate points uniformly distributed on the unit circle.</p>
<p>At first glance it seems reasonable that it might do so. Upon slightly further reflection, we see that for the results to be uniformly distributed, we must map the square <span class="math inline">\([-1, 1] \times [-1, 1]\)</span> to the unit circle in a manner that preserves area (in the appropriate sense). From this point of view, we can quickly conclude that the results will not be uniformly (EDIT: this originally read “normally,” which was a typo) distributed.</p>
<p>To see why, consider the following diagram.</p>
<center>
<img src="/resources/most-interesting/diagonal.png" />
</center>
<p>All of the points in the square on the red line get scaled to the red point on the unit circle. Likewise, all of the points in the square on the blue line get scaled to the blue point on the unit circle. It is quite clear from this diagram that the blue line is longer than the red line. To be precise, the red line has length one, while the blue line has length <span class="math inline">\(\sqrt{2} \approx 1.414.\)</span></p>
<p>Due to this difference in length, the points generated by the function are more likely to be clustered around the four points <span class="math inline">\((\sqrt{2}, \sqrt{2})\)</span>, <span class="math inline">\((-\sqrt{2}, \sqrt{2})\)</span>, <span class="math inline">\((-\sqrt{2}, -\sqrt{2})\)</span>, and <span class="math inline">\((\sqrt{2}, -\sqrt{2})\)</span> than elsewhere on the circle.</p>
<p>The following diagram shows a heatmap of the locations of one million samples generated by this function.</p>
<center>
<img src="/resources/most-interesting/clustered.png" />
</center>
<p>We can see that the samples do indeed cluster around those four points, as shown by the red regions in the heatmap.</p>
<p>Although this problem is fairly simple, unlike many interview problems it reinforces a key breakdown in our intuition about probability theory and naive interpretations of transformations of random variables.</p>
<p>Discuss on <a href="https://news.ycombinator.com/item?id=6367378">Hacker News</a></p>
<p><strong><em>Update</em></strong></p>
<p>Many people have pointed out that this isn’t a great problem for general developer interview, and I agree. This interview was for a data-oriented position which required a strong understanding of probability theory.</p>
