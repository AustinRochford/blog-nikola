<meta name="title" content="MRPyMC3 - Multilevel Regression and Poststratification with PyMC3" />
<meta name="tags" content="PyMC3, Bayesian Statistics" />
<meta name="date" content="2017-07-09" />
<meta name="has_math" content="true" /><style>
.dataframe * {border-color: #c0c0c0 !important;}
.dataframe th{background: #eee;}
.dataframe td{
    background: #fff;
    text-align: right; 
    min-width:5em;
}

/* Format summary rows */
.dataframe-summary-row tr:last-child,
.dataframe-summary-col td:last-child{
background: #eee;
    font-weight: 500;
}
</style>
<p>A few weeks ago, <a href="https://today.yougov.com/">YouGov</a> correctly <a href="https://yougov.co.uk/uk-general-election-2017/#/uk-elections-charts-anchor">predicted</a> a hung parliament as a result of the 2017 UK general election, to the astonishment of many commentators. YouGov’s predictions were <a href="https://yougov.co.uk/news/2017/05/31/how-yougov-model-2017-general-election-works/">based</a> on a technique called multilevel regression with poststratification, or MRP for short (Andrew Gelman playfully refers to it as <a href="http://andrewgelman.com/2009/05/09/the_next_suprem/">Mister P</a>).</p>
<p>I was impressed with YouGov’s prediction and decided to work through an MRP example to improve my understanding of this technique. Since all of the applications of MRP I have found online involve <code>R</code>’s <a href="https://cran.r-project.org/web/packages/lme4/index.html"><code>lme4</code></a> package or <a href="http://mc-stan.org/">Stan</a>, I also thought this was a good opportunity to illustrate MRP in Python with PyMC3. This post is essentially a port of <a href="http://www.princeton.edu/~jkastell/">Jonathan Kastellec</a>’s excellent <a href="http://www.princeton.edu/~jkastell/mrp_primer.html">MRP primer</a> to Python and PyMC3. I am very grateful for his clear exposition of MRP and willingness to share a relevant data set.</p>
<p>MRP was developed to estimate American state-level opinions from national polls. This sort of estimation is crucial to understanding American politics at the national level, as many of the important political positions of the federal government are impacted by state-level elections:</p>
<ul>
<li>the president is chosen by the Electoral College, which (with a few exceptions) votes according to state-level vote totals,</li>
<li>senators are chosen by state-level elections,</li>
<li>many political and all judicial (notably Supreme Court) appointees require Senate approval, and therefore are subject to indirect state-level elections.</li>
</ul>
<p>Of course, as YouGov demonstrates, MRP is more widely applicable than estimation of state-level opinion.</p>
<p>In this post, we will follow Kastellec’s example of estimating state-level opinion about gay marriage in 2005/2006 using a combination of three national polls. We begin by loading a data set that consists of responses to the three national polls.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="op">%</span>matplotlib inline</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="op">%</span>config InlineBackend.figure_format <span class="op">=</span> <span class="st">&#39;retina&#39;</span></span></code></pre></div>
<div class="sourceCode" id="cb2"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> os</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> us</span></code></pre></div>
<div class="sourceCode" id="cb3"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib <span class="im">as</span> mpl</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> matplotlib <span class="im">import</span> pyplot <span class="im">as</span> plt</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> matplotlib.colors <span class="im">import</span> Normalize, rgb2hex</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> matplotlib.patches <span class="im">import</span> Polygon</span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> matplotlib.ticker <span class="im">import</span> FuncFormatter</span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> mpl_toolkits.basemap <span class="im">import</span> Basemap</span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pandas <span class="im">as</span> pd</span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pymc3 <span class="im">as</span> pm</span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> scipy <span class="im">as</span> sp</span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> seaborn <span class="im">as</span> sns</span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> theano <span class="im">import</span> shared</span></code></pre></div>
<div class="sourceCode" id="cb4"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="op">%%</span>bash</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> [ <span class="op">!</span> <span class="op">-</span>e .<span class="op">/</span>st99_d00.dbf ]<span class="op">;</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>then</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>    wget <span class="op">-</span>q https:<span class="op">//</span>github.com<span class="op">/</span>matplotlib<span class="op">/</span>basemap<span class="op">/</span>raw<span class="op">/</span>master<span class="op">/</span>examples<span class="op">/</span>st99_d00.dbf</span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>    wget <span class="op">-</span>q https:<span class="op">//</span>github.com<span class="op">/</span>matplotlib<span class="op">/</span>basemap<span class="op">/</span>raw<span class="op">/</span>master<span class="op">/</span>examples<span class="op">/</span>st99_d00.shp</span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>    wget <span class="op">-</span>q https:<span class="op">//</span>github.com<span class="op">/</span>matplotlib<span class="op">/</span>basemap<span class="op">/</span>raw<span class="op">/</span>master<span class="op">/</span>examples<span class="op">/</span>st99_d00.shx</span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>fi</span></code></pre></div>
<div class="sourceCode" id="cb5"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a>SEED <span class="op">=</span> <span class="dv">4260026</span> <span class="co"># from random.org, for reproducibility</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>np.random.seed(SEED)</span></code></pre></div>
<p>We load only the columns which we will use in the analysis and transform categorical variables to be zero-indexed.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> to_zero_indexed(col):</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="kw">lambda</span> df: (df[col] <span class="op">-</span> <span class="dv">1</span>).astype(np.int64)</span></code></pre></div>
<div class="sourceCode" id="cb7"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a>DATA_PREFIX <span class="op">=</span> <span class="st">&#39;http://www.princeton.edu/~jkastell/MRP_primer/&#39;</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>survey_df <span class="op">=</span> (pd.read_stata(os.path.join(DATA_PREFIX, <span class="st">&#39;gay_marriage_megapoll.dta&#39;</span>),</span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>                           columns<span class="op">=</span>[<span class="st">&#39;race_wbh&#39;</span>, <span class="st">&#39;age_cat&#39;</span>, <span class="st">&#39;edu_cat&#39;</span>, <span class="st">&#39;female&#39;</span>,</span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>                                    <span class="st">&#39;state_initnum&#39;</span>, <span class="st">&#39;state&#39;</span>, <span class="st">&#39;region_cat&#39;</span>, <span class="st">&#39;region&#39;</span>, <span class="st">&#39;statename&#39;</span>,</span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>                                    <span class="st">&#39;poll&#39;</span>, <span class="st">&#39;yes_of_all&#39;</span>])</span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>               .dropna(subset<span class="op">=</span>[<span class="st">&#39;race_wbh&#39;</span>, <span class="st">&#39;age_cat&#39;</span>, <span class="st">&#39;edu_cat&#39;</span>, <span class="st">&#39;state_initnum&#39;</span>])</span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a>               .assign(state_initnum<span class="op">=</span>to_zero_indexed(<span class="st">&#39;state_initnum&#39;</span>),</span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a>                       race_wbh<span class="op">=</span>to_zero_indexed(<span class="st">&#39;race_wbh&#39;</span>),</span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a>                       edu_cat<span class="op">=</span>to_zero_indexed(<span class="st">&#39;edu_cat&#39;</span>),</span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a>                       age_cat<span class="op">=</span>to_zero_indexed(<span class="st">&#39;age_cat&#39;</span>),</span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true" tabindex="-1"></a>                       region_cat<span class="op">=</span>to_zero_indexed(<span class="st">&#39;region_cat&#39;</span>)))</span></code></pre></div>
<div class="sourceCode" id="cb8"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a>survey_df.head()</span></code></pre></div>
<center>
<div>
<table border="1" class="dataframe">
<thead>
<tr style="text-align: right;">
<th>
</th>
<th>
race_wbh
</th>
<th>
age_cat
</th>
<th>
edu_cat
</th>
<th>
female
</th>
<th>
state_initnum
</th>
<th>
state
</th>
<th>
region_cat
</th>
<th>
region
</th>
<th>
statename
</th>
<th>
poll
</th>
<th>
yes_of_all
</th>
</tr>
</thead>
<tbody>
<tr>
<th>
0
</th>
<td>
0
</td>
<td>
2
</td>
<td>
2
</td>
<td>
1
</td>
<td>
22
</td>
<td>
MI
</td>
<td>
1
</td>
<td>
midwest
</td>
<td>
michigan
</td>
<td>
Gall2005Aug22
</td>
<td>
0
</td>
</tr>
<tr>
<th>
1
</th>
<td>
0
</td>
<td>
2
</td>
<td>
3
</td>
<td>
0
</td>
<td>
10
</td>
<td>
GA
</td>
<td>
2
</td>
<td>
south
</td>
<td>
georgia
</td>
<td>
Gall2005Aug22
</td>
<td>
0
</td>
</tr>
<tr>
<th>
2
</th>
<td>
2
</td>
<td>
0
</td>
<td>
3
</td>
<td>
0
</td>
<td>
34
</td>
<td>
NY
</td>
<td>
0
</td>
<td>
northeast
</td>
<td>
new york
</td>
<td>
Gall2005Aug22
</td>
<td>
1
</td>
</tr>
<tr>
<th>
3
</th>
<td>
0
</td>
<td>
3
</td>
<td>
3
</td>
<td>
1
</td>
<td>
30
</td>
<td>
NH
</td>
<td>
0
</td>
<td>
northeast
</td>
<td>
new hampshire
</td>
<td>
Gall2005Aug22
</td>
<td>
1
</td>
</tr>
<tr>
<th>
5
</th>
<td>
0
</td>
<td>
3
</td>
<td>
2
</td>
<td>
1
</td>
<td>
14
</td>
<td>
IL
</td>
<td>
1
</td>
<td>
midwest
</td>
<td>
illinois
</td>
<td>
Gall2005Aug22
</td>
<td>
0
</td>
</tr>
</tbody>
</table>
</div>
</center>
<p>These three surveys collected data from roughly 6,300 respondents during 2005 and 2006.</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a>survey_df.shape[<span class="dv">0</span>]</span></code></pre></div>
<pre><code>6341</code></pre>
<p>We see that the number of respondents varies widely between states.</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> state_plot(state_data, cmap, norm, cbar<span class="op">=</span><span class="va">True</span>, default<span class="op">=</span><span class="va">None</span>, ax<span class="op">=</span><span class="va">None</span>):</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> ax <span class="kw">is</span> <span class="va">None</span>:</span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>        fig, ax <span class="op">=</span> plt.subplots(figsize<span class="op">=</span>(<span class="dv">8</span>, <span class="dv">6</span>))</span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a>        fig <span class="op">=</span> plt.gcf()</span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a>    m <span class="op">=</span> Basemap(llcrnrlon<span class="op">=-</span><span class="dv">121</span>, llcrnrlat<span class="op">=</span><span class="dv">20</span>,</span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a>                urcrnrlon<span class="op">=-</span><span class="dv">62</span>, urcrnrlat<span class="op">=</span><span class="dv">51</span>,</span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true" tabindex="-1"></a>                projection<span class="op">=</span><span class="st">&#39;lcc&#39;</span>,</span>
<span id="cb11-10"><a href="#cb11-10" aria-hidden="true" tabindex="-1"></a>                lat_1<span class="op">=</span><span class="dv">32</span>, lat_2<span class="op">=</span><span class="dv">45</span>, lon_0<span class="op">=-</span><span class="dv">95</span>)</span>
<span id="cb11-11"><a href="#cb11-11" aria-hidden="true" tabindex="-1"></a>    m.readshapefile(<span class="st">&#39;st99_d00&#39;</span>, name<span class="op">=</span><span class="st">&#39;states&#39;</span>, drawbounds<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb11-12"><a href="#cb11-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-13"><a href="#cb11-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> state_info, state_seg <span class="kw">in</span> <span class="bu">zip</span>(m.states_info, m.states):</span>
<span id="cb11-14"><a href="#cb11-14" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> state_info[<span class="st">&#39;NAME&#39;</span>] <span class="op">==</span> <span class="st">&#39;Alaska&#39;</span>:</span>
<span id="cb11-15"><a href="#cb11-15" aria-hidden="true" tabindex="-1"></a>            state_seg <span class="op">=</span> <span class="bu">list</span>(<span class="bu">map</span>(<span class="kw">lambda</span> xy: (<span class="fl">0.35</span> <span class="op">*</span> xy[<span class="dv">0</span>] <span class="op">+</span> <span class="dv">1100000</span>, <span class="fl">0.35</span> <span class="op">*</span> xy[<span class="dv">1</span>] <span class="op">-</span> <span class="dv">1300000</span>), state_seg))</span>
<span id="cb11-16"><a href="#cb11-16" aria-hidden="true" tabindex="-1"></a>        <span class="cf">elif</span> state_info[<span class="st">&#39;NAME&#39;</span>] <span class="op">==</span> <span class="st">&#39;Hawaii&#39;</span> <span class="kw">and</span> <span class="bu">float</span>(state_info[<span class="st">&#39;AREA&#39;</span>]) <span class="op">&gt;</span> <span class="fl">0.005</span>:</span>
<span id="cb11-17"><a href="#cb11-17" aria-hidden="true" tabindex="-1"></a>            state_seg <span class="op">=</span> <span class="bu">list</span>(<span class="bu">map</span>(<span class="kw">lambda</span> xy: (xy[<span class="dv">0</span>] <span class="op">+</span> <span class="dv">5100000</span>, xy[<span class="dv">1</span>] <span class="op">-</span> <span class="dv">1400000</span>), state_seg))</span>
<span id="cb11-18"><a href="#cb11-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-19"><a href="#cb11-19" aria-hidden="true" tabindex="-1"></a>        <span class="cf">try</span>:</span>
<span id="cb11-20"><a href="#cb11-20" aria-hidden="true" tabindex="-1"></a>            state_datum <span class="op">=</span> state_data.loc[us.states.lookup(state_info[<span class="st">&#39;NAME&#39;</span>]).abbr]   </span>
<span id="cb11-21"><a href="#cb11-21" aria-hidden="true" tabindex="-1"></a>        <span class="cf">except</span> <span class="pp">KeyError</span>:</span>
<span id="cb11-22"><a href="#cb11-22" aria-hidden="true" tabindex="-1"></a>            state_datum <span class="op">=</span> default</span>
<span id="cb11-23"><a href="#cb11-23" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb11-24"><a href="#cb11-24" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> state_datum <span class="kw">is</span> <span class="kw">not</span> <span class="va">None</span>:</span>
<span id="cb11-25"><a href="#cb11-25" aria-hidden="true" tabindex="-1"></a>            color <span class="op">=</span> rgb2hex(cmap(norm(state_datum))) </span>
<span id="cb11-26"><a href="#cb11-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-27"><a href="#cb11-27" aria-hidden="true" tabindex="-1"></a>            poly <span class="op">=</span> Polygon(state_seg, facecolor<span class="op">=</span>color, edgecolor<span class="op">=</span><span class="st">&#39;#000000&#39;</span>)</span>
<span id="cb11-28"><a href="#cb11-28" aria-hidden="true" tabindex="-1"></a>            ax.add_patch(poly)</span>
<span id="cb11-29"><a href="#cb11-29" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb11-30"><a href="#cb11-30" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> cbar:</span>
<span id="cb11-31"><a href="#cb11-31" aria-hidden="true" tabindex="-1"></a>        cbar_ax <span class="op">=</span> fig.add_axes([<span class="fl">0.925</span>, <span class="fl">0.25</span>, <span class="fl">0.04</span>, <span class="fl">0.5</span>])</span>
<span id="cb11-32"><a href="#cb11-32" aria-hidden="true" tabindex="-1"></a>        mpl.colorbar.ColorbarBase(cbar_ax, cmap<span class="op">=</span>cmap, norm<span class="op">=</span>norm)</span>
<span id="cb11-33"><a href="#cb11-33" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb11-34"><a href="#cb11-34" aria-hidden="true" tabindex="-1"></a>        cbar_ax <span class="op">=</span> <span class="va">None</span></span>
<span id="cb11-35"><a href="#cb11-35" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb11-36"><a href="#cb11-36" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> fig, ax, cbar_ax</span></code></pre></div>
<div class="sourceCode" id="cb12"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a>state_counts <span class="op">=</span> survey_df.groupby(<span class="st">&#39;state&#39;</span>).size()</span></code></pre></div>
<div class="sourceCode" id="cb13"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a>fig, ax, cbar_ax <span class="op">=</span> state_plot(state_counts,</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>                              mpl.cm.binary,</span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>                              Normalize(<span class="dv">0</span>, state_counts.<span class="bu">max</span>()),</span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a>                              default<span class="op">=</span><span class="va">None</span>)</span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a>ax.set_title(<span class="st">&quot;Number of poll respondents&quot;</span>)<span class="op">;</span></span></code></pre></div>
<center>
<img src="/resources/mrpymc3/MRPyMC3-Multilevel%20Regression%20and%20Poststratification%20with%20PyMC3_16_0.png" title="fig:" alt="png" />
</center>
<p>Notably, there are no respondents from some less populous states, such as Alaska and Hawaii.</p>
<p>Faced with this data set, it is inuitively appealing to estimate state-level opinion by the observed proportion of that state’s respondents that supported gay marriage. This approach is known as disaggregation.</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a>disagg_p <span class="op">=</span> (survey_df.groupby(<span class="st">&#39;state&#39;</span>)</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>                     .yes_of_all</span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>                     .mean())</span></code></pre></div>
<div class="sourceCode" id="cb15"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a>p_norm <span class="op">=</span> Normalize(<span class="fl">0.</span>, <span class="fl">0.6</span>)</span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>p_cmap <span class="op">=</span> sns.diverging_palette(<span class="dv">220</span>, <span class="dv">10</span>, as_cmap<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a>fig, ax, cbar_ax <span class="op">=</span> state_plot(disagg_p, p_cmap, p_norm)</span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a>p_formatter <span class="op">=</span> FuncFormatter(<span class="kw">lambda</span> prop, _: <span class="st">&#39;</span><span class="sc">{:.1%}</span><span class="st">&#39;</span>.<span class="bu">format</span>(p_norm.inverse(prop)))</span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true" tabindex="-1"></a>cbar_ax.yaxis.set_major_formatter(p_formatter)<span class="op">;</span></span>
<span id="cb15-8"><a href="#cb15-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-9"><a href="#cb15-9" aria-hidden="true" tabindex="-1"></a>ax.set_title(<span class="st">&quot;Disaggregation estimate of</span><span class="ch">\n</span><span class="st">support for gay marriage in 2005&quot;</span>)<span class="op">;</span></span></code></pre></div>
<center>
<img src="/resources/mrpymc3/MRPyMC3-Multilevel%20Regression%20and%20Poststratification%20with%20PyMC3_19_0.png" title="fig:" alt="png" />
</center>
<p>The simplicity of disaggregation is appealing, but it suffers from a number of drawbacks. Obviously, it cannot estimate the state-level support for gay marriage in states with no respondents, such as Alaska and Hawaii. Similarly, for small/low population states with some respondents, the sample size may be too small to produce reliable estimates of opinion. This problem is exacerbated by the fact that for many issues, opinion is quite correlated with demographic factors such as age, race, education, gender, etc. Many more states will not have sufficient sample size for each combination of these factors for the disaggregate estimate to be representative of that state’s demographic compositon.</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a>ax <span class="op">=</span> (survey_df.groupby([<span class="st">&#39;state&#39;</span>, <span class="st">&#39;female&#39;</span>, <span class="st">&#39;race_wbh&#39;</span>])</span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a>               .size()</span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a>               .unstack(level<span class="op">=</span>[<span class="st">&#39;female&#39;</span>, <span class="st">&#39;race_wbh&#39;</span>])</span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a>               .isnull()</span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a>               .<span class="bu">sum</span>()</span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true" tabindex="-1"></a>               .unstack(level<span class="op">=</span><span class="st">&#39;female&#39;</span>)</span>
<span id="cb16-7"><a href="#cb16-7" aria-hidden="true" tabindex="-1"></a>               .rename(index<span class="op">=</span>{<span class="dv">0</span>: <span class="st">&#39;White&#39;</span>, <span class="dv">1</span>: <span class="st">&#39;Black&#39;</span>, <span class="dv">2</span>: <span class="st">&#39;Hispanic&#39;</span>},</span>
<span id="cb16-8"><a href="#cb16-8" aria-hidden="true" tabindex="-1"></a>                       columns<span class="op">=</span>{<span class="dv">0</span>: <span class="st">&#39;Male&#39;</span>, <span class="dv">1</span>: <span class="st">&#39;Female&#39;</span>})</span>
<span id="cb16-9"><a href="#cb16-9" aria-hidden="true" tabindex="-1"></a>               .rename_axis(<span class="st">&#39;Race&#39;</span>, axis<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb16-10"><a href="#cb16-10" aria-hidden="true" tabindex="-1"></a>               .rename_axis(<span class="st">&#39;Gender&#39;</span>, axis<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb16-11"><a href="#cb16-11" aria-hidden="true" tabindex="-1"></a>               .plot(kind<span class="op">=</span><span class="st">&#39;bar&#39;</span>, rot<span class="op">=</span><span class="dv">0</span>, figsize<span class="op">=</span>(<span class="dv">8</span>, <span class="dv">6</span>)))</span>
<span id="cb16-12"><a href="#cb16-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-13"><a href="#cb16-13" aria-hidden="true" tabindex="-1"></a>ax.set_yticks(np.arange(<span class="dv">0</span>, <span class="dv">21</span>, <span class="dv">5</span>))<span class="op">;</span></span>
<span id="cb16-14"><a href="#cb16-14" aria-hidden="true" tabindex="-1"></a>ax.set_ylabel(<span class="st">&quot;Number of states&quot;</span>)<span class="op">;</span></span>
<span id="cb16-15"><a href="#cb16-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-16"><a href="#cb16-16" aria-hidden="true" tabindex="-1"></a>ax.set_title(<span class="st">&quot;States with no respondents&quot;</span>)<span class="op">;</span></span></code></pre></div>
<center>
<img src="/resources/mrpymc3/MRPyMC3-Multilevel%20Regression%20and%20Poststratification%20with%20PyMC3_21_0.png" title="fig:" alt="png" />
</center>
<p>The plot above illustrates this phenomenon; a number of states have no nonwhite male or female respondents. Even more states will have very few such respondents. This lack of data renders the disaggregation estimates suspect. For further discussion and references on disaggregation (as well as an empirical comparison of disaggregation and MRP), consult Lax and Phillip’s <a href="http://www.columbia.edu/~jrl2124/Lax%20Phillips%20-%20Estimating%20State%20Public%20Opinion.pdf"><em>How Should We Estimate Public Opinion in the States?</em></a>.</p>
<p>MRP lessens the impact of this per-state respondent sparsity by first building a <a href="https://en.wikipedia.org/wiki/Multilevel_model">multilevel model</a> of the relationship between respondents’ states and demographic characteristics to opinion, and subsequently using the predictions of this multilevel model along with census data about the demographic composition of each state to predict state-level opinion. Intuitively, the multilevel model employed by MRP is a principled statistical method for estimating, for example, how much men in Pennsylvania share opinions with men in other states versus how much they share opinions with women in Pennsylvania. This partial pooling at both the state- and demographic-levels helps MRP impute the opinions of groups present in states that were not surveyed.</p>
<p>The rest of this post is focused primarily on the execution of MRP in Python with PyMC3. For more detail on the theory and accuracy of MRP, consult the following (very incomplete) list of MRP resources:</p>
<ul>
<li>the <a href="http://www.princeton.edu/~jkastell/MRP_primer/mrp_primer.pdf">MRP primer</a> from which our example is taken,</li>
<li>Park, Gelman, and Bafumi’s <a href="https://pdfs.semanticscholar.org/2008/bee9f8c2d7e41ac9c5c54489f41989a0d7ba.pdf"><em>Bayesian Multilevel Estimation with Poststratification: State-Level Estimates from National Polls</em></a>, which assesses the accuracy of MRP in predicting the state-level results of the 1998 and 1992 US presidential elections,</li>
<li>Section 14.1 of Gelman and Hill’s <a href="http://www.stat.columbia.edu/~gelman/arm/"><em>Data Analysis Using Regression and Multilevel/Hierarchical Models</em></a>, which gives an expanded discussion of the example from the previous paper,</li>
<li>Lax and Phillips’ <a href="http://www.columbia.edu/~jrl2124/Lax%20Phillips%20-%20Estimating%20State%20Public%20Opinion.pdf"><em>How Should We Estimate Public Opinion in The States?</em></a>, which is also mentioned above,</li>
<li>Gelman’s blog post <a href="http://andrewgelman.com/2013/10/09/mister-p-whats-its-secret-sauce/">Mister P: What’s its secret sauce?</a>, which is an extended discussion of several asssesments of MRP’s accuracy (<a href="https://academic.oup.com/pan/article-abstract/21/4/449/1544117/How-Does-Multilevel-Regression-and?redirectedFrom=fulltext">1</a>, <a href="http://www.columbia.edu/~jrl2124/mrp2.pdf">2</a>).</li>
</ul>
<p>Following the MRP primer, our multilevel opinion model will include factors for state, race, gender, education, age, and poll. In order to accelerate inference, we count the number of unique combinations of these factors, along with how many respondents with each combination supported gay marriage.</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a>uniq_survey_df <span class="op">=</span> (survey_df.groupby([<span class="st">&#39;race_wbh&#39;</span>, <span class="st">&#39;female&#39;</span>, <span class="st">&#39;edu_cat&#39;</span>, <span class="st">&#39;age_cat&#39;</span>,</span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>                                     <span class="st">&#39;region_cat&#39;</span>, <span class="st">&#39;state_initnum&#39;</span>, <span class="st">&#39;poll&#39;</span>])</span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a>                           .yes_of_all</span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a>                           .agg({</span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a>                               <span class="st">&#39;yes_of_all&#39;</span>: <span class="st">&#39;sum&#39;</span>,</span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true" tabindex="-1"></a>                               <span class="st">&#39;n&#39;</span>: <span class="st">&#39;size&#39;</span></span>
<span id="cb17-7"><a href="#cb17-7" aria-hidden="true" tabindex="-1"></a>                           })</span>
<span id="cb17-8"><a href="#cb17-8" aria-hidden="true" tabindex="-1"></a>                           .reset_index())</span></code></pre></div>
<div class="sourceCode" id="cb18"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a>uniq_survey_df.head()</span></code></pre></div>
<center>
<div>
<table border="1" class="dataframe">
<thead>
<tr style="text-align: right;">
<th>
</th>
<th>
race_wbh
</th>
<th>
female
</th>
<th>
edu_cat
</th>
<th>
age_cat
</th>
<th>
region_cat
</th>
<th>
state_initnum
</th>
<th>
poll
</th>
<th>
yes_of_all
</th>
<th>
n
</th>
</tr>
</thead>
<tbody>
<tr>
<th>
0
</th>
<td>
0
</td>
<td>
0
</td>
<td>
0
</td>
<td>
0
</td>
<td>
0
</td>
<td>
6
</td>
<td>
Pew 2004Dec01
</td>
<td>
0
</td>
<td>
1
</td>
</tr>
<tr>
<th>
1
</th>
<td>
0
</td>
<td>
0
</td>
<td>
0
</td>
<td>
0
</td>
<td>
0
</td>
<td>
30
</td>
<td>
Gall2005Aug22
</td>
<td>
0
</td>
<td>
1
</td>
</tr>
<tr>
<th>
2
</th>
<td>
0
</td>
<td>
0
</td>
<td>
0
</td>
<td>
0
</td>
<td>
0
</td>
<td>
34
</td>
<td>
ABC 2004Jan15
</td>
<td>
1
</td>
<td>
1
</td>
</tr>
<tr>
<th>
3
</th>
<td>
0
</td>
<td>
0
</td>
<td>
0
</td>
<td>
0
</td>
<td>
0
</td>
<td>
38
</td>
<td>
Pew 2004Dec01
</td>
<td>
1
</td>
<td>
1
</td>
</tr>
<tr>
<th>
4
</th>
<td>
0
</td>
<td>
0
</td>
<td>
0
</td>
<td>
0
</td>
<td>
1
</td>
<td>
12
</td>
<td>
ABC 2004Jan15
</td>
<td>
0
</td>
<td>
1
</td>
</tr>
</tbody>
</table>
</div>
</center>
<p>This reduction adds negligible mathematical complexity (several Bernoulli distributions are combined into a single binomial distribution), but reduces the number of rows in the data set by nearly half.</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a>uniq_survey_df.shape[<span class="dv">0</span>] <span class="op">/</span> survey_df.shape[<span class="dv">0</span>]</span></code></pre></div>
<pre><code>0.5824002523261316</code></pre>
<p>We will refer to each unique combination of state and demographic characteristics as a cell. Let <span class="math inline">\(n_i\)</span> denote the number of respondents in cell <span class="math inline">\(i\)</span>, <span class="math inline">\(y_i\)</span> the number of those respondents that supported gay marriage, and <span class="math inline">\(p_i\)</span> the probability that a member of the general population of cell <span class="math inline">\(i\)</span> supports gay marriage. We build a Bayesian multilevel logistic regression model of opinion as follows.</p>
<p><span class="math display">\[\begin{align*}
\eta_i
    &amp; = \beta_0 + \alpha^{\textrm{gender : race}}_{j(i)} + \alpha^{\textrm{age}}_{k(i)} + \alpha^{\textrm{edu}}_{l(i)} + \alpha^{\textrm{age : edu}}_{k(i),\ l(i)} + \alpha^{\textrm{state}}_{s(i)} + \alpha^{\textrm{poll}}_{m(i)} \\
\log \left(\frac{p_i}{1 - p_i}\right)
    &amp; = \eta_i \\
y_i
    &amp; \sim \textrm{Bernoulli}(n_i, p_i)
\end{align*}\]</span></p>
<p>Here each subscript indexed by <span class="math inline">\(i\)</span> is the categorical level of that characteristic for respondents in cell <span class="math inline">\(i\)</span>. The prior for the intercept is <span class="math inline">\(\beta_0 \sim N(0, 5^2)\)</span>. The prior for the effects of the interaction of gender and age is <span class="math inline">\(\alpha^{\textrm{gender : race}}_j \sim N\left(0, \sigma_{\textrm{gender : race}}^2\right),\)</span> with <span class="math inline">\(\sigma_{\textrm{gender : race}} \sim \textrm{HalfCauchy}(5)\)</span>. The priors on <span class="math inline">\(\alpha^{\textrm{age}}_k,\)</span> <span class="math inline">\(\alpha^{\textrm{edu}}_l,\)</span> <span class="math inline">\(\alpha^{\textrm{age : edu}}_{k,\ l},\)</span> and <span class="math inline">\(\alpha^{\textrm{poll}}_m\)</span> are defined similarly. The prior on the state term, <span class="math inline">\(\alpha^{\textrm{state}}_s\)</span>, includes state-level predictors for region of the country, religiosity, and support for John Kerry in the 2004 presidential election.</p>
<p><span class="math display">\[\begin{align*}
\alpha^{\textrm{state}}_s
    &amp; \sim N\left(\alpha^{\textrm{region}}_s + \beta^{\textrm{relig}} x^{\textrm{relig}}_s + \beta^{\textrm{kerry}} x^{\textrm{kerry}}_s, \sigma^2_{\textrm{state}}\right)
\end{align*}\]</span></p>
<p>Here <span class="math inline">\(x^{\textrm{relig}}_s\)</span> is the log odds of the proportion of the state’s residents that are evangelical Christian or Mormon, and <span class="math inline">\(x^{\textrm{kerry}}_s\)</span> is the log odds of the proportion of the state’s voters that voted for John Kerry in 2004. The priors on <span class="math inline">\(\alpha^{\textrm{region}}_s\)</span>, <span class="math inline">\(\beta^{\textrm{relig}}\)</span>, <span class="math inline">\(\beta^{\textrm{kerry}}\)</span> are the same as those on the analagous terms in the definition of <span class="math inline">\(\eta\)</span>.</p>
<p>First we encode the respondent information.</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> encode_gender_race(female, race_wbh):</span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> (<span class="dv">3</span> <span class="op">*</span> female <span class="op">+</span> race_wbh).values</span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> encode_age_edu(age, edu):</span>
<span id="cb21-5"><a href="#cb21-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> (<span class="dv">4</span> <span class="op">*</span> age <span class="op">+</span> edu).values</span></code></pre></div>
<div class="sourceCode" id="cb22"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a>gender_race <span class="op">=</span> encode_gender_race(uniq_survey_df.female, uniq_survey_df.race_wbh)</span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a>n_gender_race <span class="op">=</span> np.unique(gender_race).size</span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true" tabindex="-1"></a>age <span class="op">=</span> uniq_survey_df.age_cat.values</span>
<span id="cb22-5"><a href="#cb22-5" aria-hidden="true" tabindex="-1"></a>n_age <span class="op">=</span> np.unique(age).size</span>
<span id="cb22-6"><a href="#cb22-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-7"><a href="#cb22-7" aria-hidden="true" tabindex="-1"></a>edu <span class="op">=</span> uniq_survey_df.edu_cat.values</span>
<span id="cb22-8"><a href="#cb22-8" aria-hidden="true" tabindex="-1"></a>n_edu <span class="op">=</span> np.unique(edu).size</span>
<span id="cb22-9"><a href="#cb22-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-10"><a href="#cb22-10" aria-hidden="true" tabindex="-1"></a>age_edu <span class="op">=</span> encode_age_edu(uniq_survey_df.age_cat, uniq_survey_df.edu_cat)</span>
<span id="cb22-11"><a href="#cb22-11" aria-hidden="true" tabindex="-1"></a>n_age_edu <span class="op">=</span> np.unique(age_edu).size</span>
<span id="cb22-12"><a href="#cb22-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-13"><a href="#cb22-13" aria-hidden="true" tabindex="-1"></a>poll, poll_map <span class="op">=</span> uniq_survey_df.poll.factorize()</span>
<span id="cb22-14"><a href="#cb22-14" aria-hidden="true" tabindex="-1"></a>n_poll <span class="op">=</span> poll_map.size</span>
<span id="cb22-15"><a href="#cb22-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-16"><a href="#cb22-16" aria-hidden="true" tabindex="-1"></a>region <span class="op">=</span> uniq_survey_df.region_cat.values</span>
<span id="cb22-17"><a href="#cb22-17" aria-hidden="true" tabindex="-1"></a>n_region <span class="op">=</span> np.unique(region).size</span>
<span id="cb22-18"><a href="#cb22-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-19"><a href="#cb22-19" aria-hidden="true" tabindex="-1"></a>state <span class="op">=</span> uniq_survey_df.state_initnum.values</span>
<span id="cb22-20"><a href="#cb22-20" aria-hidden="true" tabindex="-1"></a>n_state <span class="op">=</span> <span class="dv">51</span></span>
<span id="cb22-21"><a href="#cb22-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-22"><a href="#cb22-22" aria-hidden="true" tabindex="-1"></a>n <span class="op">=</span> uniq_survey_df.n.values</span>
<span id="cb22-23"><a href="#cb22-23" aria-hidden="true" tabindex="-1"></a>yes_of_all <span class="op">=</span> uniq_survey_df.yes_of_all.values</span></code></pre></div>
<p>Next we load the state-level data and encode <span class="math inline">\(x^{\textrm{relig}}\)</span> and <span class="math inline">\(x^{\textrm{kerry}}\)</span>.</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a>STATE_URL <span class="op">=</span> <span class="st">&#39;http://www.princeton.edu/~jkastell/MRP_primer/state_level_update.dta&#39;</span></span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true" tabindex="-1"></a>state_df <span class="op">=</span> (pd.read_stata(STATE_URL,</span>
<span id="cb23-4"><a href="#cb23-4" aria-hidden="true" tabindex="-1"></a>                          columns<span class="op">=</span>[<span class="st">&#39;sstate_initnum&#39;</span>, <span class="st">&#39;sstate&#39;</span>,</span>
<span id="cb23-5"><a href="#cb23-5" aria-hidden="true" tabindex="-1"></a>                                   <span class="st">&#39;p_evang&#39;</span>, <span class="st">&#39;p_mormon&#39;</span>, <span class="st">&#39;kerry_04&#39;</span>])</span>
<span id="cb23-6"><a href="#cb23-6" aria-hidden="true" tabindex="-1"></a>              .rename(columns<span class="op">=</span>{<span class="st">&#39;sstate_initnum&#39;</span>: <span class="st">&#39;state_initnum&#39;</span>, <span class="st">&#39;sstate&#39;</span>: <span class="st">&#39;state&#39;</span>})</span>
<span id="cb23-7"><a href="#cb23-7" aria-hidden="true" tabindex="-1"></a>              .assign(state_initnum<span class="op">=</span>to_zero_indexed(<span class="st">&#39;state_initnum&#39;</span>),</span>
<span id="cb23-8"><a href="#cb23-8" aria-hidden="true" tabindex="-1"></a>                      p_relig<span class="op">=</span><span class="kw">lambda</span> df: df.p_evang <span class="op">+</span> df.p_mormon))</span></code></pre></div>
<div class="sourceCode" id="cb24"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a>state_df.head()</span></code></pre></div>
<center>
<div>
<table border="1" class="dataframe">
<thead>
<tr style="text-align: right;">
<th>
</th>
<th>
state_initnum
</th>
<th>
state
</th>
<th>
p_evang
</th>
<th>
p_mormon
</th>
<th>
kerry_04
</th>
<th>
p_relig
</th>
</tr>
</thead>
<tbody>
<tr>
<th>
0
</th>
<td>
0
</td>
<td>
AK
</td>
<td>
12.440000
</td>
<td>
3.003126
</td>
<td>
35.500000
</td>
<td>
15.443126
</td>
</tr>
<tr>
<th>
1
</th>
<td>
1
</td>
<td>
AL
</td>
<td>
40.549999
</td>
<td>
0.458273
</td>
<td>
36.799999
</td>
<td>
41.008274
</td>
</tr>
<tr>
<th>
2
</th>
<td>
2
</td>
<td>
AR
</td>
<td>
43.070000
</td>
<td>
0.560113
</td>
<td>
44.599998
</td>
<td>
43.630112
</td>
</tr>
<tr>
<th>
3
</th>
<td>
3
</td>
<td>
AZ
</td>
<td>
9.410000
</td>
<td>
4.878735
</td>
<td>
44.400002
</td>
<td>
14.288734
</td>
</tr>
<tr>
<th>
4
</th>
<td>
4
</td>
<td>
CA
</td>
<td>
7.160000
</td>
<td>
1.557627
</td>
<td>
54.299999
</td>
<td>
8.717627
</td>
</tr>
</tbody>
</table>
</div>
</center>
<div class="sourceCode" id="cb25"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a>state_kerry <span class="op">=</span> sp.special.logit(state_df.kerry_04.values <span class="op">/</span> <span class="fl">100.</span>)</span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a>state_relig <span class="op">=</span> sp.special.logit(state_df.p_relig.values <span class="op">/</span> <span class="fl">100.</span>)</span></code></pre></div>
<p>The state-level data doesn’t contain region information, so we load census data in order to build a mapping between state and region.</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a>CENSUS_URL <span class="op">=</span> <span class="st">&#39;http://www.princeton.edu/~jkastell/MRP_primer/poststratification%202000.dta&#39;</span></span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true" tabindex="-1"></a>census_df <span class="op">=</span> (pd.read_stata(CENSUS_URL)</span>
<span id="cb26-4"><a href="#cb26-4" aria-hidden="true" tabindex="-1"></a>               .rename(columns<span class="op">=</span><span class="kw">lambda</span> s: s.lstrip(<span class="st">&#39;c_&#39;</span>).lower())</span>
<span id="cb26-5"><a href="#cb26-5" aria-hidden="true" tabindex="-1"></a>               .assign(race_wbh<span class="op">=</span>to_zero_indexed(<span class="st">&#39;race_wbh&#39;</span>),</span>
<span id="cb26-6"><a href="#cb26-6" aria-hidden="true" tabindex="-1"></a>                       edu_cat<span class="op">=</span>to_zero_indexed(<span class="st">&#39;edu_cat&#39;</span>),</span>
<span id="cb26-7"><a href="#cb26-7" aria-hidden="true" tabindex="-1"></a>                       age_cat<span class="op">=</span>to_zero_indexed(<span class="st">&#39;age_cat&#39;</span>)))</span></code></pre></div>
<div class="sourceCode" id="cb27"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a>census_df.head()</span></code></pre></div>
<center>
<div>
<table border="1" class="dataframe">
<thead>
<tr style="text-align: right;">
<th>
</th>
<th>
race_wbh
</th>
<th>
age_cat
</th>
<th>
edu_cat
</th>
<th>
female
</th>
<th>
state
</th>
<th>
freq
</th>
<th>
freq_state
</th>
<th>
percent_state
</th>
<th>
region
</th>
</tr>
</thead>
<tbody>
<tr>
<th>
0
</th>
<td>
0
</td>
<td>
0
</td>
<td>
0
</td>
<td>
0
</td>
<td>
AK
</td>
<td>
467
</td>
<td>
21222.0
</td>
<td>
0.022005
</td>
<td>
west
</td>
</tr>
<tr>
<th>
1
</th>
<td>
0
</td>
<td>
1
</td>
<td>
0
</td>
<td>
0
</td>
<td>
AK
</td>
<td>
377
</td>
<td>
21222.0
</td>
<td>
0.017765
</td>
<td>
west
</td>
</tr>
<tr>
<th>
2
</th>
<td>
0
</td>
<td>
2
</td>
<td>
0
</td>
<td>
0
</td>
<td>
AK
</td>
<td>
419
</td>
<td>
21222.0
</td>
<td>
0.019744
</td>
<td>
west
</td>
</tr>
<tr>
<th>
3
</th>
<td>
0
</td>
<td>
3
</td>
<td>
0
</td>
<td>
0
</td>
<td>
AK
</td>
<td>
343
</td>
<td>
21222.0
</td>
<td>
0.016162
</td>
<td>
west
</td>
</tr>
<tr>
<th>
4
</th>
<td>
0
</td>
<td>
0
</td>
<td>
1
</td>
<td>
0
</td>
<td>
AK
</td>
<td>
958
</td>
<td>
21222.0
</td>
<td>
0.045142
</td>
<td>
west
</td>
</tr>
</tbody>
</table>
</div>
</center>
<div class="sourceCode" id="cb28"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a>state_df <span class="op">=</span> (pd.merge(</span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true" tabindex="-1"></a>                pd.merge((survey_df.groupby(<span class="st">&#39;region&#39;</span>)</span>
<span id="cb28-3"><a href="#cb28-3" aria-hidden="true" tabindex="-1"></a>                                   .region_cat</span>
<span id="cb28-4"><a href="#cb28-4" aria-hidden="true" tabindex="-1"></a>                                   .first()</span>
<span id="cb28-5"><a href="#cb28-5" aria-hidden="true" tabindex="-1"></a>                                   .reset_index()),</span>
<span id="cb28-6"><a href="#cb28-6" aria-hidden="true" tabindex="-1"></a>                          (census_df[[<span class="st">&#39;state&#39;</span>, <span class="st">&#39;region&#39;</span>]].drop_duplicates()),</span>
<span id="cb28-7"><a href="#cb28-7" aria-hidden="true" tabindex="-1"></a>                          on<span class="op">=</span><span class="st">&#39;region&#39;</span>)[[<span class="st">&#39;state&#39;</span>, <span class="st">&#39;region_cat&#39;</span>]],</span>
<span id="cb28-8"><a href="#cb28-8" aria-hidden="true" tabindex="-1"></a>                 state_df, on<span class="op">=</span><span class="st">&#39;state&#39;</span>)</span>
<span id="cb28-9"><a href="#cb28-9" aria-hidden="true" tabindex="-1"></a>               .set_index(<span class="st">&#39;state_initnum&#39;</span>)</span>
<span id="cb28-10"><a href="#cb28-10" aria-hidden="true" tabindex="-1"></a>               .sort_index())</span></code></pre></div>
<div class="sourceCode" id="cb29"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a>state_df.head()</span></code></pre></div>
<center>
<div>
<table border="1" class="dataframe">
<thead>
<tr style="text-align: right;">
<th>
</th>
<th>
state
</th>
<th>
region_cat
</th>
<th>
p_evang
</th>
<th>
p_mormon
</th>
<th>
kerry_04
</th>
<th>
p_relig
</th>
</tr>
<tr>
<th>
state_initnum
</th>
<th>
</th>
<th>
</th>
<th>
</th>
<th>
</th>
<th>
</th>
<th>
</th>
</tr>
</thead>
<tbody>
<tr>
<th>
0
</th>
<td>
AK
</td>
<td>
3
</td>
<td>
12.440000
</td>
<td>
3.003126
</td>
<td>
35.500000
</td>
<td>
15.443126
</td>
</tr>
<tr>
<th>
1
</th>
<td>
AL
</td>
<td>
2
</td>
<td>
40.549999
</td>
<td>
0.458273
</td>
<td>
36.799999
</td>
<td>
41.008274
</td>
</tr>
<tr>
<th>
2
</th>
<td>
AR
</td>
<td>
2
</td>
<td>
43.070000
</td>
<td>
0.560113
</td>
<td>
44.599998
</td>
<td>
43.630112
</td>
</tr>
<tr>
<th>
3
</th>
<td>
AZ
</td>
<td>
3
</td>
<td>
9.410000
</td>
<td>
4.878735
</td>
<td>
44.400002
</td>
<td>
14.288734
</td>
</tr>
<tr>
<th>
4
</th>
<td>
CA
</td>
<td>
3
</td>
<td>
7.160000
</td>
<td>
1.557627
</td>
<td>
54.299999
</td>
<td>
8.717627
</td>
</tr>
</tbody>
</table>
</div>
</center>
<div class="sourceCode" id="cb30"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a>state_region <span class="op">=</span> state_df.region_cat.values</span></code></pre></div>
<p>Finally, we are ready to specify the model with PyMC3. First, we wrap the predictors in <code>theano.shared</code> so that we can eventually replace the survey respondent’s predictors with census predictors for posterior prediction (the poststratification step of MRP).</p>
<div class="sourceCode" id="cb31"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a>gender_race_ <span class="op">=</span> shared(gender_race)</span>
<span id="cb31-2"><a href="#cb31-2" aria-hidden="true" tabindex="-1"></a>age_ <span class="op">=</span> shared(age)</span>
<span id="cb31-3"><a href="#cb31-3" aria-hidden="true" tabindex="-1"></a>edu_ <span class="op">=</span> shared(edu)</span>
<span id="cb31-4"><a href="#cb31-4" aria-hidden="true" tabindex="-1"></a>age_edu_ <span class="op">=</span> shared(age_edu)</span>
<span id="cb31-5"><a href="#cb31-5" aria-hidden="true" tabindex="-1"></a>poll_ <span class="op">=</span> shared(poll)</span>
<span id="cb31-6"><a href="#cb31-6" aria-hidden="true" tabindex="-1"></a>state_ <span class="op">=</span> shared(state)</span>
<span id="cb31-7"><a href="#cb31-7" aria-hidden="true" tabindex="-1"></a>use_poll_ <span class="op">=</span> shared(<span class="dv">1</span>)</span>
<span id="cb31-8"><a href="#cb31-8" aria-hidden="true" tabindex="-1"></a>n_ <span class="op">=</span> shared(n)</span></code></pre></div>
<p>We specify the model for <span class="math inline">\(\alpha^{\textrm{state}}\)</span>.</p>
<div class="sourceCode" id="cb32"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> hierarchical_normal(name, shape, μ<span class="op">=</span><span class="fl">0.</span>):</span>
<span id="cb32-2"><a href="#cb32-2" aria-hidden="true" tabindex="-1"></a>    Δ <span class="op">=</span> pm.Normal(<span class="st">&#39;Δ_</span><span class="sc">{}</span><span class="st">&#39;</span>.<span class="bu">format</span>(name), <span class="fl">0.</span>, <span class="fl">1.</span>, shape<span class="op">=</span>shape)</span>
<span id="cb32-3"><a href="#cb32-3" aria-hidden="true" tabindex="-1"></a>    σ <span class="op">=</span> pm.HalfCauchy(<span class="st">&#39;σ_</span><span class="sc">{}</span><span class="st">&#39;</span>.<span class="bu">format</span>(name), <span class="fl">5.</span>)</span>
<span id="cb32-4"><a href="#cb32-4" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb32-5"><a href="#cb32-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> pm.Deterministic(name, μ <span class="op">+</span> Δ <span class="op">*</span> σ)</span></code></pre></div>
<div class="sourceCode" id="cb33"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a><span class="cf">with</span> pm.Model() <span class="im">as</span> model:</span>
<span id="cb33-2"><a href="#cb33-2" aria-hidden="true" tabindex="-1"></a>    α_region <span class="op">=</span> hierarchical_normal(<span class="st">&#39;region&#39;</span>, n_region)</span>
<span id="cb33-3"><a href="#cb33-3" aria-hidden="true" tabindex="-1"></a>    β_relig <span class="op">=</span> pm.Normal(<span class="st">&#39;relig&#39;</span>, <span class="fl">0.</span>, <span class="fl">5.</span>)</span>
<span id="cb33-4"><a href="#cb33-4" aria-hidden="true" tabindex="-1"></a>    β_kerry <span class="op">=</span> pm.Normal(<span class="st">&#39;kerry&#39;</span>, <span class="fl">0.</span>, <span class="fl">5.</span>)</span>
<span id="cb33-5"><a href="#cb33-5" aria-hidden="true" tabindex="-1"></a>    μ_state <span class="op">=</span> α_region[state_region] <span class="op">+</span> β_relig <span class="op">*</span> state_relig <span class="op">+</span> β_kerry <span class="op">*</span> state_kerry</span>
<span id="cb33-6"><a href="#cb33-6" aria-hidden="true" tabindex="-1"></a>    α_state <span class="op">=</span> hierarchical_normal(<span class="st">&#39;state&#39;</span>, n_state, μ<span class="op">=</span>μ_state)</span></code></pre></div>
<p>Throughout, we use a <a href="http://twiecki.github.io/blog/2017/02/08/bayesian-hierchical-non-centered/">non-centered parametrization</a> for our hierarchical normal priors for more efficient sampling. We now specify the rest of <span class="math inline">\(\eta_i\)</span>.</p>
<div class="sourceCode" id="cb34"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a><span class="cf">with</span> model:</span>
<span id="cb34-2"><a href="#cb34-2" aria-hidden="true" tabindex="-1"></a>    β<span class="dv">0</span> <span class="op">=</span> pm.Normal(<span class="st">&#39;β0&#39;</span>, <span class="fl">0.</span>, <span class="fl">5.</span>,</span>
<span id="cb34-3"><a href="#cb34-3" aria-hidden="true" tabindex="-1"></a>                   testval<span class="op">=</span>sp.special.logit(survey_df.yes_of_all.mean()))</span>
<span id="cb34-4"><a href="#cb34-4" aria-hidden="true" tabindex="-1"></a>    α_gender_race <span class="op">=</span> hierarchical_normal(<span class="st">&#39;gender_race&#39;</span>, n_gender_race)</span>
<span id="cb34-5"><a href="#cb34-5" aria-hidden="true" tabindex="-1"></a>    α_age <span class="op">=</span> hierarchical_normal(<span class="st">&#39;age&#39;</span>, n_age)</span>
<span id="cb34-6"><a href="#cb34-6" aria-hidden="true" tabindex="-1"></a>    α_edu <span class="op">=</span> hierarchical_normal(<span class="st">&#39;edu&#39;</span>, n_edu)</span>
<span id="cb34-7"><a href="#cb34-7" aria-hidden="true" tabindex="-1"></a>    α_age_edu <span class="op">=</span> hierarchical_normal(<span class="st">&#39;age_edu&#39;</span>, n_age_edu)</span>
<span id="cb34-8"><a href="#cb34-8" aria-hidden="true" tabindex="-1"></a>    α_poll <span class="op">=</span> hierarchical_normal(<span class="st">&#39;poll&#39;</span>, n_poll)</span>
<span id="cb34-9"><a href="#cb34-9" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb34-10"><a href="#cb34-10" aria-hidden="true" tabindex="-1"></a>    η <span class="op">=</span> β<span class="dv">0</span> <span class="op">\</span></span>
<span id="cb34-11"><a href="#cb34-11" aria-hidden="true" tabindex="-1"></a>        <span class="op">+</span> α_gender_race[gender_race_] <span class="op">\</span></span>
<span id="cb34-12"><a href="#cb34-12" aria-hidden="true" tabindex="-1"></a>        <span class="op">+</span> α_age[age_] <span class="op">\</span></span>
<span id="cb34-13"><a href="#cb34-13" aria-hidden="true" tabindex="-1"></a>        <span class="op">+</span> α_edu[edu_] <span class="op">\</span></span>
<span id="cb34-14"><a href="#cb34-14" aria-hidden="true" tabindex="-1"></a>        <span class="op">+</span> α_age_edu[age_edu_] <span class="op">\</span></span>
<span id="cb34-15"><a href="#cb34-15" aria-hidden="true" tabindex="-1"></a>        <span class="op">+</span> α_state[state_] <span class="op">\</span></span>
<span id="cb34-16"><a href="#cb34-16" aria-hidden="true" tabindex="-1"></a>        <span class="op">+</span> use_poll_ <span class="op">*</span> α_poll[poll_]</span></code></pre></div>
<p>Here the <code>theano.shared</code> variable <code>use_poll_</code> will allow us to ignore poll effects when we do posterior predictive sampling with census data.</p>
<p>Finally, we specify the likelihood and sample from the model using NUTS.</p>
<div class="sourceCode" id="cb35"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true" tabindex="-1"></a><span class="cf">with</span> model:</span>
<span id="cb35-2"><a href="#cb35-2" aria-hidden="true" tabindex="-1"></a>    p <span class="op">=</span> pm.math.sigmoid(η)</span>
<span id="cb35-3"><a href="#cb35-3" aria-hidden="true" tabindex="-1"></a>    obs <span class="op">=</span> pm.Binomial(<span class="st">&#39;obs&#39;</span>, n_, p, observed<span class="op">=</span>yes_of_all)</span></code></pre></div>
<div class="sourceCode" id="cb36"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true" tabindex="-1"></a>NUTS_KWARGS <span class="op">=</span> {</span>
<span id="cb36-2"><a href="#cb36-2" aria-hidden="true" tabindex="-1"></a>    <span class="st">&#39;target_accept&#39;</span>: <span class="fl">0.99</span></span>
<span id="cb36-3"><a href="#cb36-3" aria-hidden="true" tabindex="-1"></a>}      </span>
<span id="cb36-4"><a href="#cb36-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-5"><a href="#cb36-5" aria-hidden="true" tabindex="-1"></a><span class="cf">with</span> model:</span>
<span id="cb36-6"><a href="#cb36-6" aria-hidden="true" tabindex="-1"></a>    trace <span class="op">=</span> pm.sample(draws<span class="op">=</span><span class="dv">1000</span>, random_seed<span class="op">=</span>SEED,</span>
<span id="cb36-7"><a href="#cb36-7" aria-hidden="true" tabindex="-1"></a>                      nuts_kwargs<span class="op">=</span>NUTS_KWARGS, njobs<span class="op">=</span><span class="dv">3</span>)</span></code></pre></div>
<pre><code>Auto-assigning NUTS sampler...
Initializing NUTS using ADVI...
Average Loss = 2,800.1:  19%|█▉        | 37833/200000 [00:44&lt;02:44, 982.94it/s] 
Convergence archived at 37900
Interrupted at 37,900 [18%]: Average Loss = 3,804.3
100%|██████████| 1500/1500 [09:02&lt;00:00,  3.82it/s]</code></pre>
<p>The marginal energy and energy transition distributions are fairly close, showing no obvious problem with NUTS.</p>
<div class="sourceCode" id="cb38"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb38-1"><a href="#cb38-1" aria-hidden="true" tabindex="-1"></a>pm.energyplot(trace)<span class="op">;</span></span></code></pre></div>
<center>
<img src="/resources/mrpymc3/MRPyMC3-Multilevel%20Regression%20and%20Poststratification%20with%20PyMC3_51_0.png" title="fig:" alt="png" />
</center>
<p>The Gelman-Rubin statistics for all parameters are quite close to one, indicating convergence.</p>
<div class="sourceCode" id="cb39"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb39-1"><a href="#cb39-1" aria-hidden="true" tabindex="-1"></a><span class="bu">max</span>(np.<span class="bu">max</span>(score) <span class="cf">for</span> score <span class="kw">in</span> pm.gelman_rubin(trace).values())</span></code></pre></div>
<pre><code>1.0088100577623547</code></pre>
<p>We are now ready for the post-stratification step of MRP. First we combine the census and state-level data.</p>
<div class="sourceCode" id="cb41"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb41-1"><a href="#cb41-1" aria-hidden="true" tabindex="-1"></a>ps_df <span class="op">=</span> pd.merge(census_df,</span>
<span id="cb41-2"><a href="#cb41-2" aria-hidden="true" tabindex="-1"></a>                 state_df[[<span class="st">&#39;state&#39;</span>, <span class="st">&#39;region_cat&#39;</span>]].reset_index(),</span>
<span id="cb41-3"><a href="#cb41-3" aria-hidden="true" tabindex="-1"></a>                 on<span class="op">=</span><span class="st">&#39;state&#39;</span>)</span></code></pre></div>
<div class="sourceCode" id="cb42"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb42-1"><a href="#cb42-1" aria-hidden="true" tabindex="-1"></a>ps_df.head()</span></code></pre></div>
<center>
<div>
<table border="1" class="dataframe">
<thead>
<tr style="text-align: right;">
<th>
</th>
<th>
race_wbh
</th>
<th>
age_cat
</th>
<th>
edu_cat
</th>
<th>
female
</th>
<th>
state
</th>
<th>
freq
</th>
<th>
freq_state
</th>
<th>
percent_state
</th>
<th>
region
</th>
<th>
state_initnum
</th>
<th>
region_cat
</th>
</tr>
</thead>
<tbody>
<tr>
<th>
0
</th>
<td>
0
</td>
<td>
0
</td>
<td>
0
</td>
<td>
0
</td>
<td>
AK
</td>
<td>
467
</td>
<td>
21222.0
</td>
<td>
0.022005
</td>
<td>
west
</td>
<td>
0
</td>
<td>
3
</td>
</tr>
<tr>
<th>
1
</th>
<td>
0
</td>
<td>
1
</td>
<td>
0
</td>
<td>
0
</td>
<td>
AK
</td>
<td>
377
</td>
<td>
21222.0
</td>
<td>
0.017765
</td>
<td>
west
</td>
<td>
0
</td>
<td>
3
</td>
</tr>
<tr>
<th>
2
</th>
<td>
0
</td>
<td>
2
</td>
<td>
0
</td>
<td>
0
</td>
<td>
AK
</td>
<td>
419
</td>
<td>
21222.0
</td>
<td>
0.019744
</td>
<td>
west
</td>
<td>
0
</td>
<td>
3
</td>
</tr>
<tr>
<th>
3
</th>
<td>
0
</td>
<td>
3
</td>
<td>
0
</td>
<td>
0
</td>
<td>
AK
</td>
<td>
343
</td>
<td>
21222.0
</td>
<td>
0.016162
</td>
<td>
west
</td>
<td>
0
</td>
<td>
3
</td>
</tr>
<tr>
<th>
4
</th>
<td>
0
</td>
<td>
0
</td>
<td>
1
</td>
<td>
0
</td>
<td>
AK
</td>
<td>
958
</td>
<td>
21222.0
</td>
<td>
0.045142
</td>
<td>
west
</td>
<td>
0
</td>
<td>
3
</td>
</tr>
</tbody>
</table>
</div>
</center>
<p>Next we encode this combined data as before.</p>
<div class="sourceCode" id="cb43"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb43-1"><a href="#cb43-1" aria-hidden="true" tabindex="-1"></a>ps_gender_race <span class="op">=</span> encode_gender_race(ps_df.female, ps_df.race_wbh)</span>
<span id="cb43-2"><a href="#cb43-2" aria-hidden="true" tabindex="-1"></a>ps_age <span class="op">=</span> ps_df.age_cat.values</span>
<span id="cb43-3"><a href="#cb43-3" aria-hidden="true" tabindex="-1"></a>ps_edu <span class="op">=</span> ps_df.edu_cat.values</span>
<span id="cb43-4"><a href="#cb43-4" aria-hidden="true" tabindex="-1"></a>ps_age_edu <span class="op">=</span> encode_age_edu(ps_df.age_cat, ps_df.edu_cat)</span>
<span id="cb43-5"><a href="#cb43-5" aria-hidden="true" tabindex="-1"></a>ps_region <span class="op">=</span> ps_df.region_cat.values</span>
<span id="cb43-6"><a href="#cb43-6" aria-hidden="true" tabindex="-1"></a>ps_state <span class="op">=</span> ps_df.state_initnum.values</span>
<span id="cb43-7"><a href="#cb43-7" aria-hidden="true" tabindex="-1"></a>ps_n <span class="op">=</span> ps_df.freq.values.astype(np.int64)</span></code></pre></div>
<p>We now set the values of the <code>theano.shared</code> variables in our PyMC3 model to the poststratification data and sample from the posterior predictive distribution.</p>
<div class="sourceCode" id="cb44"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb44-1"><a href="#cb44-1" aria-hidden="true" tabindex="-1"></a>gender_race_.set_value(ps_gender_race)</span>
<span id="cb44-2"><a href="#cb44-2" aria-hidden="true" tabindex="-1"></a>age_.set_value(ps_age)</span>
<span id="cb44-3"><a href="#cb44-3" aria-hidden="true" tabindex="-1"></a>edu_.set_value(ps_edu)</span>
<span id="cb44-4"><a href="#cb44-4" aria-hidden="true" tabindex="-1"></a>age_edu_.set_value(ps_age_edu)</span>
<span id="cb44-5"><a href="#cb44-5" aria-hidden="true" tabindex="-1"></a>poll_.set_value(np.zeros_like(ps_gender_race))</span>
<span id="cb44-6"><a href="#cb44-6" aria-hidden="true" tabindex="-1"></a>state_.set_value(ps_state)</span>
<span id="cb44-7"><a href="#cb44-7" aria-hidden="true" tabindex="-1"></a>use_poll_.set_value(<span class="dv">0</span>)</span>
<span id="cb44-8"><a href="#cb44-8" aria-hidden="true" tabindex="-1"></a>n_.set_value(ps_n)</span></code></pre></div>
<div class="sourceCode" id="cb45"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb45-1"><a href="#cb45-1" aria-hidden="true" tabindex="-1"></a><span class="cf">with</span> model:</span>
<span id="cb45-2"><a href="#cb45-2" aria-hidden="true" tabindex="-1"></a>    pp_trace <span class="op">=</span> pm.sample_ppc(trace, random_seed<span class="op">=</span>SEED)</span></code></pre></div>
<pre><code>100%|██████████| 1000/1000 [00:01&lt;00:00, 583.42it/s]</code></pre>
<div class="sourceCode" id="cb47"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb47-1"><a href="#cb47-1" aria-hidden="true" tabindex="-1"></a>PP_COLS <span class="op">=</span> [<span class="st">&#39;pp_yes_of_all_</span><span class="sc">{}</span><span class="st">&#39;</span>.<span class="bu">format</span>(i) <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(pp_trace[<span class="st">&#39;obs&#39;</span>].shape[<span class="dv">0</span>])]</span>
<span id="cb47-2"><a href="#cb47-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb47-3"><a href="#cb47-3" aria-hidden="true" tabindex="-1"></a>pp_df <span class="op">=</span> pd.merge(ps_df,</span>
<span id="cb47-4"><a href="#cb47-4" aria-hidden="true" tabindex="-1"></a>                 pd.DataFrame(pp_trace[<span class="st">&#39;obs&#39;</span>].T, columns<span class="op">=</span>PP_COLS),</span>
<span id="cb47-5"><a href="#cb47-5" aria-hidden="true" tabindex="-1"></a>                 left_index<span class="op">=</span><span class="va">True</span>, right_index<span class="op">=</span><span class="va">True</span>)</span></code></pre></div>
<div class="sourceCode" id="cb48"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb48-1"><a href="#cb48-1" aria-hidden="true" tabindex="-1"></a>pp_df.head()</span></code></pre></div>
<center>
<div>
<table border="1" class="dataframe">
<thead>
<tr style="text-align: right;">
<th>
</th>
<th>
race_wbh
</th>
<th>
age_cat
</th>
<th>
edu_cat
</th>
<th>
female
</th>
<th>
state
</th>
<th>
freq
</th>
<th>
freq_state
</th>
<th>
percent_state
</th>
<th>
region
</th>
<th>
state_initnum
</th>
<th>
…
</th>
<th>
pp_yes_of_all_990
</th>
<th>
pp_yes_of_all_991
</th>
<th>
pp_yes_of_all_992
</th>
<th>
pp_yes_of_all_993
</th>
<th>
pp_yes_of_all_994
</th>
<th>
pp_yes_of_all_995
</th>
<th>
pp_yes_of_all_996
</th>
<th>
pp_yes_of_all_997
</th>
<th>
pp_yes_of_all_998
</th>
<th>
pp_yes_of_all_999
</th>
</tr>
</thead>
<tbody>
<tr>
<th>
0
</th>
<td>
0
</td>
<td>
0
</td>
<td>
0
</td>
<td>
0
</td>
<td>
AK
</td>
<td>
467
</td>
<td>
21222.0
</td>
<td>
0.022005
</td>
<td>
west
</td>
<td>
0
</td>
<td>
…
</td>
<td>
205
</td>
<td>
151
</td>
<td>
144
</td>
<td>
185
</td>
<td>
137
</td>
<td>
122
</td>
<td>
145
</td>
<td>
139
</td>
<td>
171
</td>
<td>
186
</td>
</tr>
<tr>
<th>
1
</th>
<td>
0
</td>
<td>
1
</td>
<td>
0
</td>
<td>
0
</td>
<td>
AK
</td>
<td>
377
</td>
<td>
21222.0
</td>
<td>
0.017765
</td>
<td>
west
</td>
<td>
0
</td>
<td>
…
</td>
<td>
86
</td>
<td>
71
</td>
<td>
83
</td>
<td>
95
</td>
<td>
84
</td>
<td>
96
</td>
<td>
66
</td>
<td>
79
</td>
<td>
64
</td>
<td>
121
</td>
</tr>
<tr>
<th>
2
</th>
<td>
0
</td>
<td>
2
</td>
<td>
0
</td>
<td>
0
</td>
<td>
AK
</td>
<td>
419
</td>
<td>
21222.0
</td>
<td>
0.019744
</td>
<td>
west
</td>
<td>
0
</td>
<td>
…
</td>
<td>
94
</td>
<td>
77
</td>
<td>
45
</td>
<td>
86
</td>
<td>
80
</td>
<td>
61
</td>
<td>
47
</td>
<td>
54
</td>
<td>
50
</td>
<td>
65
</td>
</tr>
<tr>
<th>
3
</th>
<td>
0
</td>
<td>
3
</td>
<td>
0
</td>
<td>
0
</td>
<td>
AK
</td>
<td>
343
</td>
<td>
21222.0
</td>
<td>
0.016162
</td>
<td>
west
</td>
<td>
0
</td>
<td>
…
</td>
<td>
69
</td>
<td>
38
</td>
<td>
33
</td>
<td>
40
</td>
<td>
39
</td>
<td>
18
</td>
<td>
32
</td>
<td>
35
</td>
<td>
32
</td>
<td>
39
</td>
</tr>
<tr>
<th>
4
</th>
<td>
0
</td>
<td>
0
</td>
<td>
1
</td>
<td>
0
</td>
<td>
AK
</td>
<td>
958
</td>
<td>
21222.0
</td>
<td>
0.045142
</td>
<td>
west
</td>
<td>
0
</td>
<td>
…
</td>
<td>
430
</td>
<td>
287
</td>
<td>
342
</td>
<td>
430
</td>
<td>
342
</td>
<td>
348
</td>
<td>
307
</td>
<td>
382
</td>
<td>
312
</td>
<td>
450
</td>
</tr>
</tbody>
</table>
<p>
5 rows × 1011 columns
</p>
</div>
</center>
<p>We complete the poststratification step by taking a weighted sum across the demographic cells within each state, to produce posterior predictive samples from the state-level opinion distribution.</p>
<div class="sourceCode" id="cb49"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb49-1"><a href="#cb49-1" aria-hidden="true" tabindex="-1"></a>ps_prob <span class="op">=</span> (pp_df.groupby(<span class="st">&#39;state&#39;</span>)</span>
<span id="cb49-2"><a href="#cb49-2" aria-hidden="true" tabindex="-1"></a>                .<span class="bu">apply</span>(<span class="kw">lambda</span> df: df[PP_COLS].<span class="bu">sum</span>(axis<span class="op">=</span><span class="dv">0</span>) <span class="op">/</span> df.freq.<span class="bu">sum</span>()))</span></code></pre></div>
<div class="sourceCode" id="cb50"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb50-1"><a href="#cb50-1" aria-hidden="true" tabindex="-1"></a>ps_prob.head()</span></code></pre></div>
<center>
<div>
<table border="1" class="dataframe">
<thead>
<tr style="text-align: right;">
<th>
</th>
<th>
pp_yes_of_all_0
</th>
<th>
pp_yes_of_all_1
</th>
<th>
pp_yes_of_all_2
</th>
<th>
pp_yes_of_all_3
</th>
<th>
pp_yes_of_all_4
</th>
<th>
pp_yes_of_all_5
</th>
<th>
pp_yes_of_all_6
</th>
<th>
pp_yes_of_all_7
</th>
<th>
pp_yes_of_all_8
</th>
<th>
pp_yes_of_all_9
</th>
<th>
…
</th>
<th>
pp_yes_of_all_990
</th>
<th>
pp_yes_of_all_991
</th>
<th>
pp_yes_of_all_992
</th>
<th>
pp_yes_of_all_993
</th>
<th>
pp_yes_of_all_994
</th>
<th>
pp_yes_of_all_995
</th>
<th>
pp_yes_of_all_996
</th>
<th>
pp_yes_of_all_997
</th>
<th>
pp_yes_of_all_998
</th>
<th>
pp_yes_of_all_999
</th>
</tr>
<tr>
<th>
state
</th>
<th>
</th>
<th>
</th>
<th>
</th>
<th>
</th>
<th>
</th>
<th>
</th>
<th>
</th>
<th>
</th>
<th>
</th>
<th>
</th>
<th>
</th>
<th>
</th>
<th>
</th>
<th>
</th>
<th>
</th>
<th>
</th>
<th>
</th>
<th>
</th>
<th>
</th>
<th>
</th>
<th>
</th>
</tr>
</thead>
<tbody>
<tr>
<th>
AK
</th>
<td>
0.306380
</td>
<td>
0.390585
</td>
<td>
0.361229
</td>
<td>
0.275893
</td>
<td>
0.374140
</td>
<td>
0.410847
</td>
<td>
0.362360
</td>
<td>
0.389172
</td>
<td>
0.372491
</td>
<td>
0.302281
</td>
<td>
…
</td>
<td>
0.411413
</td>
<td>
0.290312
</td>
<td>
0.297521
</td>
<td>
0.387287
</td>
<td>
0.365988
</td>
<td>
0.328386
</td>
<td>
0.316982
</td>
<td>
0.357035
</td>
<td>
0.280417
</td>
<td>
0.373433
</td>
</tr>
<tr>
<th>
AL
</th>
<td>
0.174168
</td>
<td>
0.199505
</td>
<td>
0.203892
</td>
<td>
0.155924
</td>
<td>
0.214749
</td>
<td>
0.190090
</td>
<td>
0.204509
</td>
<td>
0.203507
</td>
<td>
0.188764
</td>
<td>
0.147419
</td>
<td>
…
</td>
<td>
0.217865
</td>
<td>
0.145274
</td>
<td>
0.153651
</td>
<td>
0.220120
</td>
<td>
0.185526
</td>
<td>
0.187560
</td>
<td>
0.101283
</td>
<td>
0.175781
</td>
<td>
0.117774
</td>
<td>
0.218250
</td>
</tr>
<tr>
<th>
AR
</th>
<td>
0.142486
</td>
<td>
0.207379
</td>
<td>
0.219824
</td>
<td>
0.221326
</td>
<td>
0.229756
</td>
<td>
0.204580
</td>
<td>
0.221235
</td>
<td>
0.239279
</td>
<td>
0.193739
</td>
<td>
0.198919
</td>
<td>
…
</td>
<td>
0.210138
</td>
<td>
0.164843
</td>
<td>
0.146860
</td>
<td>
0.238502
</td>
<td>
0.185973
</td>
<td>
0.245931
</td>
<td>
0.114837
</td>
<td>
0.189018
</td>
<td>
0.164965
</td>
<td>
0.232096
</td>
</tr>
<tr>
<th>
AZ
</th>
<td>
0.353140
</td>
<td>
0.395125
</td>
<td>
0.388163
</td>
<td>
0.361972
</td>
<td>
0.394620
</td>
<td>
0.378743
</td>
<td>
0.387904
</td>
<td>
0.375209
</td>
<td>
0.385323
</td>
<td>
0.443167
</td>
<td>
…
</td>
<td>
0.390827
</td>
<td>
0.318305
</td>
<td>
0.340562
</td>
<td>
0.411255
</td>
<td>
0.376126
</td>
<td>
0.455857
</td>
<td>
0.318835
</td>
<td>
0.387193
</td>
<td>
0.329390
</td>
<td>
0.405663
</td>
</tr>
<tr>
<th>
CA
</th>
<td>
0.384078
</td>
<td>
0.463444
</td>
<td>
0.463495
</td>
<td>
0.405385
</td>
<td>
0.468195
</td>
<td>
0.475593
</td>
<td>
0.463783
</td>
<td>
0.474011
</td>
<td>
0.429405
</td>
<td>
0.431427
</td>
<td>
…
</td>
<td>
0.468451
</td>
<td>
0.384701
</td>
<td>
0.374767
</td>
<td>
0.486855
</td>
<td>
0.434450
</td>
<td>
0.475072
</td>
<td>
0.378866
</td>
<td>
0.471518
</td>
<td>
0.378529
</td>
<td>
0.496080
</td>
</tr>
</tbody>
</table>
<p>
5 rows × 1000 columns
</p>
</div>
</center>
<p>The simplest summary of state-level opinion is the posterior expected mean, shown below.</p>
<div class="sourceCode" id="cb51"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb51-1"><a href="#cb51-1" aria-hidden="true" tabindex="-1"></a>ps_mean <span class="op">=</span> ps_prob.mean(axis<span class="op">=</span><span class="dv">1</span>)</span></code></pre></div>
<div class="sourceCode" id="cb52"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb52-1"><a href="#cb52-1" aria-hidden="true" tabindex="-1"></a>ps_mean.head()</span></code></pre></div>
<pre><code>state
AK    0.365962
AL    0.189076
AR    0.201302
AZ    0.395071
CA    0.459842
dtype: float64</code></pre>
<p>The following choropleth maps show the disaggregation and MRP estimates of support for gay marriage by state.</p>
<div class="sourceCode" id="cb54"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb54-1"><a href="#cb54-1" aria-hidden="true" tabindex="-1"></a>fig, (disagg_ax, mrp_ax) <span class="op">=</span> plt.subplots(ncols<span class="op">=</span><span class="dv">2</span>, sharex<span class="op">=</span><span class="va">True</span>, sharey<span class="op">=</span><span class="va">True</span>, figsize<span class="op">=</span>(<span class="dv">16</span>, <span class="dv">6</span>))</span>
<span id="cb54-2"><a href="#cb54-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-3"><a href="#cb54-3" aria-hidden="true" tabindex="-1"></a>fig, disagg_ax, _ <span class="op">=</span> state_plot(disagg_p, p_cmap, p_norm, cbar<span class="op">=</span><span class="va">False</span>, ax<span class="op">=</span>disagg_ax)</span>
<span id="cb54-4"><a href="#cb54-4" aria-hidden="true" tabindex="-1"></a>disagg_ax.set_title(<span class="st">&quot;Disaggregation&quot;</span>)<span class="op">;</span></span>
<span id="cb54-5"><a href="#cb54-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-6"><a href="#cb54-6" aria-hidden="true" tabindex="-1"></a>fig, mrp_ax, cbar_ax <span class="op">=</span> state_plot(ps_mean, p_cmap, p_norm, ax<span class="op">=</span>mrp_ax)</span>
<span id="cb54-7"><a href="#cb54-7" aria-hidden="true" tabindex="-1"></a>cbar_ax.yaxis.set_major_formatter(p_formatter)<span class="op">;</span></span>
<span id="cb54-8"><a href="#cb54-8" aria-hidden="true" tabindex="-1"></a>mrp_ax.set_title(<span class="st">&quot;MRP&quot;</span>)<span class="op">;</span></span>
<span id="cb54-9"><a href="#cb54-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-10"><a href="#cb54-10" aria-hidden="true" tabindex="-1"></a>fig.suptitle(<span class="st">&quot;Estimated support for gay marriage in 2005&quot;</span>)<span class="op">;</span></span></code></pre></div>
<center>
<img src="/resources/mrpymc3/MRPyMC3-Multilevel%20Regression%20and%20Poststratification%20with%20PyMC3_71_0.png" title="fig:" alt="png" />
</center>
<p>Notably, MRP produces opinion estimates for Alaska and Hawaii, which disaggregation does not. The following scatter plot makes it easier to see how the estimate for each state differs between disaggregation and MRP.</p>
<div class="sourceCode" id="cb55"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb55-1"><a href="#cb55-1" aria-hidden="true" tabindex="-1"></a>disagg_p_aligned, ps_mean_aligned <span class="op">=</span> disagg_p.align(ps_mean)</span></code></pre></div>
<div class="sourceCode" id="cb56"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb56-1"><a href="#cb56-1" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots(figsize<span class="op">=</span>(<span class="dv">8</span>, <span class="dv">8</span>))</span>
<span id="cb56-2"><a href="#cb56-2" aria-hidden="true" tabindex="-1"></a>ax.set_aspect(<span class="st">&#39;equal&#39;</span>)<span class="op">;</span></span>
<span id="cb56-3"><a href="#cb56-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb56-4"><a href="#cb56-4" aria-hidden="true" tabindex="-1"></a>pct_formatter <span class="op">=</span> FuncFormatter(<span class="kw">lambda</span> prop, _: <span class="st">&#39;</span><span class="sc">{:.1%}</span><span class="st">&#39;</span>.<span class="bu">format</span>(prop))</span>
<span id="cb56-5"><a href="#cb56-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb56-6"><a href="#cb56-6" aria-hidden="true" tabindex="-1"></a>ax.plot([<span class="fl">0.1</span>, <span class="fl">0.7</span>], [<span class="fl">0.1</span>, <span class="fl">0.7</span>], <span class="st">&#39;--&#39;</span>, c<span class="op">=</span><span class="st">&#39;k&#39;</span>, label<span class="op">=</span><span class="st">&quot;No change&quot;</span>)<span class="op">;</span></span>
<span id="cb56-7"><a href="#cb56-7" aria-hidden="true" tabindex="-1"></a>ax.scatter(disagg_p_aligned, ps_mean_aligned)<span class="op">;</span></span>
<span id="cb56-8"><a href="#cb56-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb56-9"><a href="#cb56-9" aria-hidden="true" tabindex="-1"></a>ax.set_xlim(<span class="fl">0.1</span>, <span class="fl">0.7</span>)<span class="op">;</span></span>
<span id="cb56-10"><a href="#cb56-10" aria-hidden="true" tabindex="-1"></a>ax.xaxis.set_major_formatter(pct_formatter)<span class="op">;</span></span>
<span id="cb56-11"><a href="#cb56-11" aria-hidden="true" tabindex="-1"></a>ax.set_xlabel(<span class="st">&quot;Disaggregation estimate&quot;</span>)<span class="op">;</span></span>
<span id="cb56-12"><a href="#cb56-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb56-13"><a href="#cb56-13" aria-hidden="true" tabindex="-1"></a>ax.set_ylim(<span class="fl">0.1</span>, <span class="fl">0.7</span>)<span class="op">;</span></span>
<span id="cb56-14"><a href="#cb56-14" aria-hidden="true" tabindex="-1"></a>ax.yaxis.set_major_formatter(pct_formatter)<span class="op">;</span></span>
<span id="cb56-15"><a href="#cb56-15" aria-hidden="true" tabindex="-1"></a>ax.set_ylabel(<span class="st">&quot;MRP estimate&quot;</span>)<span class="op">;</span></span>
<span id="cb56-16"><a href="#cb56-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb56-17"><a href="#cb56-17" aria-hidden="true" tabindex="-1"></a>ax.legend(loc<span class="op">=</span><span class="dv">2</span>)<span class="op">;</span></span>
<span id="cb56-18"><a href="#cb56-18" aria-hidden="true" tabindex="-1"></a>ax.set_title(<span class="st">&quot;Estimated support for gay marriage in 2005&quot;</span>)<span class="op">;</span></span></code></pre></div>
<center>
<img src="/resources/mrpymc3/MRPyMC3-Multilevel%20Regression%20and%20Poststratification%20with%20PyMC3_74_0.png" title="fig:" alt="png" />
</center>
<p>We see that the MRP estimates tend to be higher than the disaggregation estimates, possibly due to under-sampling of supportive demographic cells in many states.</p>
<p>An additional advantage of MRP is that we can produce better opinion estimates for demographic subsets than disaggregation. For example, we plot below the disaggregation and MRP estimates of support for gay marriage among black men. From above, we know disaggregation will not be able to produce an estimate for many states.</p>
<div class="sourceCode" id="cb57"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb57-1"><a href="#cb57-1" aria-hidden="true" tabindex="-1"></a>black_men_disagg_p <span class="op">=</span> (survey_df[(survey_df.race_wbh <span class="op">==</span> <span class="dv">1</span>) <span class="op">&amp;</span> (survey_df.female <span class="op">==</span> <span class="dv">0</span>)]</span>
<span id="cb57-2"><a href="#cb57-2" aria-hidden="true" tabindex="-1"></a>                               .groupby(<span class="st">&#39;state&#39;</span>)</span>
<span id="cb57-3"><a href="#cb57-3" aria-hidden="true" tabindex="-1"></a>                               .yes_of_all</span>
<span id="cb57-4"><a href="#cb57-4" aria-hidden="true" tabindex="-1"></a>                               .mean())</span>
<span id="cb57-5"><a href="#cb57-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-6"><a href="#cb57-6" aria-hidden="true" tabindex="-1"></a>black_men_ps_mean <span class="op">=</span> (pp_df[(pp_df.race_wbh <span class="op">==</span> <span class="dv">1</span>) <span class="op">&amp;</span> (pp_df.female <span class="op">==</span> <span class="dv">0</span>)]</span>
<span id="cb57-7"><a href="#cb57-7" aria-hidden="true" tabindex="-1"></a>                         .groupby(<span class="st">&#39;state&#39;</span>)</span>
<span id="cb57-8"><a href="#cb57-8" aria-hidden="true" tabindex="-1"></a>                         .<span class="bu">apply</span>(<span class="kw">lambda</span> df: (df[PP_COLS].<span class="bu">sum</span>(axis<span class="op">=</span><span class="dv">0</span>) <span class="op">/</span> df.freq.<span class="bu">sum</span>()))</span>
<span id="cb57-9"><a href="#cb57-9" aria-hidden="true" tabindex="-1"></a>                         .mean(axis<span class="op">=</span><span class="dv">1</span>))</span></code></pre></div>
<div class="sourceCode" id="cb58"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb58-1"><a href="#cb58-1" aria-hidden="true" tabindex="-1"></a>fig, (disagg_ax, mrp_ax) <span class="op">=</span> plt.subplots(ncols<span class="op">=</span><span class="dv">2</span>, sharex<span class="op">=</span><span class="va">True</span>, sharey<span class="op">=</span><span class="va">True</span>, figsize<span class="op">=</span>(<span class="dv">16</span>, <span class="dv">6</span>))</span>
<span id="cb58-2"><a href="#cb58-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-3"><a href="#cb58-3" aria-hidden="true" tabindex="-1"></a>fig, disagg_ax, _ <span class="op">=</span> state_plot(black_men_disagg_p, p_cmap, p_norm, cbar<span class="op">=</span><span class="va">False</span>, ax<span class="op">=</span>disagg_ax)</span>
<span id="cb58-4"><a href="#cb58-4" aria-hidden="true" tabindex="-1"></a>disagg_ax.set_title(<span class="st">&quot;Disaggregation&quot;</span>)<span class="op">;</span></span>
<span id="cb58-5"><a href="#cb58-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-6"><a href="#cb58-6" aria-hidden="true" tabindex="-1"></a>fig, mrp_ax, cbar_ax <span class="op">=</span> state_plot(black_men_ps_mean, p_cmap, p_norm, ax<span class="op">=</span>mrp_ax)</span>
<span id="cb58-7"><a href="#cb58-7" aria-hidden="true" tabindex="-1"></a>cbar_ax.yaxis.set_major_formatter(p_formatter)<span class="op">;</span></span>
<span id="cb58-8"><a href="#cb58-8" aria-hidden="true" tabindex="-1"></a>mrp_ax.set_title(<span class="st">&quot;MRP&quot;</span>)<span class="op">;</span></span>
<span id="cb58-9"><a href="#cb58-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-10"><a href="#cb58-10" aria-hidden="true" tabindex="-1"></a>fig.suptitle(<span class="st">&quot;Estimated support for gay marriage</span><span class="ch">\n</span><span class="st">among black men in 2005&quot;</span>)<span class="op">;</span></span></code></pre></div>
<center>
<img src="/resources/mrpymc3/MRPyMC3-Multilevel%20Regression%20and%20Poststratification%20with%20PyMC3_77_0.png" title="fig:" alt="png" />
</center>
<p>In addition to the gaps in the disaggregation map above, it seems highly unlikely that not a single black man in Minnesota, Arizona, New Mexico, etc. supported gay marriage in 2005. These disaggregation estimates are due to polling few black men in these states, which MRP attempts to counteract. For further discussion of estimating the opinions of demographic subgroups using MRP, consult Ghitza and Gelman’s <a href="http://www.stat.columbia.edu/~gelman/research/published/misterp.pdf"><em>Deep Interactions with MRP: Election Turnout and Voting Patterns Among Small Electoral Subgroups</em></a>.</p>
<p>One advantage of using the fully Bayesian approach we have taken to MRP via PyMC3 is that we have access to the full posterior distribution of each state’s opinion, in addition to the posterior expected values shown in the above choropleth maps.</p>
<div class="sourceCode" id="cb59"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb59-1"><a href="#cb59-1" aria-hidden="true" tabindex="-1"></a>grid <span class="op">=</span> sns.FacetGrid(pd.melt(ps_prob.reset_index(),</span>
<span id="cb59-2"><a href="#cb59-2" aria-hidden="true" tabindex="-1"></a>                             id_vars<span class="op">=</span><span class="st">&#39;state&#39;</span>, value_vars<span class="op">=</span>PP_COLS,</span>
<span id="cb59-3"><a href="#cb59-3" aria-hidden="true" tabindex="-1"></a>                             var_name<span class="op">=</span><span class="st">&#39;pp_sample&#39;</span>, value_name<span class="op">=</span><span class="st">&#39;p&#39;</span>),</span>
<span id="cb59-4"><a href="#cb59-4" aria-hidden="true" tabindex="-1"></a>                     col<span class="op">=</span><span class="st">&#39;state&#39;</span>, col_wrap<span class="op">=</span><span class="dv">3</span>, size<span class="op">=</span><span class="dv">2</span>, aspect<span class="op">=</span><span class="fl">1.5</span>)</span>
<span id="cb59-5"><a href="#cb59-5" aria-hidden="true" tabindex="-1"></a>grid.<span class="bu">map</span>(plt.hist, <span class="st">&#39;p&#39;</span>, bins<span class="op">=</span><span class="dv">30</span>)<span class="op">;</span></span>
<span id="cb59-6"><a href="#cb59-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb59-7"><a href="#cb59-7" aria-hidden="true" tabindex="-1"></a>grid.set_xlabels(<span class="st">&quot;Posterior distribution of support</span><span class="ch">\n</span><span class="st">for gay marriage in 2005&quot;</span>)<span class="op">;</span></span>
<span id="cb59-8"><a href="#cb59-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb59-9"><a href="#cb59-9" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> ax <span class="kw">in</span> grid.axes.flat:</span>
<span id="cb59-10"><a href="#cb59-10" aria-hidden="true" tabindex="-1"></a>    ax.set_xticks(np.linspace(<span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">5</span>))<span class="op">;</span></span>
<span id="cb59-11"><a href="#cb59-11" aria-hidden="true" tabindex="-1"></a>    ax.xaxis.set_major_formatter(pct_formatter)<span class="op">;</span></span>
<span id="cb59-12"><a href="#cb59-12" aria-hidden="true" tabindex="-1"></a>    plt.setp(ax.get_xticklabels(), visible<span class="op">=</span><span class="va">True</span>)<span class="op">;</span></span>
<span id="cb59-13"><a href="#cb59-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb59-14"><a href="#cb59-14" aria-hidden="true" tabindex="-1"></a>grid.set_yticklabels([])<span class="op">;</span></span>
<span id="cb59-15"><a href="#cb59-15" aria-hidden="true" tabindex="-1"></a>grid.set_ylabels(<span class="st">&quot;Frequency&quot;</span>)<span class="op">;</span></span>
<span id="cb59-16"><a href="#cb59-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb59-17"><a href="#cb59-17" aria-hidden="true" tabindex="-1"></a>grid.fig.tight_layout()<span class="op">;</span></span>
<span id="cb59-18"><a href="#cb59-18" aria-hidden="true" tabindex="-1"></a>grid.set_titles(<span class="st">&#39;</span><span class="sc">{col_name}</span><span class="st">&#39;</span>)<span class="op">;</span></span></code></pre></div>
<center>
<img src="/resources/mrpymc3/MRPyMC3-Multilevel%20Regression%20and%20Poststratification%20with%20PyMC3_79_0.png" title="fig:" alt="png" />
</center>
<p>Specifying this model in PyMC3 would certainly have been simpler using <a href="https://github.com/bambinos/bambi">Bambi</a>, which I intend to learn soon for exactly that reason.</p>
<p>I am particularly eager to see what applications MRP will find outside of political science in the coming years.</p>
<p>This post is available as a Jupyter notebook <a href="https://gist.github.com/AustinRochford/bfc20cb3262169b41b730bd9faf74477">here</a>.</p>
