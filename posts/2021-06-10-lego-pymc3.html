<meta name="title" content="A Bayesian Analysis of Lego Prices in Python with PyMC3" />
<meta name="tags" content="Lego, Python, PyMC3, Bayesian Statistics" />
<meta name="date" content="2021-06-10" />
<meta name="has_math" content="true" /><p>This post is the second in a series of posts analyzing Lego pricing data scraped from <a href="https://brickset.com/">brickset.com</a>. The <a href="https://austinrochford.com/posts/2021-06-03-vader-meditation.html">first post</a> gave an empirical analysis of the fairness of the price for Darth Vader’s Meditation Chamber (<a href="https://www.lego.com/en-us/product/darth-vader-meditation-chamber-75296">75296</a>), disproving my initial impression that the set was overpriced for its size and prompting me to preorder it. In this post we will build several more formal models of the price of Lego sets based on their size and use them to answer a few related questions.</p>
<center>
<figure>
<img src="/resources/lego_pymc3_files/tantiveiv.png" width=500> <br>
<caption>
The newest addition to my collection (<a href="https://brickset.com/sets/75244-1/Tantive-IV">75244</a>).
</caption>
</figure>
</center>
<p>First we make the necessary Python imports and do some light housekeeping.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="op">%</span>matplotlib inline</span></code></pre></div>
<div class="sourceCode" id="cb2"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> datetime</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> functools <span class="im">import</span> <span class="bu">reduce</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> itertools <span class="im">as</span> itl</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> warnings <span class="im">import</span> filterwarnings</span></code></pre></div>
<div class="sourceCode" id="cb3"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> aesara <span class="im">import</span> shared, tensor <span class="im">as</span> at</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> arviz <span class="im">as</span> az</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> matplotlib <span class="im">import</span> MatplotlibDeprecationWarning, pyplot <span class="im">as</span> plt</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> matplotlib.lines <span class="im">import</span> Line2D</span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> matplotlib.ticker <span class="im">import</span> FuncFormatter, MultipleLocator, StrMethodFormatter</span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pandas <span class="im">as</span> pd</span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pymc3 <span class="im">as</span> pm</span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> scipy <span class="im">as</span> sp</span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn.preprocessing <span class="im">import</span> StandardScaler</span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> seaborn <span class="im">as</span> sns</span></code></pre></div>
<div class="sourceCode" id="cb4"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a>filterwarnings(<span class="st">&#39;ignore&#39;</span>, category<span class="op">=</span><span class="pp">UserWarning</span>, message<span class="op">=</span><span class="st">&quot;.*FixedFormatter.*&quot;</span>)</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>filterwarnings(<span class="st">&#39;ignore&#39;</span>, category<span class="op">=</span>MatplotlibDeprecationWarning, module<span class="op">=</span><span class="st">&#39;pandas&#39;</span>)</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>filterwarnings(<span class="st">&#39;ignore&#39;</span>, category<span class="op">=</span><span class="pp">UserWarning</span>, module<span class="op">=</span><span class="st">&#39;aesara&#39;</span>)</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>filterwarnings(<span class="st">&#39;ignore&#39;</span>, category<span class="op">=</span><span class="pp">UserWarning</span>, module<span class="op">=</span><span class="st">&#39;arviz&#39;</span>)</span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>filterwarnings(<span class="st">&#39;ignore&#39;</span>, category<span class="op">=</span><span class="pp">UserWarning</span>, module<span class="op">=</span><span class="st">&#39;pandas&#39;</span>)</span></code></pre></div>
<div class="sourceCode" id="cb5"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a>plt.rcParams[<span class="st">&#39;figure.figsize&#39;</span>] <span class="op">=</span> (<span class="dv">8</span>, <span class="dv">6</span>)</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>sns.<span class="bu">set</span>(color_codes<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>dollar_formatter <span class="op">=</span> StrMethodFormatter(<span class="st">&quot;${x:,.2f}&quot;</span>)</span></code></pre></div>
<h2 id="load-the-data">Load the Data</h2>
<p>We begin the real work by loading the data scraped from Brickset. See the <a href="https://austinrochford.com/posts/2021-06-03-vader-meditation.html">first post</a> in this series for more background on the data.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a>DATA_URL <span class="op">=</span> <span class="st">&#39;https://austinrochford.com/resources/lego/brickset_01011980_06012021.csv.gz&#39;</span></span></code></pre></div>
<div class="sourceCode" id="cb7"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> to_datetime(year):</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> np.datetime64(<span class="ss">f&quot;</span><span class="sc">{</span><span class="bu">round</span>(year)<span class="sc">}</span><span class="ss">-01-01&quot;</span>)</span></code></pre></div>
<div class="sourceCode" id="cb8"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a>full_df <span class="op">=</span> (pd.read_csv(DATA_URL,</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>                       usecols<span class="op">=</span>[</span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>                           <span class="st">&quot;Year released&quot;</span>, <span class="st">&quot;Set number&quot;</span>,</span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>                           <span class="st">&quot;Name&quot;</span>, <span class="st">&quot;Set type&quot;</span>, <span class="st">&quot;Theme&quot;</span>, <span class="st">&quot;Subtheme&quot;</span>,</span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>                           <span class="st">&quot;Pieces&quot;</span>, <span class="st">&quot;RRP&quot;</span></span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a>                       ])</span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a>             .dropna(subset<span class="op">=</span>[</span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a>                 <span class="st">&quot;Year released&quot;</span>, <span class="st">&quot;Set number&quot;</span>,</span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a>                 <span class="st">&quot;Name&quot;</span>, <span class="st">&quot;Set type&quot;</span>, <span class="st">&quot;Theme&quot;</span>,</span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a>                 <span class="st">&quot;Pieces&quot;</span>, <span class="st">&quot;RRP&quot;</span></span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true" tabindex="-1"></a>             ]))</span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true" tabindex="-1"></a>full_df[<span class="st">&quot;Year released&quot;</span>] <span class="op">=</span> full_df[<span class="st">&quot;Year released&quot;</span>].<span class="bu">apply</span>(to_datetime)</span>
<span id="cb8-13"><a href="#cb8-13" aria-hidden="true" tabindex="-1"></a>full_df <span class="op">=</span> (full_df.set_index([<span class="st">&quot;Year released&quot;</span>, <span class="st">&quot;Set number&quot;</span>])</span>
<span id="cb8-14"><a href="#cb8-14" aria-hidden="true" tabindex="-1"></a>                  .sort_index())</span></code></pre></div>
<p>We see that the data set contains information on approximately 8,500 Lego sets produced between 1980 and June 2021.</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a>full_df.head()</span></code></pre></div>
<center>
<div>
<style scoped>
.dataframe tbody tr th:only-of-type {
vertical-align: middle;
}

.dataframe tbody tr th {
vertical-align: top;
}

.dataframe thead th {
text-align: right;
}
</style>
<table border="1" class="dataframe">
<thead>
<tr style="text-align: right;">
<th>
</th>
<th>
</th>
<th>
Name
</th>
<th>
Set type
</th>
<th>
Theme
</th>
<th>
Pieces
</th>
<th>
RRP
</th>
<th>
Subtheme
</th>
</tr>
<tr>
<th>
Year released
</th>
<th>
Set number
</th>
<th>
</th>
<th>
</th>
<th>
</th>
<th>
</th>
<th>
</th>
<th>
</th>
</tr>
</thead>
<tbody>
<tr>
<th rowspan="5" valign="top">
1980-01-01
</th>
<th>
1041-2
</th>
<td>
Educational Duplo Building Set
</td>
<td>
Normal
</td>
<td>
Dacta
</td>
<td>
68.0
</td>
<td>
36.50
</td>
<td>
NaN
</td>
</tr>
<tr>
<th>
1075-1
</th>
<td>
LEGO People Supplementary Set
</td>
<td>
Normal
</td>
<td>
Dacta
</td>
<td>
304.0
</td>
<td>
14.50
</td>
<td>
NaN
</td>
</tr>
<tr>
<th>
1101-1
</th>
<td>
Replacement 4.5V Motor
</td>
<td>
Normal
</td>
<td>
Service Packs
</td>
<td>
1.0
</td>
<td>
5.65
</td>
<td>
NaN
</td>
</tr>
<tr>
<th>
1123-1
</th>
<td>
Ball and Socket Couplings &amp; One Articulated Joint
</td>
<td>
Normal
</td>
<td>
Service Packs
</td>
<td>
8.0
</td>
<td>
16.00
</td>
<td>
NaN
</td>
</tr>
<tr>
<th>
1130-1
</th>
<td>
Plastic Folder for Building Instructions
</td>
<td>
Normal
</td>
<td>
Service Packs
</td>
<td>
1.0
</td>
<td>
14.00
</td>
<td>
NaN
</td>
</tr>
</tbody>
</table>
</div>
</center>
<p><br></p>
<div class="sourceCode" id="cb10"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a>full_df.tail()</span></code></pre></div>
<center>
<div>
<style scoped>
.dataframe tbody tr th:only-of-type {
vertical-align: middle;
}

.dataframe tbody tr th {
vertical-align: top;
}

.dataframe thead th {
text-align: right;
}
</style>
<table border="1" class="dataframe">
<thead>
<tr style="text-align: right;">
<th>
</th>
<th>
</th>
<th>
Name
</th>
<th>
Set type
</th>
<th>
Theme
</th>
<th>
Pieces
</th>
<th>
RRP
</th>
<th>
Subtheme
</th>
</tr>
<tr>
<th>
Year released
</th>
<th>
Set number
</th>
<th>
</th>
<th>
</th>
<th>
</th>
<th>
</th>
<th>
</th>
<th>
</th>
</tr>
</thead>
<tbody>
<tr>
<th rowspan="5" valign="top">
2021-01-01
</th>
<th>
80022-1
</th>
<td>
Spider Queen’s Arachnoid Base
</td>
<td>
Normal
</td>
<td>
Monkie Kid
</td>
<td>
1170.0
</td>
<td>
119.99
</td>
<td>
Season 2
</td>
</tr>
<tr>
<th>
80023-1
</th>
<td>
Monkie Kid’s Team Dronecopter
</td>
<td>
Normal
</td>
<td>
Monkie Kid
</td>
<td>
1462.0
</td>
<td>
149.99
</td>
<td>
Season 2
</td>
</tr>
<tr>
<th>
80024-1
</th>
<td>
The Legendary Flower Fruit Mountain
</td>
<td>
Normal
</td>
<td>
Monkie Kid
</td>
<td>
1949.0
</td>
<td>
169.99
</td>
<td>
Season 2
</td>
</tr>
<tr>
<th>
80106-1
</th>
<td>
Story of Nian
</td>
<td>
Normal
</td>
<td>
Seasonal
</td>
<td>
1067.0
</td>
<td>
79.99
</td>
<td>
Chinese Traditional Festivals
</td>
</tr>
<tr>
<th>
80107-1
</th>
<td>
Spring Lantern Festival
</td>
<td>
Normal
</td>
<td>
Seasonal
</td>
<td>
1793.0
</td>
<td>
119.99
</td>
<td>
Chinese Traditional Festivals
</td>
</tr>
</tbody>
</table>
</div>
</center>
<p><br></p>
<div class="sourceCode" id="cb11"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a>full_df.describe()</span></code></pre></div>
<center>
<div>
<style scoped>
.dataframe tbody tr th:only-of-type {
vertical-align: middle;
}

.dataframe tbody tr th {
vertical-align: top;
}

.dataframe thead th {
text-align: right;
}
</style>
<table border="1" class="dataframe">
<thead>
<tr style="text-align: right;">
<th>
</th>
<th>
Pieces
</th>
<th>
RRP
</th>
</tr>
</thead>
<tbody>
<tr>
<th>
count
</th>
<td>
8502.000000
</td>
<td>
8502.000000
</td>
</tr>
<tr>
<th>
mean
</th>
<td>
258.739591
</td>
<td>
31.230506
</td>
</tr>
<tr>
<th>
std
</th>
<td>
481.627846
</td>
<td>
44.993559
</td>
</tr>
<tr>
<th>
min
</th>
<td>
0.000000
</td>
<td>
0.000000
</td>
</tr>
<tr>
<th>
25%
</th>
<td>
32.000000
</td>
<td>
7.000000
</td>
</tr>
<tr>
<th>
50%
</th>
<td>
98.000000
</td>
<td>
17.000000
</td>
</tr>
<tr>
<th>
75%
</th>
<td>
300.000000
</td>
<td>
39.990000
</td>
</tr>
<tr>
<th>
max
</th>
<td>
11695.000000
</td>
<td>
799.990000
</td>
</tr>
</tbody>
</table>
</div>
</center>
<p><br></p>
<p>We also load data about my personal collection and add a column to <code>full_df</code> indicating whether or not I own each set.</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a>MY_COLLECTION_URL <span class="op">=</span> <span class="st">&#39;https://austinrochford.com/resources/lego/Brickset-MySets-owned-20210602.csv&#39;</span></span></code></pre></div>
<div class="sourceCode" id="cb13"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a>my_df <span class="op">=</span> pd.read_csv(MY_COLLECTION_URL)</span></code></pre></div>
<div class="sourceCode" id="cb14"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a>my_df.index</span></code></pre></div>
<pre><code>Index([&#39;8092-1&#39;, &#39;10221-1&#39;, &#39;10266-1&#39;, &#39;10281-1&#39;, &#39;10283-1&#39;, &#39;21309-1&#39;,
       &#39;21312-1&#39;, &#39;21320-1&#39;, &#39;21321-1&#39;, &#39;31091-1&#39;, &#39;40174-1&#39;, &#39;40268-1&#39;,
       &#39;40391-1&#39;, &#39;40431-1&#39;, &#39;40440-1&#39;, &#39;41602-1&#39;, &#39;41608-1&#39;, &#39;41609-1&#39;,
       &#39;41628-1&#39;, &#39;75030-1&#39;, &#39;75049-1&#39;, &#39;75074-1&#39;, &#39;75075-1&#39;, &#39;75093-1&#39;,
       &#39;75099-1&#39;, &#39;75136-1&#39;, &#39;75137-1&#39;, &#39;75138-1&#39;, &#39;75162-1&#39;, &#39;75176-1&#39;,
       &#39;75187-1&#39;, &#39;75229-1&#39;, &#39;75243-1&#39;, &#39;75244-1&#39;, &#39;75248-1&#39;, &#39;75254-1&#39;,
       &#39;75255-1&#39;, &#39;75263-1&#39;, &#39;75264-1&#39;, &#39;75266-1&#39;, &#39;75267-1&#39;, &#39;75269-1&#39;,
       &#39;75273-1&#39;, &#39;75277-1&#39;, &#39;75278-1&#39;, &#39;75283-1&#39;, &#39;75292-1&#39;, &#39;75297-1&#39;,
       &#39;75302-1&#39;, &#39;75306-1&#39;, &#39;75308-1&#39;, &#39;75317-1&#39;, &#39;75318-1&#39;],
      dtype=&#39;object&#39;)</code></pre>
<div class="sourceCode" id="cb16"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a>full_df[<span class="st">&quot;austin&quot;</span>] <span class="op">=</span> (full_df.index</span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a>                            .get_level_values(<span class="st">&quot;Set number&quot;</span>)</span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a>                            .isin(my_df.index))</span></code></pre></div>
<p>Since the data spans more than 40 years, it is important to adjust for inflation. We use the <a href="https://fred.stlouisfed.org/series/CPIAUCNS">Consumer Price Index for All Urban Consumers: All Items in U.S. City Average</a> from the U.S. Federal Reserve to adjust for inflation.</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a>CPI_URL <span class="op">=</span> <span class="st">&#39;https://austinrochford.com/resources/lego/CPIAUCNS202100401.csv&#39;</span></span></code></pre></div>
<div class="sourceCode" id="cb18"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a>years <span class="op">=</span> pd.date_range(<span class="st">&#39;1979-01-01&#39;</span>, <span class="st">&#39;2021-01-01&#39;</span>, freq<span class="op">=</span><span class="st">&#39;Y&#39;</span>) <span class="op">\</span></span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a>            <span class="op">+</span> datetime.timedelta(days<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a>cpi_df <span class="op">=</span> (pd.read_csv(CPI_URL, index_col<span class="op">=</span><span class="st">&quot;DATE&quot;</span>, parse_dates<span class="op">=</span>[<span class="st">&quot;DATE&quot;</span>])</span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a>            .loc[years])</span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a>cpi_df[<span class="st">&quot;to2021&quot;</span>] <span class="op">=</span> cpi_df.loc[<span class="st">&quot;2021-01-01&quot;</span>] <span class="op">/</span> cpi_df</span></code></pre></div>
<p>We now add a column <code>RRP2021</code>, which is <code>RRP</code> adjusted to 2021 dollars.</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a>full_df[<span class="st">&quot;RRP2021&quot;</span>] <span class="op">=</span> (pd.merge(full_df, cpi_df,</span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a>                               left_on<span class="op">=</span>[<span class="st">&quot;Year released&quot;</span>],</span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a>                               right_index<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a>                        .<span class="bu">apply</span>(<span class="kw">lambda</span> df: df[<span class="st">&quot;RRP&quot;</span>] <span class="op">*</span> df[<span class="st">&quot;to2021&quot;</span>],</span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a>                               axis<span class="op">=</span><span class="dv">1</span>))</span></code></pre></div>
<p>Based on the exploratory data analysis in the previous post, we filter <code>full_df</code> down to approximately 6,300 sets to be included in our analysis.</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a>FILTERS <span class="op">=</span> [</span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a>    full_df[<span class="st">&quot;Set type&quot;</span>] <span class="op">==</span> <span class="st">&quot;Normal&quot;</span>,</span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a>    full_df[<span class="st">&quot;Pieces&quot;</span>] <span class="op">&gt;</span> <span class="dv">10</span>,</span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a>    full_df[<span class="st">&quot;Theme&quot;</span>] <span class="op">!=</span> <span class="st">&quot;Duplo&quot;</span>,</span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true" tabindex="-1"></a>    full_df[<span class="st">&quot;Theme&quot;</span>] <span class="op">!=</span> <span class="st">&quot;Service Packs&quot;</span>,</span>
<span id="cb20-6"><a href="#cb20-6" aria-hidden="true" tabindex="-1"></a>    full_df[<span class="st">&quot;Theme&quot;</span>] <span class="op">!=</span> <span class="st">&quot;Bulk Bricks&quot;</span>,</span>
<span id="cb20-7"><a href="#cb20-7" aria-hidden="true" tabindex="-1"></a>    full_df[<span class="st">&quot;RRP&quot;</span>] <span class="op">&gt;</span> <span class="dv">0</span></span>
<span id="cb20-8"><a href="#cb20-8" aria-hidden="true" tabindex="-1"></a>]</span></code></pre></div>
<div class="sourceCode" id="cb21"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a>df <span class="op">=</span> full_df[<span class="bu">reduce</span>(np.logical_and, FILTERS)].copy()</span></code></pre></div>
<div class="sourceCode" id="cb22"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a>df.head()</span></code></pre></div>
<center>
<div>
<style scoped>
.dataframe tbody tr th:only-of-type {
vertical-align: middle;
}

.dataframe tbody tr th {
vertical-align: top;
}

.dataframe thead th {
text-align: right;
}
</style>
<table border="1" class="dataframe">
<thead>
<tr style="text-align: right;">
<th>
</th>
<th>
</th>
<th>
Name
</th>
<th>
Set type
</th>
<th>
Theme
</th>
<th>
Pieces
</th>
<th>
RRP
</th>
<th>
Subtheme
</th>
<th>
austin
</th>
<th>
RRP2021
</th>
</tr>
<tr>
<th>
Year released
</th>
<th>
Set number
</th>
<th>
</th>
<th>
</th>
<th>
</th>
<th>
</th>
<th>
</th>
<th>
</th>
<th>
</th>
<th>
</th>
</tr>
</thead>
<tbody>
<tr>
<th rowspan="5" valign="top">
1980-01-01
</th>
<th>
1041-2
</th>
<td>
Educational Duplo Building Set
</td>
<td>
Normal
</td>
<td>
Dacta
</td>
<td>
68.0
</td>
<td>
36.50
</td>
<td>
NaN
</td>
<td>
False
</td>
<td>
122.721632
</td>
</tr>
<tr>
<th>
1075-1
</th>
<td>
LEGO People Supplementary Set
</td>
<td>
Normal
</td>
<td>
Dacta
</td>
<td>
304.0
</td>
<td>
14.50
</td>
<td>
NaN
</td>
<td>
False
</td>
<td>
48.752429
</td>
</tr>
<tr>
<th>
5233-1
</th>
<td>
Bedroom
</td>
<td>
Normal
</td>
<td>
Homemaker
</td>
<td>
26.0
</td>
<td>
4.50
</td>
<td>
NaN
</td>
<td>
False
</td>
<td>
15.130064
</td>
</tr>
<tr>
<th>
6305-1
</th>
<td>
Trees and Flowers
</td>
<td>
Normal
</td>
<td>
Town
</td>
<td>
12.0
</td>
<td>
3.75
</td>
<td>
Accessories
</td>
<td>
False
</td>
<td>
12.608387
</td>
</tr>
<tr>
<th>
6306-1
</th>
<td>
Road Signs
</td>
<td>
Normal
</td>
<td>
Town
</td>
<td>
12.0
</td>
<td>
2.50
</td>
<td>
Accessories
</td>
<td>
False
</td>
<td>
8.405591
</td>
</tr>
</tbody>
</table>
</div>
</center>
<p><br></p>
<div class="sourceCode" id="cb23"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a>df.describe()</span></code></pre></div>
<center>
<div>
<style scoped>
.dataframe tbody tr th:only-of-type {
vertical-align: middle;
}

.dataframe tbody tr th {
vertical-align: top;
}

.dataframe thead th {
text-align: right;
}
</style>
<table border="1" class="dataframe">
<thead>
<tr style="text-align: right;">
<th>
</th>
<th>
Pieces
</th>
<th>
RRP
</th>
<th>
RRP2021
</th>
</tr>
</thead>
<tbody>
<tr>
<th>
count
</th>
<td>
6312.000000
</td>
<td>
6312.000000
</td>
<td>
6312.000000
</td>
</tr>
<tr>
<th>
mean
</th>
<td>
337.177440
</td>
<td>
37.038246
</td>
<td>
45.795998
</td>
</tr>
<tr>
<th>
std
</th>
<td>
535.619271
</td>
<td>
49.657704
</td>
<td>
58.952563
</td>
</tr>
<tr>
<th>
min
</th>
<td>
11.000000
</td>
<td>
0.600000
</td>
<td>
0.971220
</td>
</tr>
<tr>
<th>
25%
</th>
<td>
68.000000
</td>
<td>
9.990000
</td>
<td>
11.866173
</td>
</tr>
<tr>
<th>
50%
</th>
<td>
177.000000
</td>
<td>
19.990000
</td>
<td>
26.712319
</td>
</tr>
<tr>
<th>
75%
</th>
<td>
400.000000
</td>
<td>
49.500000
</td>
<td>
55.952471
</td>
</tr>
<tr>
<th>
max
</th>
<td>
11695.000000
</td>
<td>
799.990000
</td>
<td>
897.373477
</td>
</tr>
</tbody>
</table>
</div>
</center>
<p><br></p>
<h2 id="modeling">Modeling</h2>
<p>Upon plotting the data, a linear relationship between the logarithm of pieces and the logarithm of reccomended retail price (in 2021 dollars) becomes immediately apparent.</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a>ax <span class="op">=</span> sns.scatterplot(x<span class="op">=</span><span class="st">&quot;Pieces&quot;</span>, y<span class="op">=</span><span class="st">&quot;RRP2021&quot;</span>, data<span class="op">=</span>df,</span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a>                alpha<span class="op">=</span><span class="fl">0.05</span>)<span class="op">;</span></span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true" tabindex="-1"></a>sns.scatterplot(x<span class="op">=</span><span class="st">&quot;Pieces&quot;</span>, y<span class="op">=</span><span class="st">&quot;RRP2021&quot;</span>,</span>
<span id="cb24-4"><a href="#cb24-4" aria-hidden="true" tabindex="-1"></a>                data<span class="op">=</span>df[df[<span class="st">&quot;austin&quot;</span>] <span class="op">==</span> <span class="va">True</span>],</span>
<span id="cb24-5"><a href="#cb24-5" aria-hidden="true" tabindex="-1"></a>                label<span class="op">=</span><span class="st">&quot;My sets&quot;</span>, ax<span class="op">=</span>ax)<span class="op">;</span> </span>
<span id="cb24-6"><a href="#cb24-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-7"><a href="#cb24-7" aria-hidden="true" tabindex="-1"></a>ax.set_xscale(<span class="st">&#39;log&#39;</span>)<span class="op">;</span></span>
<span id="cb24-8"><a href="#cb24-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-9"><a href="#cb24-9" aria-hidden="true" tabindex="-1"></a>ax.set_yscale(<span class="st">&#39;log&#39;</span>)<span class="op">;</span></span>
<span id="cb24-10"><a href="#cb24-10" aria-hidden="true" tabindex="-1"></a>ax.set_ylabel(<span class="st">&quot;Retail price (2021 $)&quot;</span>)<span class="op">;</span></span>
<span id="cb24-11"><a href="#cb24-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-12"><a href="#cb24-12" aria-hidden="true" tabindex="-1"></a>ax.legend(loc<span class="op">=</span><span class="st">&#39;upper left&#39;</span>)<span class="op">;</span></span></code></pre></div>
<center>
<img src="/resources/lego_pymc3_files/lego_pymc3_31_0.png" title="fig:" alt="png" />
</center>
<h3 id="pooled-model">Pooled model</h3>
<p>We start with a very simple pooled linear model of log price versus log pieces. Let <span class="math inline">\(Y_i\)</span> denote the recommended retail price of the <span class="math inline">\(i\)</span>-th set and <span class="math inline">\(y_i = \log Y_i\)</span>. Similarly, let <span class="math inline">\(X_i\)</span> denote the number of pieces in the <span class="math inline">\(i\)</span>-th set and <span class="math inline">\(x_i = \log X_i\)</span>. Due to the log-log linear relationship between <span class="math inline">\(Y_i\)</span> and <span class="math inline">\(X_i\)</span>, our models will take the form</p>
<p><span class="math display">\[Y_i = f_i(X_i) \cdot \varepsilon_i,\]</span></p>
<p>where <span class="math inline">\(\varepsilon_i\)</span> accounts for the unmeasured noise in the price of the <span class="math inline">\(i\)</span>-th set. We place a <a href="https://en.wikipedia.org/wiki/Log-normal_distribution">log-normal</a> prior on <span class="math inline">\(\varepsilon_i\)</span> so that $ (_i) = 1$ and <span class="math inline">\(\textrm{Var}\left(\log(\varepsilon_j)\right) = \sigma_i^2.\)</span> standard <a href="https://en.wikipedia.org/wiki/Log-normal_distribution#Generation_and_parameters">distributional math</a> shows that</p>
<p><span class="math display">\[y_i \sim N\left(\log\left(f_i(X_i))\right) - \frac{\sigma_i^2}{2}, \sigma_i^2\right).\]</span></p>
<p>Each model is of the form</p>
<p><span class="math display">\[f_i(X_i) = b_{0, i} \cdot X_i^{\beta_i},\]</span></p>
<p>so</p>
<p><span class="math display">\[\log\left(f_i(X_i)\right) = \beta_{0, i} + \beta_i x_i,\]</span></p>
<p>where <span class="math inline">\(\beta_{0, i} = \log b_{0, i}\)</span>.</p>
<p>We define <code>log_pieces</code> and <code>log_rrp2021</code> which correspond to <span class="math inline">\(x_i\)</span> and <span class="math inline">\(y_i\)</span> respectively.</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a>pieces <span class="op">=</span> df[<span class="st">&quot;Pieces&quot;</span>].values</span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a>log_pieces <span class="op">=</span> np.log(df[<span class="st">&quot;Pieces&quot;</span>].values)</span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-4"><a href="#cb25-4" aria-hidden="true" tabindex="-1"></a>rrp2021 <span class="op">=</span> df[<span class="st">&quot;RRP2021&quot;</span>].values</span>
<span id="cb25-5"><a href="#cb25-5" aria-hidden="true" tabindex="-1"></a>log_rrp2021 <span class="op">=</span> np.log(rrp2021)</span></code></pre></div>
<p>For computational efficiency, we will standardize <span class="math inline">\(x_i\)</span> to produce <span class="math inline">\(\tilde{x}_i\)</span> which has mean zero and variance one.</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a>scaler <span class="op">=</span> StandardScaler().fit(log_pieces[:, np.newaxis])</span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> scale_log_pieces(log_pieces, scaler<span class="op">=</span>scaler):</span>
<span id="cb26-4"><a href="#cb26-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> scaler.transform(log_pieces[:, np.newaxis])[:, <span class="dv">0</span>]</span>
<span id="cb26-5"><a href="#cb26-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-6"><a href="#cb26-6" aria-hidden="true" tabindex="-1"></a>std_log_pieces <span class="op">=</span> scale_log_pieces(log_pieces)</span>
<span id="cb26-7"><a href="#cb26-7" aria-hidden="true" tabindex="-1"></a>std_log_pieces_ <span class="op">=</span> shared(std_log_pieces)</span></code></pre></div>
<p>Here definining <code>std_log_pieces_</code> as an <code>aesara</code> <code>shared</code> variable will allow us to change its value later for posterior predictive sampling.</p>
<p>Our models are therefore given by</p>
<p><span class="math display">\[\log\left(f_i(X_i)\right) = \beta_{0, i} + \beta_i \tilde{x}_i.\]</span></p>
<p>For the pooled model, <span class="math inline">\(\beta_{0, i} = \beta_0\)</span>, <span class="math inline">\(\beta_i = \beta\)</span>, and <span class="math inline">\(\sigma_i = \sigma\)</span> are constant across all sets. We give them the priors</p>
<p><span class="math display">\[
\begin{align*}
    \beta_0
        &amp; \sim N(0, 2.5^2) \\
    \beta
        &amp; \sim N(0, 2.5^2) \\
    \sigma
        &amp; \sim \textrm{HalfNormal}(5^2).
\end{align*}
\]</span></p>
<div class="sourceCode" id="cb27"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a><span class="cf">with</span> pm.Model() <span class="im">as</span> pooled_model:</span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a>    β<span class="dv">0</span> <span class="op">=</span> pm.Normal(<span class="st">&quot;β0&quot;</span>, <span class="fl">0.</span>, <span class="fl">2.5</span>)</span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true" tabindex="-1"></a>    β_pieces <span class="op">=</span> pm.Normal(<span class="st">&quot;β_pieces&quot;</span>, <span class="fl">0.</span>, <span class="fl">2.5</span>)</span>
<span id="cb27-4"><a href="#cb27-4" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb27-5"><a href="#cb27-5" aria-hidden="true" tabindex="-1"></a>    σ <span class="op">=</span> pm.HalfNormal(<span class="st">&quot;σ&quot;</span>, <span class="fl">5.</span>)</span></code></pre></div>
<p>We define the mean and likelihood of the observed data as above.</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a><span class="cf">with</span> pooled_model:</span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true" tabindex="-1"></a>    μ <span class="op">=</span> β<span class="dv">0</span> <span class="op">+</span> β_pieces <span class="op">*</span> std_log_pieces_ <span class="op">-</span> <span class="fl">0.5</span> <span class="op">*</span> σ<span class="op">**</span><span class="dv">2</span></span>
<span id="cb28-3"><a href="#cb28-3" aria-hidden="true" tabindex="-1"></a>    obs <span class="op">=</span> pm.Normal(<span class="st">&quot;obs&quot;</span>, μ, σ, observed<span class="op">=</span>log_rrp2021)</span></code></pre></div>
<p>We now sample from posterior distribution of this model.</p>
<div class="sourceCode" id="cb29"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a>CHAINS <span class="op">=</span> <span class="dv">3</span></span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true" tabindex="-1"></a>SEED <span class="op">=</span> <span class="dv">123456789</span></span>
<span id="cb29-3"><a href="#cb29-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-4"><a href="#cb29-4" aria-hidden="true" tabindex="-1"></a>SAMPLE_KWARGS <span class="op">=</span> {</span>
<span id="cb29-5"><a href="#cb29-5" aria-hidden="true" tabindex="-1"></a>    <span class="st">&#39;cores&#39;</span>: CHAINS,</span>
<span id="cb29-6"><a href="#cb29-6" aria-hidden="true" tabindex="-1"></a>    <span class="st">&#39;random_seed&#39;</span>: [SEED <span class="op">+</span> i <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(CHAINS)],</span>
<span id="cb29-7"><a href="#cb29-7" aria-hidden="true" tabindex="-1"></a>    <span class="st">&#39;return_inferencedata&#39;</span>: <span class="va">True</span></span>
<span id="cb29-8"><a href="#cb29-8" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<div class="sourceCode" id="cb30"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a><span class="cf">with</span> pooled_model:</span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true" tabindex="-1"></a>    pooled_trace <span class="op">=</span> pm.sample(<span class="op">**</span>SAMPLE_KWARGS)</span></code></pre></div>
<pre><code>Auto-assigning NUTS sampler...
Initializing NUTS using jitter+adapt_diag...
Multiprocess sampling (3 chains in 3 jobs)
NUTS: [β0, β_pieces, σ]</code></pre>
<div>
<style>
/* Turns off some styling */
progress {
/* gets rid of default border in Firefox and Opera. */
border: none;
/* Needs to be in here for Safari polyfill so background images work as expected. */
background-size: auto;
}
.progress-bar-interrupted, .progress-bar-interrupted::-webkit-progress-bar {
background: #F44336;
}
</style>
<progress value="6000" class max="6000" style="width:300px; height:20px; vertical-align: middle;">
</progress>
<p>100.00% [6000/6000 00:15&lt;00:00 Sampling 3 chains, 0 divergences]</p>
</div>
<pre><code>Sampling 3 chains for 1_000 tune and 1_000 draw iterations (3_000 + 3_000 draws total) took 18 seconds.</code></pre>
<p>The energy plot, BFMI, and <span class="math inline">\(\hat{R}\)</span> statistics for these samples show no cause for concern.</p>
<div class="sourceCode" id="cb33"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> make_diagnostic_plots(trace, axes<span class="op">=</span><span class="va">None</span>, min_mult<span class="op">=</span><span class="fl">0.995</span>, max_mult<span class="op">=</span><span class="fl">1.005</span>):</span>
<span id="cb33-2"><a href="#cb33-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> axes <span class="kw">is</span> <span class="va">None</span>:</span>
<span id="cb33-3"><a href="#cb33-3" aria-hidden="true" tabindex="-1"></a>        fig, axes <span class="op">=</span> plt.subplots(ncols<span class="op">=</span><span class="dv">2</span>, sharex<span class="op">=</span><span class="va">False</span>, sharey<span class="op">=</span><span class="va">False</span>,</span>
<span id="cb33-4"><a href="#cb33-4" aria-hidden="true" tabindex="-1"></a>                                 figsize<span class="op">=</span>(<span class="dv">16</span>, <span class="dv">6</span>))</span>
<span id="cb33-5"><a href="#cb33-5" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb33-6"><a href="#cb33-6" aria-hidden="true" tabindex="-1"></a>    az.plot_energy(trace, ax<span class="op">=</span>axes[<span class="dv">0</span>])</span>
<span id="cb33-7"><a href="#cb33-7" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb33-8"><a href="#cb33-8" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb33-9"><a href="#cb33-9" aria-hidden="true" tabindex="-1"></a>    rhat <span class="op">=</span> az.rhat(trace).<span class="bu">max</span>()</span>
<span id="cb33-10"><a href="#cb33-10" aria-hidden="true" tabindex="-1"></a>    axes[<span class="dv">1</span>].barh(np.arange(<span class="bu">len</span>(rhat.variables)), rhat.to_array(),</span>
<span id="cb33-11"><a href="#cb33-11" aria-hidden="true" tabindex="-1"></a>                 tick_label<span class="op">=</span><span class="bu">list</span>(rhat.variables.keys()))</span>
<span id="cb33-12"><a href="#cb33-12" aria-hidden="true" tabindex="-1"></a>    axes[<span class="dv">1</span>].axvline(<span class="dv">1</span>, c<span class="op">=</span><span class="st">&#39;k&#39;</span>, ls<span class="op">=</span><span class="st">&#39;--&#39;</span>)</span>
<span id="cb33-13"><a href="#cb33-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-14"><a href="#cb33-14" aria-hidden="true" tabindex="-1"></a>    axes[<span class="dv">1</span>].set_xlim(</span>
<span id="cb33-15"><a href="#cb33-15" aria-hidden="true" tabindex="-1"></a>        min_mult <span class="op">*</span> <span class="bu">min</span>(rhat.<span class="bu">min</span>().to_array().<span class="bu">min</span>(), <span class="dv">1</span>),</span>
<span id="cb33-16"><a href="#cb33-16" aria-hidden="true" tabindex="-1"></a>        max_mult <span class="op">*</span> <span class="bu">max</span>(rhat.<span class="bu">max</span>().to_array().<span class="bu">max</span>(), <span class="dv">1</span>)</span>
<span id="cb33-17"><a href="#cb33-17" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb33-18"><a href="#cb33-18" aria-hidden="true" tabindex="-1"></a>    axes[<span class="dv">1</span>].set_xlabel(<span class="vs">r&quot;$\hat</span><span class="sc">{R}</span><span class="vs">$&quot;</span>)</span>
<span id="cb33-19"><a href="#cb33-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-20"><a href="#cb33-20" aria-hidden="true" tabindex="-1"></a>    axes[<span class="dv">1</span>].set_ylabel(<span class="st">&quot;Variable&quot;</span>)</span>
<span id="cb33-21"><a href="#cb33-21" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb33-22"><a href="#cb33-22" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> fig, axes</span></code></pre></div>
<div class="sourceCode" id="cb34"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a>make_diagnostic_plots(pooled_trace)<span class="op">;</span></span></code></pre></div>
<center>
<img src="/resources/lego_pymc3_files/lego_pymc3_45_0.png" title="fig:" alt="png" />
</center>
<p>We sample from the posterior predictive distribution at the observed data points and plot the residuals.</p>
<div class="sourceCode" id="cb35"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true" tabindex="-1"></a><span class="cf">with</span> pooled_model:</span>
<span id="cb35-2"><a href="#cb35-2" aria-hidden="true" tabindex="-1"></a>    pp_trace_data <span class="op">=</span> pm.sample_posterior_predictive(pooled_trace)</span>
<span id="cb35-3"><a href="#cb35-3" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb35-4"><a href="#cb35-4" aria-hidden="true" tabindex="-1"></a>df[<span class="st">&quot;pooled_resid&quot;</span>] <span class="op">=</span> (log_rrp2021 <span class="op">-</span> pp_trace_data[<span class="st">&quot;obs&quot;</span>]).mean(axis<span class="op">=</span><span class="dv">0</span>)</span></code></pre></div>
<div>
<style>
/* Turns off some styling */
progress {
/* gets rid of default border in Firefox and Opera. */
border: none;
/* Needs to be in here for Safari polyfill so background images work as expected. */
background-size: auto;
}
.progress-bar-interrupted, .progress-bar-interrupted::-webkit-progress-bar {
background: #F44336;
}
</style>
<progress value="3000" class max="3000" style="width:300px; height:20px; vertical-align: middle;">
</progress>
<p>100.00% [3000/3000 00:02&lt;00:00]</p>
</div>
<div class="sourceCode" id="cb36"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true" tabindex="-1"></a>ax <span class="op">=</span> sns.scatterplot(x<span class="op">=</span><span class="st">&quot;Pieces&quot;</span>, y<span class="op">=</span><span class="st">&quot;pooled_resid&quot;</span>, data<span class="op">=</span>df,</span>
<span id="cb36-2"><a href="#cb36-2" aria-hidden="true" tabindex="-1"></a>                     alpha<span class="op">=</span><span class="fl">0.1</span>)</span>
<span id="cb36-3"><a href="#cb36-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-4"><a href="#cb36-4" aria-hidden="true" tabindex="-1"></a>ax.set_xscale(<span class="st">&#39;log&#39;</span>)<span class="op">;</span></span>
<span id="cb36-5"><a href="#cb36-5" aria-hidden="true" tabindex="-1"></a>ax.set_xlabel(<span class="st">&quot;Pieces&quot;</span>)<span class="op">;</span></span>
<span id="cb36-6"><a href="#cb36-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-7"><a href="#cb36-7" aria-hidden="true" tabindex="-1"></a>ax.set_ylabel(<span class="st">&quot;Log RRP residual (2021 $)&quot;</span>)<span class="op">;</span></span>
<span id="cb36-8"><a href="#cb36-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-9"><a href="#cb36-9" aria-hidden="true" tabindex="-1"></a>ax.set_title(<span class="st">&quot;Pooled model&quot;</span>)<span class="op">;</span></span></code></pre></div>
<center>
<img src="/resources/lego_pymc3_files/lego_pymc3_48_0.png" title="fig:" alt="png" />
</center>
<p>We will investigate these residuals further shortly. First we sample from the posterior predictive distribution along a grid spanning reasonable values of pieces and plot the resulting predictions.</p>
<div class="sourceCode" id="cb37"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true" tabindex="-1"></a>pp_pieces <span class="op">=</span> np.logspace(<span class="dv">1</span>, np.log10(pieces.<span class="bu">max</span>()))</span>
<span id="cb37-2"><a href="#cb37-2" aria-hidden="true" tabindex="-1"></a>pp_log_pieces <span class="op">=</span> np.log(pp_pieces)</span>
<span id="cb37-3"><a href="#cb37-3" aria-hidden="true" tabindex="-1"></a>pp_std_log_pieces <span class="op">=</span> scale_log_pieces(pp_log_pieces)</span></code></pre></div>
<div class="sourceCode" id="cb38"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb38-1"><a href="#cb38-1" aria-hidden="true" tabindex="-1"></a>std_log_pieces_.set_value(pp_std_log_pieces)</span></code></pre></div>
<div class="sourceCode" id="cb39"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb39-1"><a href="#cb39-1" aria-hidden="true" tabindex="-1"></a><span class="cf">with</span> pooled_model:</span>
<span id="cb39-2"><a href="#cb39-2" aria-hidden="true" tabindex="-1"></a>    pooled_pp_trace <span class="op">=</span> pm.sample_posterior_predictive(pooled_trace)</span></code></pre></div>
<div>
<style>
/* Turns off some styling */
progress {
/* gets rid of default border in Firefox and Opera. */
border: none;
/* Needs to be in here for Safari polyfill so background images work as expected. */
background-size: auto;
}
.progress-bar-interrupted, .progress-bar-interrupted::-webkit-progress-bar {
background: #F44336;
}
</style>
<progress value="3000" class max="3000" style="width:300px; height:20px; vertical-align: middle;">
</progress>
<p>100.00% [3000/3000 00:01&lt;00:00]</p>
</div>
<div class="sourceCode" id="cb40"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb40-1"><a href="#cb40-1" aria-hidden="true" tabindex="-1"></a>ax <span class="op">=</span> sns.scatterplot(x<span class="op">=</span><span class="st">&quot;Pieces&quot;</span>, y<span class="op">=</span><span class="st">&quot;RRP2021&quot;</span>, data<span class="op">=</span>df,</span>
<span id="cb40-2"><a href="#cb40-2" aria-hidden="true" tabindex="-1"></a>                alpha<span class="op">=</span><span class="fl">0.05</span>)<span class="op">;</span></span>
<span id="cb40-3"><a href="#cb40-3" aria-hidden="true" tabindex="-1"></a>sns.scatterplot(x<span class="op">=</span><span class="st">&quot;Pieces&quot;</span>, y<span class="op">=</span><span class="st">&quot;RRP2021&quot;</span>,</span>
<span id="cb40-4"><a href="#cb40-4" aria-hidden="true" tabindex="-1"></a>                data<span class="op">=</span>df[df[<span class="st">&quot;austin&quot;</span>] <span class="op">==</span> <span class="va">True</span>],</span>
<span id="cb40-5"><a href="#cb40-5" aria-hidden="true" tabindex="-1"></a>                alpha<span class="op">=</span><span class="fl">0.5</span>, label<span class="op">=</span><span class="st">&quot;My sets&quot;</span>,</span>
<span id="cb40-6"><a href="#cb40-6" aria-hidden="true" tabindex="-1"></a>                ax<span class="op">=</span>ax)<span class="op">;</span></span>
<span id="cb40-7"><a href="#cb40-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-8"><a href="#cb40-8" aria-hidden="true" tabindex="-1"></a>pp_low, pp_high <span class="op">=</span> np.percentile(</span>
<span id="cb40-9"><a href="#cb40-9" aria-hidden="true" tabindex="-1"></a>    np.exp(pooled_pp_trace[<span class="st">&quot;obs&quot;</span>]),</span>
<span id="cb40-10"><a href="#cb40-10" aria-hidden="true" tabindex="-1"></a>    [<span class="fl">2.5</span>, <span class="fl">97.4</span>],</span>
<span id="cb40-11"><a href="#cb40-11" aria-hidden="true" tabindex="-1"></a>    axis<span class="op">=</span><span class="dv">0</span></span>
<span id="cb40-12"><a href="#cb40-12" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb40-13"><a href="#cb40-13" aria-hidden="true" tabindex="-1"></a>ax.plot(pp_pieces, np.exp(pooled_pp_trace[<span class="st">&quot;obs&quot;</span>]).mean(axis<span class="op">=</span><span class="dv">0</span>),</span>
<span id="cb40-14"><a href="#cb40-14" aria-hidden="true" tabindex="-1"></a>        c<span class="op">=</span><span class="st">&#39;k&#39;</span>, label<span class="op">=</span><span class="st">&quot;Posterior predicted mean&quot;</span>)<span class="op">;</span></span>
<span id="cb40-15"><a href="#cb40-15" aria-hidden="true" tabindex="-1"></a>ax.fill_between(pp_pieces, pp_low, pp_high,</span>
<span id="cb40-16"><a href="#cb40-16" aria-hidden="true" tabindex="-1"></a>                color<span class="op">=</span><span class="st">&#39;k&#39;</span>, alpha<span class="op">=</span><span class="fl">0.15</span>, zorder<span class="op">=-</span><span class="dv">1</span>,</span>
<span id="cb40-17"><a href="#cb40-17" aria-hidden="true" tabindex="-1"></a>                label<span class="op">=</span><span class="st">&quot;95% posterior interval&quot;</span>)<span class="op">;</span></span>
<span id="cb40-18"><a href="#cb40-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-19"><a href="#cb40-19" aria-hidden="true" tabindex="-1"></a>ax.set_xscale(<span class="st">&#39;log&#39;</span>)<span class="op">;</span></span>
<span id="cb40-20"><a href="#cb40-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-21"><a href="#cb40-21" aria-hidden="true" tabindex="-1"></a>ax.set_yscale(<span class="st">&#39;log&#39;</span>)<span class="op">;</span></span>
<span id="cb40-22"><a href="#cb40-22" aria-hidden="true" tabindex="-1"></a>ax.set_ylabel(<span class="st">&quot;Retail price (2021 $)&quot;</span>)<span class="op">;</span></span>
<span id="cb40-23"><a href="#cb40-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-24"><a href="#cb40-24" aria-hidden="true" tabindex="-1"></a>ax.legend(loc<span class="op">=</span><span class="st">&#39;upper left&#39;</span>)<span class="op">;</span></span></code></pre></div>
<center>
<img src="/resources/lego_pymc3_files/lego_pymc3_53_0.png" title="fig:" alt="png" />
</center>
<p>The predictions seem reasonable. We now plot the posterior distribution of the regression coefficients.</p>
<div class="sourceCode" id="cb41"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb41-1"><a href="#cb41-1" aria-hidden="true" tabindex="-1"></a>az.plot_posterior(pooled_trace, var_names<span class="op">=</span>[<span class="st">&quot;β0&quot;</span>, <span class="st">&quot;β_pieces&quot;</span>])<span class="op">;</span></span></code></pre></div>
<center>
<img src="/resources/lego_pymc3_files/lego_pymc3_55_0.png" title="fig:" alt="png" />
</center>
<p>When we break down the residuals for a few notable themes, we see that Star Wars and Disney sets have larger residuals than Creator sets with the corresponding number of pieces.</p>
<div class="sourceCode" id="cb42"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb42-1"><a href="#cb42-1" aria-hidden="true" tabindex="-1"></a>ax <span class="op">=</span> sns.scatterplot(x<span class="op">=</span><span class="st">&quot;Pieces&quot;</span>, y<span class="op">=</span><span class="st">&quot;pooled_resid&quot;</span>, data<span class="op">=</span>df,</span>
<span id="cb42-2"><a href="#cb42-2" aria-hidden="true" tabindex="-1"></a>                     alpha<span class="op">=</span><span class="fl">0.1</span>)</span>
<span id="cb42-3"><a href="#cb42-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-4"><a href="#cb42-4" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> theme <span class="kw">in</span> [<span class="st">&quot;Star Wars&quot;</span>, <span class="st">&quot;Creator&quot;</span>, <span class="st">&quot;Disney&quot;</span>]:</span>
<span id="cb42-5"><a href="#cb42-5" aria-hidden="true" tabindex="-1"></a>    sns.scatterplot(x<span class="op">=</span><span class="st">&quot;Pieces&quot;</span>, y<span class="op">=</span><span class="st">&quot;pooled_resid&quot;</span>,</span>
<span id="cb42-6"><a href="#cb42-6" aria-hidden="true" tabindex="-1"></a>                    data<span class="op">=</span>df[df[<span class="st">&quot;Theme&quot;</span>] <span class="op">==</span> theme],</span>
<span id="cb42-7"><a href="#cb42-7" aria-hidden="true" tabindex="-1"></a>                    alpha<span class="op">=</span><span class="fl">0.5</span>, label<span class="op">=</span><span class="ss">f&quot;</span><span class="sc">{</span>theme<span class="sc">}</span><span class="ss"> sets&quot;</span>,</span>
<span id="cb42-8"><a href="#cb42-8" aria-hidden="true" tabindex="-1"></a>                    ax<span class="op">=</span>ax)<span class="op">;</span></span>
<span id="cb42-9"><a href="#cb42-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-10"><a href="#cb42-10" aria-hidden="true" tabindex="-1"></a>ax.set_xscale(<span class="st">&#39;log&#39;</span>)<span class="op">;</span></span>
<span id="cb42-11"><a href="#cb42-11" aria-hidden="true" tabindex="-1"></a>ax.set_xlabel(<span class="st">&quot;Pieces&quot;</span>)<span class="op">;</span></span>
<span id="cb42-12"><a href="#cb42-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-13"><a href="#cb42-13" aria-hidden="true" tabindex="-1"></a>ax.set_ylabel(<span class="st">&quot;Log RRP residual (2021 $)&quot;</span>)<span class="op">;</span></span>
<span id="cb42-14"><a href="#cb42-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-15"><a href="#cb42-15" aria-hidden="true" tabindex="-1"></a>ax.set_title(<span class="st">&quot;Pooled model&quot;</span>)<span class="op">;</span></span></code></pre></div>
<center>
<img src="/resources/lego_pymc3_files/lego_pymc3_57_0.png" title="fig:" alt="png" />
</center>
<p>This difference in the distribution of residuals across themes suggests that we introduce theme-specific factors into our model.</p>
<h3 id="unpooled-model">Unpooled model</h3>
<p>In order to introduce theme-specific factors, we create indicator variables for each theme.</p>
<div class="sourceCode" id="cb43"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb43-1"><a href="#cb43-1" aria-hidden="true" tabindex="-1"></a>theme_id, theme_map <span class="op">=</span> df[<span class="st">&quot;Theme&quot;</span>].factorize(sort<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb43-2"><a href="#cb43-2" aria-hidden="true" tabindex="-1"></a>n_theme <span class="op">=</span> theme_map.size</span>
<span id="cb43-3"><a href="#cb43-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb43-4"><a href="#cb43-4" aria-hidden="true" tabindex="-1"></a>theme_id_ <span class="op">=</span> shared(theme_id)</span></code></pre></div>
<p>The simplest model that includes theme-specific factors is an unpooled model that consists of independent regressions per theme. With <span class="math inline">\(j(i)\)</span> denoting the index of the theme of the <span class="math inline">\(i\)</span>-th set, we have the model</p>
<p><span class="math display">\[\log\left(f_i(X_i)\right) = \beta_{0, j(i)} + \beta_{j(i)} \tilde{x}_i\]</span></p>
<p>with the <a href="https://en.wikipedia.org/wiki/Independent_and_identically_distributed_random_variables">i.i.d.</a> priors</p>
<p><span class="math display">\[
\begin{align*}
    \beta_{0, 1}, \ldots \beta_{0, n_j}
        &amp; \sim N(0, 2.5^2) \\
    \beta_1, \ldots \beta_{n_j}
        &amp; \sim N(0, 2.5^2) \\
    \sigma_1, \ldots, \sigma_{n_j}
        &amp; \sim \textrm{HalfNormal}(5^2).
\end{align*}
\]</span></p>
<div class="sourceCode" id="cb44"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb44-1"><a href="#cb44-1" aria-hidden="true" tabindex="-1"></a>std_log_pieces_.set_value(std_log_pieces)</span></code></pre></div>
<div class="sourceCode" id="cb45"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb45-1"><a href="#cb45-1" aria-hidden="true" tabindex="-1"></a><span class="cf">with</span> pm.Model() <span class="im">as</span> unpooled_model:</span>
<span id="cb45-2"><a href="#cb45-2" aria-hidden="true" tabindex="-1"></a>    β<span class="dv">0</span> <span class="op">=</span> pm.Normal(<span class="st">&quot;β0&quot;</span>, <span class="fl">0.</span>, <span class="fl">2.5</span>, shape<span class="op">=</span>n_theme)</span>
<span id="cb45-3"><a href="#cb45-3" aria-hidden="true" tabindex="-1"></a>    β_pieces <span class="op">=</span> pm.Normal(<span class="st">&quot;β_pieces&quot;</span>, <span class="fl">0.</span>, <span class="fl">2.5</span>, shape<span class="op">=</span>n_theme)</span>
<span id="cb45-4"><a href="#cb45-4" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb45-5"><a href="#cb45-5" aria-hidden="true" tabindex="-1"></a>    σ <span class="op">=</span> pm.HalfNormal(<span class="st">&quot;σ&quot;</span>, <span class="fl">5.</span>, shape<span class="op">=</span>n_theme)</span>
<span id="cb45-6"><a href="#cb45-6" aria-hidden="true" tabindex="-1"></a>    μ <span class="op">=</span> β<span class="dv">0</span>[theme_id_] <span class="op">+</span> β_pieces[theme_id_] <span class="op">*</span> std_log_pieces_ <span class="op">\</span></span>
<span id="cb45-7"><a href="#cb45-7" aria-hidden="true" tabindex="-1"></a>            <span class="op">-</span> <span class="fl">0.5</span> <span class="op">*</span> σ[theme_id_]<span class="op">**</span><span class="dv">2</span></span>
<span id="cb45-8"><a href="#cb45-8" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb45-9"><a href="#cb45-9" aria-hidden="true" tabindex="-1"></a>    obs <span class="op">=</span> pm.Normal(<span class="st">&quot;obs&quot;</span>, μ, σ[theme_id_], observed<span class="op">=</span>log_rrp2021)</span></code></pre></div>
<p>We don’t actually sample from this model because it is underdetermined for many themes that have few sets associated with them, as the following plot shows.</p>
<div class="sourceCode" id="cb46"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb46-1"><a href="#cb46-1" aria-hidden="true" tabindex="-1"></a>ax <span class="op">=</span> (df[<span class="st">&quot;Theme&quot;</span>]</span>
<span id="cb46-2"><a href="#cb46-2" aria-hidden="true" tabindex="-1"></a>        .value_counts()</span>
<span id="cb46-3"><a href="#cb46-3" aria-hidden="true" tabindex="-1"></a>        .nsmallest(n<span class="op">=</span><span class="dv">20</span>)</span>
<span id="cb46-4"><a href="#cb46-4" aria-hidden="true" tabindex="-1"></a>        .plot.barh())</span>
<span id="cb46-5"><a href="#cb46-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb46-6"><a href="#cb46-6" aria-hidden="true" tabindex="-1"></a>ax.set_xlabel(<span class="st">&quot;Number of sets&quot;</span>)<span class="op">;</span></span>
<span id="cb46-7"><a href="#cb46-7" aria-hidden="true" tabindex="-1"></a>ax.set_ylabel(<span class="st">&quot;Theme&quot;</span>)<span class="op">;</span></span></code></pre></div>
<center>
<img src="/resources/lego_pymc3_files/lego_pymc3_65_0.png" title="fig:" alt="png" />
</center>
<p>There are five themes with only a single set, and a number of themes with fewer than five sets total. Regression models with only a single data point are underdetermined, and those with few observations are likely to have wide error bars. Instead of imposing a minimum number of sets per theme and then using an unpooled model, we will use a partially pooled model to share some information across themes/regularize while allowing themes with many sets to deviate from the average if the data indicate that they should.</p>
<h3 id="partially-pooled-model">Partially pooled model</h3>
<p>One model that shares information across themes is called “partially pooled” (it may also be called multilevel or hierarchical). In the partially pooled model, the intercept and piece coefficient for each theme are drawn not from i.i.d normal distributions but from a normal distribution with a common mean and variance. This shared hyperprior distribution regularizes the theme intercepts and coefficients, shrinking those for themes with fewer sets towards the pooled values.</p>
<p>Conceptually, we use the priors</p>
<p><span class="math display">\[
\begin{align*}
    \mu_{\beta_0}
        &amp; \sim N(0, 2.5^2) \\
    \sigma_{\beta_0}
        &amp; \sim \textrm{HalfNormal}(2.5^2) \\
    \beta_{0, 1}, \ldots, \beta_{0, n_j}
        &amp; \sim N\left(\mu_{\beta_0}, \sigma_{\beta_0}^2\right)
\end{align*}
\]</span></p>
<p>and similarly for <span class="math inline">\(\beta\)</span>. In reality, we use a <a href="https://twiecki.io/blog/2017/02/08/bayesian-hierchical-non-centered/">non-centered parametrization</a> parameterization that is mathematically equivalent but often more computationally efficient.</p>
<div class="sourceCode" id="cb47"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb47-1"><a href="#cb47-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> hierarchical_normal(name, shape, μ<span class="op">=</span><span class="va">None</span>):</span>
<span id="cb47-2"><a href="#cb47-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> μ <span class="kw">is</span> <span class="va">None</span>:</span>
<span id="cb47-3"><a href="#cb47-3" aria-hidden="true" tabindex="-1"></a>        μ <span class="op">=</span> pm.Normal(<span class="ss">f&quot;μ_</span><span class="sc">{</span>name<span class="sc">}</span><span class="ss">&quot;</span>, <span class="fl">0.</span>, <span class="fl">2.5</span>)</span>
<span id="cb47-4"><a href="#cb47-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb47-5"><a href="#cb47-5" aria-hidden="true" tabindex="-1"></a>    Δ <span class="op">=</span> pm.Normal(<span class="ss">f&quot;Δ_</span><span class="sc">{</span>name<span class="sc">}</span><span class="ss">&quot;</span>, <span class="fl">0.</span>, <span class="fl">1.</span>, shape<span class="op">=</span>shape)</span>
<span id="cb47-6"><a href="#cb47-6" aria-hidden="true" tabindex="-1"></a>    σ <span class="op">=</span> pm.HalfNormal(<span class="ss">f&quot;σ_</span><span class="sc">{</span>name<span class="sc">}</span><span class="ss">&quot;</span>, <span class="fl">2.5</span>)</span>
<span id="cb47-7"><a href="#cb47-7" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb47-8"><a href="#cb47-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> pm.Deterministic(name, μ <span class="op">+</span> Δ <span class="op">*</span> σ)</span></code></pre></div>
<div class="sourceCode" id="cb48"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb48-1"><a href="#cb48-1" aria-hidden="true" tabindex="-1"></a><span class="cf">with</span> pm.Model() <span class="im">as</span> partial_model:</span>
<span id="cb48-2"><a href="#cb48-2" aria-hidden="true" tabindex="-1"></a>    β<span class="dv">0</span> <span class="op">=</span> hierarchical_normal(<span class="st">&quot;β0&quot;</span>, n_theme)</span>
<span id="cb48-3"><a href="#cb48-3" aria-hidden="true" tabindex="-1"></a>    β_pieces <span class="op">=</span> hierarchical_normal(<span class="st">&quot;β_pieces&quot;</span>, n_theme)</span>
<span id="cb48-4"><a href="#cb48-4" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb48-5"><a href="#cb48-5" aria-hidden="true" tabindex="-1"></a>    σ <span class="op">=</span> pm.HalfNormal(<span class="st">&quot;σ&quot;</span>, <span class="fl">5.</span>)</span>
<span id="cb48-6"><a href="#cb48-6" aria-hidden="true" tabindex="-1"></a>    μ <span class="op">=</span> β<span class="dv">0</span>[theme_id_] <span class="op">+</span> β_pieces[theme_id_] <span class="op">*</span> std_log_pieces_ <span class="op">\</span></span>
<span id="cb48-7"><a href="#cb48-7" aria-hidden="true" tabindex="-1"></a>            <span class="op">-</span> <span class="fl">0.5</span> <span class="op">*</span> σ<span class="op">**</span><span class="dv">2</span></span>
<span id="cb48-8"><a href="#cb48-8" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb48-9"><a href="#cb48-9" aria-hidden="true" tabindex="-1"></a>    obs <span class="op">=</span> pm.Normal(<span class="st">&quot;obs&quot;</span>, μ, σ, observed<span class="op">=</span>log_rrp2021)</span></code></pre></div>
<div class="sourceCode" id="cb49"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb49-1"><a href="#cb49-1" aria-hidden="true" tabindex="-1"></a><span class="cf">with</span> partial_model:</span>
<span id="cb49-2"><a href="#cb49-2" aria-hidden="true" tabindex="-1"></a>    partial_trace <span class="op">=</span> pm.sample(<span class="op">**</span>SAMPLE_KWARGS)</span></code></pre></div>
<pre><code>Auto-assigning NUTS sampler...
Initializing NUTS using jitter+adapt_diag...
Multiprocess sampling (3 chains in 3 jobs)
NUTS: [μ_β0, Δ_β0, σ_β0, μ_β_pieces, Δ_β_pieces, σ_β_pieces, σ]</code></pre>
<div>
<style>
/* Turns off some styling */
progress {
/* gets rid of default border in Firefox and Opera. */
border: none;
/* Needs to be in here for Safari polyfill so background images work as expected. */
background-size: auto;
}
.progress-bar-interrupted, .progress-bar-interrupted::-webkit-progress-bar {
background: #F44336;
}
</style>
<progress value="6000" class max="6000" style="width:300px; height:20px; vertical-align: middle;">
</progress>
<p>100.00% [6000/6000 03:15&lt;00:00 Sampling 3 chains, 0 divergences]</p>
</div>
<pre><code>Sampling 3 chains for 1_000 tune and 1_000 draw iterations (3_000 + 3_000 draws total) took 196 seconds.
The estimated number of effective samples is smaller than 200 for some parameters.</code></pre>
<p>Again our diagnostics show no cause for concern.</p>
<div class="sourceCode" id="cb52"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb52-1"><a href="#cb52-1" aria-hidden="true" tabindex="-1"></a>make_diagnostic_plots(partial_trace)<span class="op">;</span></span></code></pre></div>
<center>
<img src="/resources/lego_pymc3_files/lego_pymc3_72_0.png" title="fig:" alt="png" />
</center>
<p>After calculating the residuals for the partially pooled model we see that they tend to be closer to zero and the diagonal bands are less pronounced.</p>
<div class="sourceCode" id="cb53"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb53-1"><a href="#cb53-1" aria-hidden="true" tabindex="-1"></a><span class="cf">with</span> partial_model:</span>
<span id="cb53-2"><a href="#cb53-2" aria-hidden="true" tabindex="-1"></a>    pp_trace_data <span class="op">=</span> pm.sample_posterior_predictive(partial_trace)</span>
<span id="cb53-3"><a href="#cb53-3" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb53-4"><a href="#cb53-4" aria-hidden="true" tabindex="-1"></a>df[<span class="st">&quot;partial_resid&quot;</span>] <span class="op">=</span> (log_rrp2021 <span class="op">-</span> pp_trace_data[<span class="st">&quot;obs&quot;</span>]).mean(axis<span class="op">=</span><span class="dv">0</span>)</span></code></pre></div>
<div>
<style>
/* Turns off some styling */
progress {
/* gets rid of default border in Firefox and Opera. */
border: none;
/* Needs to be in here for Safari polyfill so background images work as expected. */
background-size: auto;
}
.progress-bar-interrupted, .progress-bar-interrupted::-webkit-progress-bar {
background: #F44336;
}
</style>
<progress value="3000" class max="3000" style="width:300px; height:20px; vertical-align: middle;">
</progress>
<p>100.00% [3000/3000 00:02&lt;00:00]</p>
</div>
<div class="sourceCode" id="cb54"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb54-1"><a href="#cb54-1" aria-hidden="true" tabindex="-1"></a>fig, axes <span class="op">=</span> plt.subplots(ncols<span class="op">=</span><span class="dv">2</span>, sharex<span class="op">=</span><span class="va">True</span>, sharey<span class="op">=</span><span class="va">True</span>,</span>
<span id="cb54-2"><a href="#cb54-2" aria-hidden="true" tabindex="-1"></a>                         figsize<span class="op">=</span>(<span class="dv">14</span>, <span class="dv">6</span>))</span>
<span id="cb54-3"><a href="#cb54-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-4"><a href="#cb54-4" aria-hidden="true" tabindex="-1"></a>sns.scatterplot(x<span class="op">=</span><span class="st">&quot;Pieces&quot;</span>, y<span class="op">=</span><span class="st">&quot;pooled_resid&quot;</span>, data<span class="op">=</span>df,</span>
<span id="cb54-5"><a href="#cb54-5" aria-hidden="true" tabindex="-1"></a>                alpha<span class="op">=</span><span class="fl">0.1</span>, ax<span class="op">=</span>axes[<span class="dv">0</span>])<span class="op">;</span></span>
<span id="cb54-6"><a href="#cb54-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-7"><a href="#cb54-7" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>].set_xscale(<span class="st">&#39;log&#39;</span>)<span class="op">;</span></span>
<span id="cb54-8"><a href="#cb54-8" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>].set_xlabel(<span class="st">&quot;Pieces&quot;</span>)<span class="op">;</span></span>
<span id="cb54-9"><a href="#cb54-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-10"><a href="#cb54-10" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>].set_ylabel(<span class="st">&quot;Log RRP residual (2021 $)&quot;</span>)<span class="op">;</span></span>
<span id="cb54-11"><a href="#cb54-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-12"><a href="#cb54-12" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>].set_title(<span class="st">&quot;Pooled model&quot;</span>)<span class="op">;</span></span>
<span id="cb54-13"><a href="#cb54-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-14"><a href="#cb54-14" aria-hidden="true" tabindex="-1"></a>sns.scatterplot(x<span class="op">=</span><span class="st">&quot;Pieces&quot;</span>, y<span class="op">=</span><span class="st">&quot;partial_resid&quot;</span>, data<span class="op">=</span>df,</span>
<span id="cb54-15"><a href="#cb54-15" aria-hidden="true" tabindex="-1"></a>                alpha<span class="op">=</span><span class="fl">0.1</span>, ax<span class="op">=</span>axes[<span class="dv">1</span>])<span class="op">;</span></span>
<span id="cb54-16"><a href="#cb54-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-17"><a href="#cb54-17" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>].set_xscale(<span class="st">&#39;log&#39;</span>)<span class="op">;</span></span>
<span id="cb54-18"><a href="#cb54-18" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>].set_xlabel(<span class="st">&quot;Pieces&quot;</span>)<span class="op">;</span></span>
<span id="cb54-19"><a href="#cb54-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-20"><a href="#cb54-20" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>].set_ylabel(<span class="st">&quot;Log RRP residual (2021 $)&quot;</span>)<span class="op">;</span></span>
<span id="cb54-21"><a href="#cb54-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-22"><a href="#cb54-22" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>].set_title(<span class="st">&quot;Partially pooled model&quot;</span>)<span class="op">;</span></span>
<span id="cb54-23"><a href="#cb54-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-24"><a href="#cb54-24" aria-hidden="true" tabindex="-1"></a>fig.tight_layout()<span class="op">;</span></span></code></pre></div>
<center>
<img src="/resources/lego_pymc3_files/lego_pymc3_75_0.png" title="fig:" alt="png" />
</center>
<p>We also see that the residuals for the example themes (Star Wars, Creator, and Disney) are more comingled than for the pooled model.</p>
<div class="sourceCode" id="cb55"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb55-1"><a href="#cb55-1" aria-hidden="true" tabindex="-1"></a>fig, axes <span class="op">=</span> plt.subplots(ncols<span class="op">=</span><span class="dv">2</span>, sharex<span class="op">=</span><span class="va">True</span>, sharey<span class="op">=</span><span class="va">True</span>,</span>
<span id="cb55-2"><a href="#cb55-2" aria-hidden="true" tabindex="-1"></a>                         figsize<span class="op">=</span>(<span class="dv">14</span>, <span class="dv">6</span>))</span>
<span id="cb55-3"><a href="#cb55-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb55-4"><a href="#cb55-4" aria-hidden="true" tabindex="-1"></a>sns.scatterplot(x<span class="op">=</span><span class="st">&quot;Pieces&quot;</span>, y<span class="op">=</span><span class="st">&quot;pooled_resid&quot;</span>, data<span class="op">=</span>df,</span>
<span id="cb55-5"><a href="#cb55-5" aria-hidden="true" tabindex="-1"></a>                alpha<span class="op">=</span><span class="fl">0.1</span>, ax<span class="op">=</span>axes[<span class="dv">0</span>])<span class="op">;</span></span>
<span id="cb55-6"><a href="#cb55-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb55-7"><a href="#cb55-7" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> theme <span class="kw">in</span> [<span class="st">&quot;Star Wars&quot;</span>, <span class="st">&quot;Creator&quot;</span>, <span class="st">&quot;Disney&quot;</span>]:</span>
<span id="cb55-8"><a href="#cb55-8" aria-hidden="true" tabindex="-1"></a>    sns.scatterplot(x<span class="op">=</span><span class="st">&quot;Pieces&quot;</span>, y<span class="op">=</span><span class="st">&quot;pooled_resid&quot;</span>,</span>
<span id="cb55-9"><a href="#cb55-9" aria-hidden="true" tabindex="-1"></a>                    data<span class="op">=</span>df[df[<span class="st">&quot;Theme&quot;</span>] <span class="op">==</span> theme],</span>
<span id="cb55-10"><a href="#cb55-10" aria-hidden="true" tabindex="-1"></a>                    alpha<span class="op">=</span><span class="fl">0.5</span>, label<span class="op">=</span><span class="ss">f&quot;</span><span class="sc">{</span>theme<span class="sc">}</span><span class="ss"> sets&quot;</span>,</span>
<span id="cb55-11"><a href="#cb55-11" aria-hidden="true" tabindex="-1"></a>                    ax<span class="op">=</span>axes[<span class="dv">0</span>])<span class="op">;</span></span>
<span id="cb55-12"><a href="#cb55-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb55-13"><a href="#cb55-13" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>].set_xscale(<span class="st">&#39;log&#39;</span>)<span class="op">;</span></span>
<span id="cb55-14"><a href="#cb55-14" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>].set_xlabel(<span class="st">&quot;Pieces&quot;</span>)<span class="op">;</span></span>
<span id="cb55-15"><a href="#cb55-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb55-16"><a href="#cb55-16" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>].set_ylabel(<span class="st">&quot;Log RRP residual (2021 $)&quot;</span>)<span class="op">;</span></span>
<span id="cb55-17"><a href="#cb55-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb55-18"><a href="#cb55-18" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>].set_title(<span class="st">&quot;Pooled model&quot;</span>)<span class="op">;</span></span>
<span id="cb55-19"><a href="#cb55-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb55-20"><a href="#cb55-20" aria-hidden="true" tabindex="-1"></a>sns.scatterplot(x<span class="op">=</span><span class="st">&quot;Pieces&quot;</span>, y<span class="op">=</span><span class="st">&quot;partial_resid&quot;</span>, data<span class="op">=</span>df,</span>
<span id="cb55-21"><a href="#cb55-21" aria-hidden="true" tabindex="-1"></a>                alpha<span class="op">=</span><span class="fl">0.1</span>, ax<span class="op">=</span>axes[<span class="dv">1</span>])<span class="op">;</span></span>
<span id="cb55-22"><a href="#cb55-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb55-23"><a href="#cb55-23" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> theme <span class="kw">in</span> [<span class="st">&quot;Star Wars&quot;</span>, <span class="st">&quot;Creator&quot;</span>, <span class="st">&quot;Disney&quot;</span>]:</span>
<span id="cb55-24"><a href="#cb55-24" aria-hidden="true" tabindex="-1"></a>    sns.scatterplot(x<span class="op">=</span><span class="st">&quot;Pieces&quot;</span>, y<span class="op">=</span><span class="st">&quot;partial_resid&quot;</span>,</span>
<span id="cb55-25"><a href="#cb55-25" aria-hidden="true" tabindex="-1"></a>                    data<span class="op">=</span>df[df[<span class="st">&quot;Theme&quot;</span>] <span class="op">==</span> theme],</span>
<span id="cb55-26"><a href="#cb55-26" aria-hidden="true" tabindex="-1"></a>                    alpha<span class="op">=</span><span class="fl">0.5</span>, label<span class="op">=</span><span class="ss">f&quot;</span><span class="sc">{</span>theme<span class="sc">}</span><span class="ss"> sets&quot;</span>,</span>
<span id="cb55-27"><a href="#cb55-27" aria-hidden="true" tabindex="-1"></a>                    ax<span class="op">=</span>axes[<span class="dv">1</span>])<span class="op">;</span></span>
<span id="cb55-28"><a href="#cb55-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb55-29"><a href="#cb55-29" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>].set_xscale(<span class="st">&#39;log&#39;</span>)<span class="op">;</span></span>
<span id="cb55-30"><a href="#cb55-30" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>].set_xlabel(<span class="st">&quot;Pieces&quot;</span>)<span class="op">;</span></span>
<span id="cb55-31"><a href="#cb55-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb55-32"><a href="#cb55-32" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>].set_ylabel(<span class="st">&quot;Log RRP residual (2021 $)&quot;</span>)<span class="op">;</span></span>
<span id="cb55-33"><a href="#cb55-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb55-34"><a href="#cb55-34" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>].set_title(<span class="st">&quot;Partially pooloed model&quot;</span>)<span class="op">;</span></span>
<span id="cb55-35"><a href="#cb55-35" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb55-36"><a href="#cb55-36" aria-hidden="true" tabindex="-1"></a>fig.tight_layout()<span class="op">;</span></span></code></pre></div>
<center>
<img src="/resources/lego_pymc3_files/lego_pymc3_77_0.png" title="fig:" alt="png" />
</center>
<p>Now that we have posterior samples from two models, we use Pareto-smoothed importance sampling leave-one-out cross validation<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a></p>
<div class="sourceCode" id="cb56"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb56-1"><a href="#cb56-1" aria-hidden="true" tabindex="-1"></a>traces <span class="op">=</span> {</span>
<span id="cb56-2"><a href="#cb56-2" aria-hidden="true" tabindex="-1"></a>    <span class="st">&quot;Unpooled&quot;</span>: pooled_trace,</span>
<span id="cb56-3"><a href="#cb56-3" aria-hidden="true" tabindex="-1"></a>    <span class="st">&quot;Partially pooled&quot;</span>: partial_trace</span>
<span id="cb56-4"><a href="#cb56-4" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<div class="sourceCode" id="cb57"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb57-1"><a href="#cb57-1" aria-hidden="true" tabindex="-1"></a>comp_df <span class="op">=</span> az.compare(traces)</span></code></pre></div>
<div class="sourceCode" id="cb58"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb58-1"><a href="#cb58-1" aria-hidden="true" tabindex="-1"></a>comp_df.loc[:, :<span class="st">&quot;weight&quot;</span>]</span></code></pre></div>
<center>
<div>
<style scoped>
.dataframe tbody tr th:only-of-type {
vertical-align: middle;
}

.dataframe tbody tr th {
vertical-align: top;
}

.dataframe thead th {
text-align: right;
}
</style>
<table border="1" class="dataframe">
<thead>
<tr style="text-align: right;">
<th>
</th>
<th>
rank
</th>
<th>
loo
</th>
<th>
p_loo
</th>
<th>
d_loo
</th>
<th>
weight
</th>
</tr>
</thead>
<tbody>
<tr>
<th>
Partially pooled
</th>
<td>
0
</td>
<td>
-2315.578245
</td>
<td>
190.594364
</td>
<td>
0.000000
</td>
<td>
0.99951
</td>
</tr>
<tr>
<th>
Unpooled
</th>
<td>
1
</td>
<td>
-5133.311893
</td>
<td>
4.871287
</td>
<td>
2817.733648
</td>
<td>
0.00049
</td>
</tr>
</tbody>
</table>
</div>
</center>
<p><br></p>
<div class="sourceCode" id="cb59"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb59-1"><a href="#cb59-1" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots(figsize<span class="op">=</span>(<span class="dv">12</span>, <span class="dv">6</span>))</span>
<span id="cb59-2"><a href="#cb59-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb59-3"><a href="#cb59-3" aria-hidden="true" tabindex="-1"></a>az.plot_compare(comp_df, plot_ic_diff<span class="op">=</span><span class="va">False</span>, ax<span class="op">=</span>ax)<span class="op">;</span></span></code></pre></div>
<center>
<img src="/resources/lego_pymc3_files/lego_pymc3_82_0.png" title="fig:" alt="png" />
</center>
<p>The table and chart show that by sharing some information across themes while also incorporating their varying effects the partially pooled model has substantially better predictive accuracy than the pooled model (higher values of <code>loo</code> correspond to better predictive ability).</p>
<p>In order to compare the posterior predictions of the pooled and partially pooled model directly, we need to define a grid over theme/standardized log piece combinations.</p>
<div class="sourceCode" id="cb60"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb60-1"><a href="#cb60-1" aria-hidden="true" tabindex="-1"></a>pp_df <span class="op">=</span> pd.DataFrame.from_records(</span>
<span id="cb60-2"><a href="#cb60-2" aria-hidden="true" tabindex="-1"></a>    itl.product(<span class="bu">range</span>(n_theme), pp_std_log_pieces),</span>
<span id="cb60-3"><a href="#cb60-3" aria-hidden="true" tabindex="-1"></a>    columns<span class="op">=</span>[<span class="st">&quot;theme_id&quot;</span>, <span class="st">&quot;std_log_pieces&quot;</span>]</span>
<span id="cb60-4"><a href="#cb60-4" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb60-5"><a href="#cb60-5" aria-hidden="true" tabindex="-1"></a>pp_df[<span class="st">&quot;theme&quot;</span>] <span class="op">=</span> theme_map[pp_df[<span class="st">&quot;theme_id&quot;</span>].values]</span>
<span id="cb60-6"><a href="#cb60-6" aria-hidden="true" tabindex="-1"></a>pp_df[<span class="st">&quot;pieces&quot;</span>] <span class="op">=</span> np.exp(</span>
<span id="cb60-7"><a href="#cb60-7" aria-hidden="true" tabindex="-1"></a>    scaler.inverse_transform(pp_df[<span class="st">&quot;std_log_pieces&quot;</span>]</span>
<span id="cb60-8"><a href="#cb60-8" aria-hidden="true" tabindex="-1"></a>                                  .values[:, np.newaxis])</span>
<span id="cb60-9"><a href="#cb60-9" aria-hidden="true" tabindex="-1"></a>          .ravel()</span>
<span id="cb60-10"><a href="#cb60-10" aria-hidden="true" tabindex="-1"></a>)</span></code></pre></div>
<div class="sourceCode" id="cb61"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb61-1"><a href="#cb61-1" aria-hidden="true" tabindex="-1"></a>pp_df.head()</span></code></pre></div>
<center>
<div>
<style scoped>
.dataframe tbody tr th:only-of-type {
vertical-align: middle;
}

.dataframe tbody tr th {
vertical-align: top;
}

.dataframe thead th {
text-align: right;
}
</style>
<table border="1" class="dataframe">
<thead>
<tr style="text-align: right;">
<th>
</th>
<th>
theme_id
</th>
<th>
std_log_pieces
</th>
<th>
theme
</th>
<th>
pieces
</th>
</tr>
</thead>
<tbody>
<tr>
<th>
0
</th>
<td>
0
</td>
<td>
-2.373432
</td>
<td>
4 Juniors
</td>
<td>
10.000000
</td>
</tr>
<tr>
<th>
1
</th>
<td>
0
</td>
<td>
-2.252260
</td>
<td>
4 Juniors
</td>
<td>
11.550805
</td>
</tr>
<tr>
<th>
2
</th>
<td>
0
</td>
<td>
-2.131088
</td>
<td>
4 Juniors
</td>
<td>
13.342109
</td>
</tr>
<tr>
<th>
3
</th>
<td>
0
</td>
<td>
-2.009916
</td>
<td>
4 Juniors
</td>
<td>
15.411210
</td>
</tr>
<tr>
<th>
4
</th>
<td>
0
</td>
<td>
-1.888744
</td>
<td>
4 Juniors
</td>
<td>
17.801188
</td>
</tr>
</tbody>
</table>
</div>
</center>
<p><br></p>
<div class="sourceCode" id="cb62"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb62-1"><a href="#cb62-1" aria-hidden="true" tabindex="-1"></a>pp_df.tail()</span></code></pre></div>
<center>
<div>
<style scoped>
.dataframe tbody tr th:only-of-type {
vertical-align: middle;
}

.dataframe tbody tr th {
vertical-align: top;
}

.dataframe thead th {
text-align: right;
}
</style>
<table border="1" class="dataframe">
<thead>
<tr style="text-align: right;">
<th>
</th>
<th>
theme_id
</th>
<th>
std_log_pieces
</th>
<th>
theme
</th>
<th>
pieces
</th>
</tr>
</thead>
<tbody>
<tr>
<th>
6545
</th>
<td>
130
</td>
<td>
3.079305
</td>
<td>
Znap
</td>
<td>
6569.786072
</td>
</tr>
<tr>
<th>
6546
</th>
<td>
130
</td>
<td>
3.200477
</td>
<td>
Znap
</td>
<td>
7588.631734
</td>
</tr>
<tr>
<th>
6547
</th>
<td>
130
</td>
<td>
3.321649
</td>
<td>
Znap
</td>
<td>
8765.480484
</td>
</tr>
<tr>
<th>
6548
</th>
<td>
130
</td>
<td>
3.442820
</td>
<td>
Znap
</td>
<td>
10124.835517
</td>
</tr>
<tr>
<th>
6549
</th>
<td>
130
</td>
<td>
3.563992
</td>
<td>
Znap
</td>
<td>
11695.000000
</td>
</tr>
</tbody>
</table>
</div>
</center>
<div class="sourceCode" id="cb63"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb63-1"><a href="#cb63-1" aria-hidden="true" tabindex="-1"></a>std_log_pieces_.set_value(pp_df[<span class="st">&quot;std_log_pieces&quot;</span>].values)</span>
<span id="cb63-2"><a href="#cb63-2" aria-hidden="true" tabindex="-1"></a>theme_id_.set_value(pp_df[<span class="st">&quot;theme_id&quot;</span>].values)</span></code></pre></div>
<p>We now sample from the posterior predictive distribution and compare the predictions to those from the pooled model.</p>
<div class="sourceCode" id="cb64"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb64-1"><a href="#cb64-1" aria-hidden="true" tabindex="-1"></a><span class="cf">with</span> partial_model:</span>
<span id="cb64-2"><a href="#cb64-2" aria-hidden="true" tabindex="-1"></a>    partial_pp_trace <span class="op">=</span> pm.sample_posterior_predictive(partial_trace)</span></code></pre></div>
<div>
<style>
/* Turns off some styling */
progress {
/* gets rid of default border in Firefox and Opera. */
border: none;
/* Needs to be in here for Safari polyfill so background images work as expected. */
background-size: auto;
}
.progress-bar-interrupted, .progress-bar-interrupted::-webkit-progress-bar {
background: #F44336;
}
</style>
<progress value="3000" class max="3000" style="width:300px; height:20px; vertical-align: middle;">
</progress>
<p>100.00% [3000/3000 00:02&lt;00:00]</p>
</div>
<div class="sourceCode" id="cb65"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb65-1"><a href="#cb65-1" aria-hidden="true" tabindex="-1"></a>pp_df[<span class="st">&quot;pp_partial_mean&quot;</span>] <span class="op">=</span> np.exp(partial_pp_trace[<span class="st">&quot;obs&quot;</span>]).mean(axis<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb65-2"><a href="#cb65-2" aria-hidden="true" tabindex="-1"></a>pp_df[<span class="st">&quot;pp_partial_low&quot;</span>], pp_df[<span class="st">&quot;pp_partial_high&quot;</span>] <span class="op">=</span> np.percentile(</span>
<span id="cb65-3"><a href="#cb65-3" aria-hidden="true" tabindex="-1"></a>    np.exp(partial_pp_trace[<span class="st">&quot;obs&quot;</span>]),</span>
<span id="cb65-4"><a href="#cb65-4" aria-hidden="true" tabindex="-1"></a>    [<span class="fl">2.5</span>, <span class="fl">97.5</span>],</span>
<span id="cb65-5"><a href="#cb65-5" aria-hidden="true" tabindex="-1"></a>    axis<span class="op">=</span><span class="dv">0</span></span>
<span id="cb65-6"><a href="#cb65-6" aria-hidden="true" tabindex="-1"></a>)</span></code></pre></div>
<div class="sourceCode" id="cb66"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb66-1"><a href="#cb66-1" aria-hidden="true" tabindex="-1"></a>pp_df.head()</span></code></pre></div>
<center>
<div>
<style scoped>
.dataframe tbody tr th:only-of-type {
vertical-align: middle;
}

.dataframe tbody tr th {
vertical-align: top;
}

.dataframe thead th {
text-align: right;
}
</style>
<table border="1" class="dataframe">
<thead>
<tr style="text-align: right;">
<th>
</th>
<th>
theme_id
</th>
<th>
std_log_pieces
</th>
<th>
theme
</th>
<th>
pieces
</th>
<th>
pp_partial_mean
</th>
<th>
pp_partial_low
</th>
<th>
pp_partial_high
</th>
</tr>
</thead>
<tbody>
<tr>
<th>
0
</th>
<td>
0
</td>
<td>
-2.373432
</td>
<td>
4 Juniors
</td>
<td>
10.000000
</td>
<td>
5.214650
</td>
<td>
2.380664
</td>
<td>
10.484612
</td>
</tr>
<tr>
<th>
1
</th>
<td>
0
</td>
<td>
-2.252260
</td>
<td>
4 Juniors
</td>
<td>
11.550805
</td>
<td>
5.917360
</td>
<td>
2.668467
</td>
<td>
11.413480
</td>
</tr>
<tr>
<th>
2
</th>
<td>
0
</td>
<td>
-2.131088
</td>
<td>
4 Juniors
</td>
<td>
13.342109
</td>
<td>
6.864103
</td>
<td>
3.045283
</td>
<td>
13.610948
</td>
</tr>
<tr>
<th>
3
</th>
<td>
0
</td>
<td>
-2.009916
</td>
<td>
4 Juniors
</td>
<td>
15.411210
</td>
<td>
7.653877
</td>
<td>
3.515344
</td>
<td>
14.966362
</td>
</tr>
<tr>
<th>
4
</th>
<td>
0
</td>
<td>
-1.888744
</td>
<td>
4 Juniors
</td>
<td>
17.801188
</td>
<td>
8.679962
</td>
<td>
4.009006
</td>
<td>
16.935274
</td>
</tr>
</tbody>
</table>
</div>
</center>
<p><br></p>
<div class="sourceCode" id="cb67"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb67-1"><a href="#cb67-1" aria-hidden="true" tabindex="-1"></a>ax <span class="op">=</span> sns.scatterplot(x<span class="op">=</span><span class="st">&quot;Pieces&quot;</span>, y<span class="op">=</span><span class="st">&quot;RRP2021&quot;</span>, data<span class="op">=</span>df,</span>
<span id="cb67-2"><a href="#cb67-2" aria-hidden="true" tabindex="-1"></a>                alpha<span class="op">=</span><span class="fl">0.05</span>)<span class="op">;</span></span>
<span id="cb67-3"><a href="#cb67-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb67-4"><a href="#cb67-4" aria-hidden="true" tabindex="-1"></a>(pp_df.groupby(<span class="st">&quot;theme_id&quot;</span>)</span>
<span id="cb67-5"><a href="#cb67-5" aria-hidden="true" tabindex="-1"></a>      .plot(<span class="st">&quot;pieces&quot;</span>, <span class="st">&quot;pp_partial_mean&quot;</span>,</span>
<span id="cb67-6"><a href="#cb67-6" aria-hidden="true" tabindex="-1"></a>            c<span class="op">=</span><span class="st">&#39;k&#39;</span>, alpha<span class="op">=</span><span class="fl">0.1</span>, label<span class="op">=</span><span class="st">&#39;_nolegend_&#39;</span>,</span>
<span id="cb67-7"><a href="#cb67-7" aria-hidden="true" tabindex="-1"></a>            ax<span class="op">=</span>ax))<span class="op">;</span></span>
<span id="cb67-8"><a href="#cb67-8" aria-hidden="true" tabindex="-1"></a>ax.plot(pp_pieces, np.exp(pooled_pp_trace[<span class="st">&quot;obs&quot;</span>]).mean(axis<span class="op">=</span><span class="dv">0</span>),</span>
<span id="cb67-9"><a href="#cb67-9" aria-hidden="true" tabindex="-1"></a>        c<span class="op">=</span><span class="st">&#39;r&#39;</span>, lw<span class="op">=</span><span class="dv">2</span>, label<span class="op">=</span><span class="st">&quot;Pooled&quot;</span>)<span class="op">;</span></span>
<span id="cb67-10"><a href="#cb67-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb67-11"><a href="#cb67-11" aria-hidden="true" tabindex="-1"></a>ax.set_xscale(<span class="st">&#39;log&#39;</span>)<span class="op">;</span></span>
<span id="cb67-12"><a href="#cb67-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb67-13"><a href="#cb67-13" aria-hidden="true" tabindex="-1"></a>ax.set_yscale(<span class="st">&#39;log&#39;</span>)<span class="op">;</span></span>
<span id="cb67-14"><a href="#cb67-14" aria-hidden="true" tabindex="-1"></a>ax.set_ylabel(<span class="st">&quot;Retail price (2021 $)&quot;</span>)<span class="op">;</span></span>
<span id="cb67-15"><a href="#cb67-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb67-16"><a href="#cb67-16" aria-hidden="true" tabindex="-1"></a>handles, _ <span class="op">=</span> ax.get_legend_handles_labels()</span>
<span id="cb67-17"><a href="#cb67-17" aria-hidden="true" tabindex="-1"></a>partial_line <span class="op">=</span> Line2D([<span class="dv">0</span>], [<span class="dv">0</span>], color<span class="op">=</span><span class="st">&#39;k&#39;</span>,</span>
<span id="cb67-18"><a href="#cb67-18" aria-hidden="true" tabindex="-1"></a>                      label<span class="op">=</span><span class="st">&quot;Partially pooled&quot;</span>)</span>
<span id="cb67-19"><a href="#cb67-19" aria-hidden="true" tabindex="-1"></a>handles.append(partial_line)</span>
<span id="cb67-20"><a href="#cb67-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb67-21"><a href="#cb67-21" aria-hidden="true" tabindex="-1"></a>ax.legend(handles<span class="op">=</span>handles,</span>
<span id="cb67-22"><a href="#cb67-22" aria-hidden="true" tabindex="-1"></a>          title<span class="op">=</span><span class="st">&quot;Posterior predicted mean&quot;</span>,</span>
<span id="cb67-23"><a href="#cb67-23" aria-hidden="true" tabindex="-1"></a>          loc<span class="op">=</span><span class="st">&#39;upper left&#39;</span>)<span class="op">;</span></span></code></pre></div>
<center>
<img src="/resources/lego_pymc3_files/lego_pymc3_92_0.png" title="fig:" alt="png" />
</center>
<p>Note that the partial pooling model produces one line per theme, with varying slopes and intercepts. We can see that while the predictions for some themes are quite far away from the pooled predictions most are close to them, as shown by the stacking of the semi-transparent lines. Below we highlight the partially pooled predictions for a few themes of interest among all partially pooled predictions.</p>
<div class="sourceCode" id="cb68"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb68-1"><a href="#cb68-1" aria-hidden="true" tabindex="-1"></a>PLOT_THEMES <span class="op">=</span> [</span>
<span id="cb68-2"><a href="#cb68-2" aria-hidden="true" tabindex="-1"></a>    <span class="st">&quot;Creator Expert&quot;</span>,</span>
<span id="cb68-3"><a href="#cb68-3" aria-hidden="true" tabindex="-1"></a>    <span class="st">&quot;Disney&quot;</span>,</span>
<span id="cb68-4"><a href="#cb68-4" aria-hidden="true" tabindex="-1"></a>    <span class="st">&quot;Star Wars&quot;</span>,</span>
<span id="cb68-5"><a href="#cb68-5" aria-hidden="true" tabindex="-1"></a>    <span class="st">&quot;Harry Potter&quot;</span>,</span>
<span id="cb68-6"><a href="#cb68-6" aria-hidden="true" tabindex="-1"></a>    <span class="st">&quot;Marvel Super Heroes&quot;</span>,</span>
<span id="cb68-7"><a href="#cb68-7" aria-hidden="true" tabindex="-1"></a>    <span class="st">&quot;Ninjago&quot;</span>,</span>
<span id="cb68-8"><a href="#cb68-8" aria-hidden="true" tabindex="-1"></a>    <span class="st">&quot;City&quot;</span>,</span>
<span id="cb68-9"><a href="#cb68-9" aria-hidden="true" tabindex="-1"></a>    <span class="st">&quot;Space&quot;</span>,</span>
<span id="cb68-10"><a href="#cb68-10" aria-hidden="true" tabindex="-1"></a>    <span class="st">&quot;Jurassic World&quot;</span></span>
<span id="cb68-11"><a href="#cb68-11" aria-hidden="true" tabindex="-1"></a>]</span></code></pre></div>
<div class="sourceCode" id="cb69"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb69-1"><a href="#cb69-1" aria-hidden="true" tabindex="-1"></a>ax <span class="op">=</span> sns.scatterplot(x<span class="op">=</span><span class="st">&quot;Pieces&quot;</span>, y<span class="op">=</span><span class="st">&quot;RRP2021&quot;</span>, data<span class="op">=</span>df,</span>
<span id="cb69-2"><a href="#cb69-2" aria-hidden="true" tabindex="-1"></a>                alpha<span class="op">=</span><span class="fl">0.05</span>)<span class="op">;</span></span>
<span id="cb69-3"><a href="#cb69-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb69-4"><a href="#cb69-4" aria-hidden="true" tabindex="-1"></a>(pp_df.groupby(<span class="st">&quot;theme_id&quot;</span>)</span>
<span id="cb69-5"><a href="#cb69-5" aria-hidden="true" tabindex="-1"></a>      .plot(<span class="st">&quot;pieces&quot;</span>, <span class="st">&quot;pp_partial_mean&quot;</span>,</span>
<span id="cb69-6"><a href="#cb69-6" aria-hidden="true" tabindex="-1"></a>            c<span class="op">=</span><span class="st">&#39;k&#39;</span>, alpha<span class="op">=</span><span class="fl">0.1</span>, label<span class="op">=</span><span class="st">&#39;_nolegend_&#39;</span>,</span>
<span id="cb69-7"><a href="#cb69-7" aria-hidden="true" tabindex="-1"></a>            ax<span class="op">=</span>ax))<span class="op">;</span></span>
<span id="cb69-8"><a href="#cb69-8" aria-hidden="true" tabindex="-1"></a>(pp_df[pp_df[<span class="st">&quot;theme&quot;</span>].isin(PLOT_THEMES)]</span>
<span id="cb69-9"><a href="#cb69-9" aria-hidden="true" tabindex="-1"></a>      .groupby(<span class="st">&quot;theme_id&quot;</span>)</span>
<span id="cb69-10"><a href="#cb69-10" aria-hidden="true" tabindex="-1"></a>      .plot(<span class="st">&quot;pieces&quot;</span>, <span class="st">&quot;pp_partial_mean&quot;</span>,</span>
<span id="cb69-11"><a href="#cb69-11" aria-hidden="true" tabindex="-1"></a>            c<span class="op">=</span><span class="st">&#39;r&#39;</span>, label<span class="op">=</span><span class="st">&#39;_nolegend_&#39;</span>,</span>
<span id="cb69-12"><a href="#cb69-12" aria-hidden="true" tabindex="-1"></a>            ax<span class="op">=</span>ax))<span class="op">;</span></span>
<span id="cb69-13"><a href="#cb69-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb69-14"><a href="#cb69-14" aria-hidden="true" tabindex="-1"></a>ax.set_xscale(<span class="st">&#39;log&#39;</span>)<span class="op">;</span></span>
<span id="cb69-15"><a href="#cb69-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb69-16"><a href="#cb69-16" aria-hidden="true" tabindex="-1"></a>ax.set_yscale(<span class="st">&#39;log&#39;</span>)<span class="op">;</span></span>
<span id="cb69-17"><a href="#cb69-17" aria-hidden="true" tabindex="-1"></a>ax.set_ylabel(<span class="st">&quot;Retail price (2021 $)&quot;</span>)<span class="op">;</span></span>
<span id="cb69-18"><a href="#cb69-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb69-19"><a href="#cb69-19" aria-hidden="true" tabindex="-1"></a>title <span class="op">=</span> <span class="st">&quot;Highlighted: &quot;</span> \</span>
<span id="cb69-20"><a href="#cb69-20" aria-hidden="true" tabindex="-1"></a>            <span class="op">+</span> <span class="st">&quot;, &quot;</span>.join(PLOT_THEMES[:<span class="dv">4</span>]) <span class="op">+</span> <span class="st">&quot;,</span><span class="ch">\n</span><span class="st">&quot;</span> \</span>
<span id="cb69-21"><a href="#cb69-21" aria-hidden="true" tabindex="-1"></a>            <span class="op">+</span> <span class="st">&quot;, &quot;</span>.join(PLOT_THEMES[<span class="dv">4</span>:<span class="op">-</span><span class="dv">1</span>]) <span class="op">\</span></span>
<span id="cb69-22"><a href="#cb69-22" aria-hidden="true" tabindex="-1"></a>            <span class="op">+</span> <span class="st">&quot;, and &quot;</span> <span class="op">+</span> PLOT_THEMES[<span class="op">-</span><span class="dv">1</span>]</span>
<span id="cb69-23"><a href="#cb69-23" aria-hidden="true" tabindex="-1"></a>ax.set_title(title)<span class="op">;</span></span></code></pre></div>
<center>
<img src="/resources/lego_pymc3_files/lego_pymc3_95_0.png" title="fig:" alt="png" />
</center>
<p>These notable themes have preditions close to the global average, which makes sense since they all have a fair number of sets, so the global mean is pulled towards their theme effects.</p>
<p>It has long been known in the quantitative social sciences that when naively modeled (as we have) that group-level effects (in this case theme-level effects), can strongly correlate with item-level covariates (in this case standardized log pieces). We now investigate whether our partially pooled model results in such a correlation.</p>
<p>First we calculate the average value of <code>std_log_pieces</code> within each theme.</p>
<div class="sourceCode" id="cb70"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb70-1"><a href="#cb70-1" aria-hidden="true" tabindex="-1"></a>theme_mean_std_log_pieces <span class="op">=</span> (pd.Series(std_log_pieces, index<span class="op">=</span>df.index)</span>
<span id="cb70-2"><a href="#cb70-2" aria-hidden="true" tabindex="-1"></a>                               .groupby(df[<span class="st">&quot;Theme&quot;</span>])</span>
<span id="cb70-3"><a href="#cb70-3" aria-hidden="true" tabindex="-1"></a>                               .mean())</span></code></pre></div>
<div class="sourceCode" id="cb71"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb71-1"><a href="#cb71-1" aria-hidden="true" tabindex="-1"></a>ax <span class="op">=</span> theme_mean_std_log_pieces.plot.hist(bins<span class="op">=</span><span class="dv">20</span>, lw<span class="op">=</span><span class="fl">0.</span>, alpha<span class="op">=</span><span class="fl">0.5</span>)</span>
<span id="cb71-2"><a href="#cb71-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb71-3"><a href="#cb71-3" aria-hidden="true" tabindex="-1"></a>ax.set_xlabel(<span class="st">&quot;Average standardized log pieces</span><span class="ch">\n</span><span class="st">per set within theme&quot;</span>)<span class="op">;</span></span></code></pre></div>
<center>
<img src="/resources/lego_pymc3_files/lego_pymc3_98_0.png" title="fig:" alt="png" />
</center>
<p>We see that these theme averages vary fairly widely. The following plots show the relationship between each theme’s average standardized log pieces and the posterior expected values of <span class="math inline">\(\beta_{0, j}\)</span> and <span class="math inline">\(\beta_j\)</span> respectively.</p>
<div class="sourceCode" id="cb72"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb72-1"><a href="#cb72-1" aria-hidden="true" tabindex="-1"></a>post_β<span class="dv">0</span> <span class="op">=</span> partial_trace[<span class="st">&quot;posterior&quot;</span>][<span class="st">&quot;β0&quot;</span>].mean(dim<span class="op">=</span>(<span class="st">&#39;chain&#39;</span>, <span class="st">&#39;draw&#39;</span>))</span>
<span id="cb72-2"><a href="#cb72-2" aria-hidden="true" tabindex="-1"></a>post_β_pieces <span class="op">=</span> partial_trace[<span class="st">&quot;posterior&quot;</span>][<span class="st">&quot;β_pieces&quot;</span>].mean(dim<span class="op">=</span>(<span class="st">&#39;chain&#39;</span>, <span class="st">&#39;draw&#39;</span>))</span></code></pre></div>
<div class="sourceCode" id="cb73"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb73-1"><a href="#cb73-1" aria-hidden="true" tabindex="-1"></a>fig, (β<span class="dv">0</span><span class="er">_ax</span>, β_pieces_ax) <span class="op">=</span> plt.subplots( </span>
<span id="cb73-2"><a href="#cb73-2" aria-hidden="true" tabindex="-1"></a>    ncols<span class="op">=</span><span class="dv">2</span>, sharex<span class="op">=</span><span class="va">True</span>, sharey<span class="op">=</span><span class="va">False</span>,</span>
<span id="cb73-3"><a href="#cb73-3" aria-hidden="true" tabindex="-1"></a>    figsize<span class="op">=</span>(<span class="dv">15</span>, <span class="dv">6</span>)</span>
<span id="cb73-4"><a href="#cb73-4" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb73-5"><a href="#cb73-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-6"><a href="#cb73-6" aria-hidden="true" tabindex="-1"></a>β<span class="dv">0</span><span class="er">_ax</span>.scatter(theme_mean_std_log_pieces, post_β<span class="dv">0</span>)<span class="op">;</span></span>
<span id="cb73-7"><a href="#cb73-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-8"><a href="#cb73-8" aria-hidden="true" tabindex="-1"></a>β<span class="dv">0</span><span class="er">_ax</span>.set_xlabel(<span class="st">&quot;Average standardized log pieces</span><span class="ch">\n</span><span class="st">per set within theme&quot;</span>)<span class="op">;</span></span>
<span id="cb73-9"><a href="#cb73-9" aria-hidden="true" tabindex="-1"></a>β<span class="dv">0</span><span class="er">_ax</span>.set_ylabel(<span class="st">&quot;Posterior expected</span><span class="ch">\n</span><span class="st">value of $</span><span class="ch">\\</span><span class="st">beta_0$&quot;</span>)<span class="op">;</span></span>
<span id="cb73-10"><a href="#cb73-10" aria-hidden="true" tabindex="-1"></a> </span>
<span id="cb73-11"><a href="#cb73-11" aria-hidden="true" tabindex="-1"></a>β<span class="dv">0</span><span class="er">_corr</span>, β<span class="dv">0</span><span class="er">_corr_p_val</span> <span class="op">=</span> sp.stats.pearsonr(</span>
<span id="cb73-12"><a href="#cb73-12" aria-hidden="true" tabindex="-1"></a>    theme_mean_std_log_pieces.values,</span>
<span id="cb73-13"><a href="#cb73-13" aria-hidden="true" tabindex="-1"></a>    post_β<span class="dv">0</span></span>
<span id="cb73-14"><a href="#cb73-14" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb73-15"><a href="#cb73-15" aria-hidden="true" tabindex="-1"></a>β<span class="dv">0</span><span class="er">_ax</span>.set_title(<span class="ss">f&quot;Correlation coefficient = </span><span class="sc">{β</span><span class="dv">0</span><span class="er">_corr</span><span class="sc">:0.2f}</span><span class="ch">\n</span><span class="ss">&quot;</span></span>
<span id="cb73-16"><a href="#cb73-16" aria-hidden="true" tabindex="-1"></a>                <span class="ss">f&quot;Two-tailed p-value </span><span class="sc">{β</span><span class="dv">0</span><span class="er">_corr_p_val</span><span class="sc">:.2e}</span><span class="ss">&quot;</span>)<span class="op">;</span></span>
<span id="cb73-17"><a href="#cb73-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-18"><a href="#cb73-18" aria-hidden="true" tabindex="-1"></a>β_pieces_ax.scatter(theme_mean_std_log_pieces, post_β_pieces)<span class="op">;</span></span>
<span id="cb73-19"><a href="#cb73-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-20"><a href="#cb73-20" aria-hidden="true" tabindex="-1"></a>β_pieces_ax.set_xlabel(<span class="st">&quot;Average standardized log pieces</span><span class="ch">\n</span><span class="st">per set within theme&quot;</span>)<span class="op">;</span></span>
<span id="cb73-21"><a href="#cb73-21" aria-hidden="true" tabindex="-1"></a>β_pieces_ax.set_ylabel(<span class="st">&quot;Posterior expected</span><span class="ch">\n</span><span class="st">value of $</span><span class="ch">\\</span><span class="st">beta_</span><span class="sc">{pieces}</span><span class="st">$&quot;</span>)<span class="op">;</span></span>
<span id="cb73-22"><a href="#cb73-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-23"><a href="#cb73-23" aria-hidden="true" tabindex="-1"></a>β_pieces_corr, β_pieces_corr_p_val <span class="op">=</span> sp.stats.pearsonr(</span>
<span id="cb73-24"><a href="#cb73-24" aria-hidden="true" tabindex="-1"></a>    theme_mean_std_log_pieces.values,</span>
<span id="cb73-25"><a href="#cb73-25" aria-hidden="true" tabindex="-1"></a>    post_β_pieces</span>
<span id="cb73-26"><a href="#cb73-26" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb73-27"><a href="#cb73-27" aria-hidden="true" tabindex="-1"></a>β_pieces_ax.set_title(<span class="ss">f&quot;Correlation coefficient = </span><span class="sc">{β</span>_pieces_corr<span class="sc">:0.2f}</span><span class="ch">\n</span><span class="ss">&quot;</span></span>
<span id="cb73-28"><a href="#cb73-28" aria-hidden="true" tabindex="-1"></a>                      <span class="ss">f&quot;Two-tailed p-value </span><span class="sc">{β</span>_pieces_corr_p_val<span class="sc">:.2e}</span><span class="ss">&quot;</span>)<span class="op">;</span></span></code></pre></div>
<center>
<img src="/resources/lego_pymc3_files/lego_pymc3_101_0.png" title="fig:" alt="png" />
</center>
<p>Both plots show highly significant correlations, with a stronger correlation between the theme average and the posterior expected average of <span class="math inline">\(\beta_{0, j}\)</span>. These correlations lead to violations of the <a href="https://en.wikipedia.org/wiki/Gauss%E2%80%93Markov_theorem">Gauss-Markov assumptions</a> in our regression design, so we remedy them with an expanded model in the next section.</p>
<h3 id="partially-pooled-mean-model">Partially pooled mean model</h3>
<p>Fortunately Bafumi and Gelman<a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a> show how to remedy this violation by including the theme-level average standardized log pieces as a covariate in <span class="math inline">\(\beta_{0, j}\)</span> and <span class="math inline">\(\beta_j\)</span>. if we denote the average standardized log pieces for sets in the <span class="math inline">\(j\)</span>-th theme as <span class="math inline">\(\bar{\tilde{x}}_j\)</span>, in this extended model, <span class="math inline">\(\beta_{0, j}\)</span> is defined as</p>
<p><span class="math display">\[
\begin{align*}
    \mu_{\beta_0}, \gamma_{\beta, 0}
        &amp; \sim N(0, 2.5^2) \\
    \sigma_{\beta_0}
        &amp; \sim \textrm{HalfNormal}(2.5^2) \\
    \beta_{0, j}
        &amp; \sim N\left(\mu_{\beta_0} + \gamma_{\beta, 0} \cdot \bar{\tilde{x}}_j, \sigma_{\beta_0}^2\right),
\end{align*}
\]</span></p>
<p>and similarly for <span class="math inline">\(\beta_j\)</span>.</p>
<div class="sourceCode" id="cb74"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb74-1"><a href="#cb74-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> hierarchical_normal_with_mean(name, x_mean, shape, μ<span class="op">=</span><span class="va">None</span>):</span>
<span id="cb74-2"><a href="#cb74-2" aria-hidden="true" tabindex="-1"></a>    γ <span class="op">=</span> pm.Normal(<span class="ss">f&quot;γ_</span><span class="sc">{</span>name<span class="sc">}</span><span class="ss">&quot;</span>, <span class="fl">0.</span>, <span class="fl">2.5</span>)</span>
<span id="cb74-3"><a href="#cb74-3" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb74-4"><a href="#cb74-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> hierarchical_normal(name, shape, μ<span class="op">=</span>μ) <span class="op">+</span> γ <span class="op">*</span> x_mean</span></code></pre></div>
<div class="sourceCode" id="cb75"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb75-1"><a href="#cb75-1" aria-hidden="true" tabindex="-1"></a><span class="cf">with</span> pm.Model() <span class="im">as</span> mean_model:</span>
<span id="cb75-2"><a href="#cb75-2" aria-hidden="true" tabindex="-1"></a>    σ <span class="op">=</span> pm.HalfNormal(<span class="st">&quot;σ&quot;</span>, <span class="fl">5.</span>)</span>
<span id="cb75-3"><a href="#cb75-3" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb75-4"><a href="#cb75-4" aria-hidden="true" tabindex="-1"></a>    β<span class="dv">0</span> <span class="op">=</span> hierarchical_normal_with_mean(</span>
<span id="cb75-5"><a href="#cb75-5" aria-hidden="true" tabindex="-1"></a>        <span class="st">&quot;β0&quot;</span>, at.constant(theme_mean_std_log_pieces),</span>
<span id="cb75-6"><a href="#cb75-6" aria-hidden="true" tabindex="-1"></a>        n_theme</span>
<span id="cb75-7"><a href="#cb75-7" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb75-8"><a href="#cb75-8" aria-hidden="true" tabindex="-1"></a>    β_pieces <span class="op">=</span> hierarchical_normal_with_mean(</span>
<span id="cb75-9"><a href="#cb75-9" aria-hidden="true" tabindex="-1"></a>        <span class="st">&quot;β_pieces&quot;</span>, at.constant(theme_mean_std_log_pieces),</span>
<span id="cb75-10"><a href="#cb75-10" aria-hidden="true" tabindex="-1"></a>        n_theme</span>
<span id="cb75-11"><a href="#cb75-11" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb75-12"><a href="#cb75-12" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb75-13"><a href="#cb75-13" aria-hidden="true" tabindex="-1"></a>    μ <span class="op">=</span> β<span class="dv">0</span>[theme_id_] <span class="op">+</span> β_pieces[theme_id_] <span class="op">*</span> std_log_pieces_ <span class="op">\</span></span>
<span id="cb75-14"><a href="#cb75-14" aria-hidden="true" tabindex="-1"></a>            <span class="op">-</span> <span class="fl">0.5</span> <span class="op">*</span> σ<span class="op">**</span><span class="dv">2</span></span>
<span id="cb75-15"><a href="#cb75-15" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb75-16"><a href="#cb75-16" aria-hidden="true" tabindex="-1"></a>    obs <span class="op">=</span> pm.Normal(<span class="st">&quot;obs&quot;</span>, μ, σ, observed<span class="op">=</span>log_rrp2021)</span></code></pre></div>
<p>We now sample from this model.</p>
<div class="sourceCode" id="cb76"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb76-1"><a href="#cb76-1" aria-hidden="true" tabindex="-1"></a>std_log_pieces_.set_value(std_log_pieces)</span>
<span id="cb76-2"><a href="#cb76-2" aria-hidden="true" tabindex="-1"></a>theme_id_.set_value(theme_id)</span></code></pre></div>
<div class="sourceCode" id="cb77"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb77-1"><a href="#cb77-1" aria-hidden="true" tabindex="-1"></a><span class="cf">with</span> mean_model:</span>
<span id="cb77-2"><a href="#cb77-2" aria-hidden="true" tabindex="-1"></a>    mean_trace <span class="op">=</span> pm.sample(<span class="op">**</span>SAMPLE_KWARGS)</span></code></pre></div>
<pre><code>Auto-assigning NUTS sampler...
Initializing NUTS using jitter+adapt_diag...
Multiprocess sampling (3 chains in 3 jobs)
NUTS: [σ, γ_β0, μ_β0, Δ_β0, σ_β0, γ_β_pieces, μ_β_pieces, Δ_β_pieces, σ_β_pieces]</code></pre>
<div>
<style>
/* Turns off some styling */
progress {
/* gets rid of default border in Firefox and Opera. */
border: none;
/* Needs to be in here for Safari polyfill so background images work as expected. */
background-size: auto;
}
.progress-bar-interrupted, .progress-bar-interrupted::-webkit-progress-bar {
background: #F44336;
}
</style>
<progress value="6000" class max="6000" style="width:300px; height:20px; vertical-align: middle;">
</progress>
<p>100.00% [6000/6000 03:57&lt;00:00 Sampling 3 chains, 0 divergences]</p>
</div>
<pre><code>Sampling 3 chains for 1_000 tune and 1_000 draw iterations (3_000 + 3_000 draws total) took 239 seconds.
The number of effective samples is smaller than 10% for some parameters.</code></pre>
<p>Once again the sampling diagnostics show no cause for concern.</p>
<div class="sourceCode" id="cb80"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb80-1"><a href="#cb80-1" aria-hidden="true" tabindex="-1"></a>make_diagnostic_plots(mean_trace)<span class="op">;</span></span></code></pre></div>
<center>
<img src="/resources/lego_pymc3_files/lego_pymc3_110_0.png" title="fig:" alt="png" />
</center>
<p>The correlations from above have disappeared in this model.</p>
<div class="sourceCode" id="cb81"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb81-1"><a href="#cb81-1" aria-hidden="true" tabindex="-1"></a>post_β<span class="dv">0</span> <span class="op">=</span> mean_trace[<span class="st">&quot;posterior&quot;</span>][<span class="st">&quot;β0&quot;</span>].mean(dim<span class="op">=</span>(<span class="st">&#39;chain&#39;</span>, <span class="st">&#39;draw&#39;</span>))</span>
<span id="cb81-2"><a href="#cb81-2" aria-hidden="true" tabindex="-1"></a>post_β_pieces <span class="op">=</span> mean_trace[<span class="st">&quot;posterior&quot;</span>][<span class="st">&quot;β_pieces&quot;</span>].mean(dim<span class="op">=</span>(<span class="st">&#39;chain&#39;</span>, <span class="st">&#39;draw&#39;</span>))</span></code></pre></div>
<div class="sourceCode" id="cb82"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb82-1"><a href="#cb82-1" aria-hidden="true" tabindex="-1"></a>fig, (β<span class="dv">0</span><span class="er">_ax</span>, β_pieces_ax) <span class="op">=</span> plt.subplots( </span>
<span id="cb82-2"><a href="#cb82-2" aria-hidden="true" tabindex="-1"></a>    ncols<span class="op">=</span><span class="dv">2</span>, sharex<span class="op">=</span><span class="va">True</span>, sharey<span class="op">=</span><span class="va">False</span>,</span>
<span id="cb82-3"><a href="#cb82-3" aria-hidden="true" tabindex="-1"></a>    figsize<span class="op">=</span>(<span class="dv">15</span>, <span class="dv">6</span>)</span>
<span id="cb82-4"><a href="#cb82-4" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb82-5"><a href="#cb82-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb82-6"><a href="#cb82-6" aria-hidden="true" tabindex="-1"></a>β<span class="dv">0</span><span class="er">_ax</span>.scatter(theme_mean_std_log_pieces, post_β<span class="dv">0</span>)<span class="op">;</span></span>
<span id="cb82-7"><a href="#cb82-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb82-8"><a href="#cb82-8" aria-hidden="true" tabindex="-1"></a>β<span class="dv">0</span><span class="er">_ax</span>.set_xlabel(<span class="st">&quot;Average standardized log pieces</span><span class="ch">\n</span><span class="st">per set within theme&quot;</span>)<span class="op">;</span></span>
<span id="cb82-9"><a href="#cb82-9" aria-hidden="true" tabindex="-1"></a>β<span class="dv">0</span><span class="er">_ax</span>.set_ylabel(<span class="st">&quot;Posterior expected</span><span class="ch">\n</span><span class="st">value of $</span><span class="ch">\\</span><span class="st">beta_0$&quot;</span>)<span class="op">;</span></span>
<span id="cb82-10"><a href="#cb82-10" aria-hidden="true" tabindex="-1"></a> </span>
<span id="cb82-11"><a href="#cb82-11" aria-hidden="true" tabindex="-1"></a>β<span class="dv">0</span><span class="er">_corr</span>, β<span class="dv">0</span><span class="er">_corr_p_val</span> <span class="op">=</span> sp.stats.pearsonr(</span>
<span id="cb82-12"><a href="#cb82-12" aria-hidden="true" tabindex="-1"></a>    theme_mean_std_log_pieces.values,</span>
<span id="cb82-13"><a href="#cb82-13" aria-hidden="true" tabindex="-1"></a>    post_β<span class="dv">0</span></span>
<span id="cb82-14"><a href="#cb82-14" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb82-15"><a href="#cb82-15" aria-hidden="true" tabindex="-1"></a>β<span class="dv">0</span><span class="er">_ax</span>.set_title(<span class="ss">f&quot;Correlation coefficient = </span><span class="sc">{β</span><span class="dv">0</span><span class="er">_corr</span><span class="sc">:0.2f}</span><span class="ch">\n</span><span class="ss">&quot;</span></span>
<span id="cb82-16"><a href="#cb82-16" aria-hidden="true" tabindex="-1"></a>                <span class="ss">f&quot;Two-tailed p-value </span><span class="sc">{β</span><span class="dv">0</span><span class="er">_corr_p_val</span><span class="sc">:.2f}</span><span class="ss">&quot;</span>)<span class="op">;</span></span>
<span id="cb82-17"><a href="#cb82-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb82-18"><a href="#cb82-18" aria-hidden="true" tabindex="-1"></a>β_pieces_ax.scatter(theme_mean_std_log_pieces, post_β_pieces)<span class="op">;</span></span>
<span id="cb82-19"><a href="#cb82-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb82-20"><a href="#cb82-20" aria-hidden="true" tabindex="-1"></a>β_pieces_ax.set_xlabel(<span class="st">&quot;Average standardized log pieces</span><span class="ch">\n</span><span class="st">per set within theme&quot;</span>)<span class="op">;</span></span>
<span id="cb82-21"><a href="#cb82-21" aria-hidden="true" tabindex="-1"></a>β_pieces_ax.set_ylabel(<span class="st">&quot;Posterior expected</span><span class="ch">\n</span><span class="st">value of $</span><span class="ch">\\</span><span class="st">beta_</span><span class="sc">{pieces}</span><span class="st">$&quot;</span>)<span class="op">;</span></span>
<span id="cb82-22"><a href="#cb82-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb82-23"><a href="#cb82-23" aria-hidden="true" tabindex="-1"></a>β_pieces_corr, β_pieces_corr_p_val <span class="op">=</span> sp.stats.pearsonr(</span>
<span id="cb82-24"><a href="#cb82-24" aria-hidden="true" tabindex="-1"></a>    theme_mean_std_log_pieces.values,</span>
<span id="cb82-25"><a href="#cb82-25" aria-hidden="true" tabindex="-1"></a>    post_β_pieces</span>
<span id="cb82-26"><a href="#cb82-26" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb82-27"><a href="#cb82-27" aria-hidden="true" tabindex="-1"></a>β_pieces_ax.set_title(<span class="ss">f&quot;Correlation coefficient = </span><span class="sc">{β</span>_pieces_corr<span class="sc">:0.2f}</span><span class="ch">\n</span><span class="ss">&quot;</span></span>
<span id="cb82-28"><a href="#cb82-28" aria-hidden="true" tabindex="-1"></a>                      <span class="ss">f&quot;Two-tailed p-value </span><span class="sc">{β</span>_pieces_corr_p_val<span class="sc">:.2f}</span><span class="ss">&quot;</span>)<span class="op">;</span></span></code></pre></div>
<center>
<img src="/resources/lego_pymc3_files/lego_pymc3_113_0.png" title="fig:" alt="png" />
</center>
<p>We add this model to our comparison.</p>
<div class="sourceCode" id="cb83"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb83-1"><a href="#cb83-1" aria-hidden="true" tabindex="-1"></a>traces[<span class="st">&quot;Partially pooled with mean&quot;</span>] <span class="op">=</span> mean_trace</span></code></pre></div>
<div class="sourceCode" id="cb84"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb84-1"><a href="#cb84-1" aria-hidden="true" tabindex="-1"></a>comp_df <span class="op">=</span> az.compare(traces)</span></code></pre></div>
<div class="sourceCode" id="cb85"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb85-1"><a href="#cb85-1" aria-hidden="true" tabindex="-1"></a>comp_df.loc[:, :<span class="st">&quot;weight&quot;</span>]</span></code></pre></div>
<center>
<div>
<style scoped>
.dataframe tbody tr th:only-of-type {
vertical-align: middle;
}

.dataframe tbody tr th {
vertical-align: top;
}

.dataframe thead th {
text-align: right;
}
</style>
<table border="1" class="dataframe">
<thead>
<tr style="text-align: right;">
<th>
</th>
<th>
rank
</th>
<th>
loo
</th>
<th>
p_loo
</th>
<th>
d_loo
</th>
<th>
weight
</th>
</tr>
</thead>
<tbody>
<tr>
<th>
Partially pooled
</th>
<td>
0
</td>
<td>
-2315.578245
</td>
<td>
190.594364
</td>
<td>
0.000000
</td>
<td>
0.958583
</td>
</tr>
<tr>
<th>
Partially pooled with mean
</th>
<td>
1
</td>
<td>
-2316.840059
</td>
<td>
187.512592
</td>
<td>
1.261814
</td>
<td>
0.000000
</td>
</tr>
<tr>
<th>
Unpooled
</th>
<td>
2
</td>
<td>
-5133.311893
</td>
<td>
4.871287
</td>
<td>
2817.733648
</td>
<td>
0.041417
</td>
</tr>
</tbody>
</table>
</div>
</center>
<p><br></p>
<div class="sourceCode" id="cb86"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb86-1"><a href="#cb86-1" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots(figsize<span class="op">=</span>(<span class="dv">12</span>, <span class="dv">6</span>))</span>
<span id="cb86-2"><a href="#cb86-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb86-3"><a href="#cb86-3" aria-hidden="true" tabindex="-1"></a>az.plot_compare(comp_df, plot_ic_diff<span class="op">=</span><span class="va">False</span>, ax<span class="op">=</span>ax)<span class="op">;</span></span></code></pre></div>
<center>
<img src="/resources/lego_pymc3_files/lego_pymc3_118_0.png" title="fig:" alt="png" />
</center>
<p>We see that the the PSIS-LOO scores of both partially pooled model are better than the pooled model and statistically indistinguishable from each other. Given these scores, we will work with the model that accounts for the theme’s average standardized log pieces going forward, since it satisfies the Gauss-Markov assumptions better.</p>
<p>The residuals from the two partially pooled models are also visually quite similar, though the second partial pooling model does have less pronounced diagonal bands.</p>
<div class="sourceCode" id="cb87"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb87-1"><a href="#cb87-1" aria-hidden="true" tabindex="-1"></a><span class="cf">with</span> mean_model:</span>
<span id="cb87-2"><a href="#cb87-2" aria-hidden="true" tabindex="-1"></a>    pp_trace_data <span class="op">=</span> pm.sample_posterior_predictive(mean_trace)</span>
<span id="cb87-3"><a href="#cb87-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-4"><a href="#cb87-4" aria-hidden="true" tabindex="-1"></a>df[<span class="st">&quot;mean_resid&quot;</span>] <span class="op">=</span> (log_rrp2021 <span class="op">-</span> pp_trace_data[<span class="st">&quot;obs&quot;</span>]).mean(axis<span class="op">=</span><span class="dv">0</span>)</span></code></pre></div>
<div>
<style>
/* Turns off some styling */
progress {
/* gets rid of default border in Firefox and Opera. */
border: none;
/* Needs to be in here for Safari polyfill so background images work as expected. */
background-size: auto;
}
.progress-bar-interrupted, .progress-bar-interrupted::-webkit-progress-bar {
background: #F44336;
}
</style>
<progress value="3000" class max="3000" style="width:300px; height:20px; vertical-align: middle;">
</progress>
<p>100.00% [3000/3000 00:01&lt;00:00]</p>
</div>
<div class="sourceCode" id="cb88"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb88-1"><a href="#cb88-1" aria-hidden="true" tabindex="-1"></a>fig, axes <span class="op">=</span> plt.subplots(ncols<span class="op">=</span><span class="dv">2</span>, sharex<span class="op">=</span><span class="va">True</span>, sharey<span class="op">=</span><span class="va">True</span>,</span>
<span id="cb88-2"><a href="#cb88-2" aria-hidden="true" tabindex="-1"></a>                         figsize<span class="op">=</span>(<span class="dv">14</span>, <span class="dv">6</span>))</span>
<span id="cb88-3"><a href="#cb88-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb88-4"><a href="#cb88-4" aria-hidden="true" tabindex="-1"></a>sns.scatterplot(x<span class="op">=</span><span class="st">&quot;Pieces&quot;</span>, y<span class="op">=</span><span class="st">&quot;pooled_resid&quot;</span>, data<span class="op">=</span>df,</span>
<span id="cb88-5"><a href="#cb88-5" aria-hidden="true" tabindex="-1"></a>                alpha<span class="op">=</span><span class="fl">0.1</span>, ax<span class="op">=</span>axes[<span class="dv">0</span>])<span class="op">;</span></span>
<span id="cb88-6"><a href="#cb88-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb88-7"><a href="#cb88-7" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>].set_xscale(<span class="st">&#39;log&#39;</span>)<span class="op">;</span></span>
<span id="cb88-8"><a href="#cb88-8" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>].set_xlabel(<span class="st">&quot;Pieces&quot;</span>)<span class="op">;</span></span>
<span id="cb88-9"><a href="#cb88-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb88-10"><a href="#cb88-10" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>].set_ylabel(<span class="st">&quot;Log RRP residual (2021 $)&quot;</span>)<span class="op">;</span></span>
<span id="cb88-11"><a href="#cb88-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb88-12"><a href="#cb88-12" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>].set_title(<span class="st">&quot;Partially pooled model&quot;</span>)<span class="op">;</span></span>
<span id="cb88-13"><a href="#cb88-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb88-14"><a href="#cb88-14" aria-hidden="true" tabindex="-1"></a>sns.scatterplot(x<span class="op">=</span><span class="st">&quot;Pieces&quot;</span>, y<span class="op">=</span><span class="st">&quot;mean_resid&quot;</span>, data<span class="op">=</span>df,</span>
<span id="cb88-15"><a href="#cb88-15" aria-hidden="true" tabindex="-1"></a>                alpha<span class="op">=</span><span class="fl">0.1</span>, ax<span class="op">=</span>axes[<span class="dv">1</span>])<span class="op">;</span></span>
<span id="cb88-16"><a href="#cb88-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb88-17"><a href="#cb88-17" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>].set_xscale(<span class="st">&#39;log&#39;</span>)<span class="op">;</span></span>
<span id="cb88-18"><a href="#cb88-18" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>].set_xlabel(<span class="st">&quot;Pieces&quot;</span>)<span class="op">;</span></span>
<span id="cb88-19"><a href="#cb88-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb88-20"><a href="#cb88-20" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>].set_ylabel(<span class="st">&quot;Log RRP residual (2021 $)&quot;</span>)<span class="op">;</span></span>
<span id="cb88-21"><a href="#cb88-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb88-22"><a href="#cb88-22" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>].set_title(<span class="st">&quot;Partially pooled mean model&quot;</span>)<span class="op">;</span></span>
<span id="cb88-23"><a href="#cb88-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb88-24"><a href="#cb88-24" aria-hidden="true" tabindex="-1"></a>fig.tight_layout()<span class="op">;</span></span></code></pre></div>
<center>
<img src="/resources/lego_pymc3_files/lego_pymc3_121_0.png" title="fig:" alt="png" />
</center>
<p>Interestingly, there is more variation in the varying intercepts (<span class="math inline">\(\beta_{0, j}\)</span>) than the varying slopes (<span class="math inline">\(\beta_j\)</span>), since <span class="math inline">\(\sigma_{\beta_0}\)</span> has a larger posterior expected value than <span class="math inline">\(\sigma_{\beta}\)</span>.</p>
<div class="sourceCode" id="cb89"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb89-1"><a href="#cb89-1" aria-hidden="true" tabindex="-1"></a>az.plot_posterior(mean_trace,</span>
<span id="cb89-2"><a href="#cb89-2" aria-hidden="true" tabindex="-1"></a>                  var_names<span class="op">=</span>[</span>
<span id="cb89-3"><a href="#cb89-3" aria-hidden="true" tabindex="-1"></a>                      <span class="st">&quot;μ_β0&quot;</span>, <span class="st">&quot;μ_β_pieces&quot;</span>,</span>
<span id="cb89-4"><a href="#cb89-4" aria-hidden="true" tabindex="-1"></a>                      <span class="st">&quot;σ_β0&quot;</span>, <span class="st">&quot;σ_β_pieces&quot;</span></span>
<span id="cb89-5"><a href="#cb89-5" aria-hidden="true" tabindex="-1"></a>                  ],</span>
<span id="cb89-6"><a href="#cb89-6" aria-hidden="true" tabindex="-1"></a>                  grid<span class="op">=</span>(<span class="dv">2</span>, <span class="dv">2</span>))<span class="op">;</span></span></code></pre></div>
<center>
<img src="/resources/lego_pymc3_files/lego_pymc3_123_0.png" title="fig:" alt="png" />
</center>
<p>Plotting the residuals of log RRP in 2021 dollars versus time shows that the residuals for this model are significantly larger for sets between 1980 and 1995. This phenomenon makes sense as Lego has released many more sets per year after 1995 than in the initial period, so the estimates are dominated by the data in this later period.</p>
<div class="sourceCode" id="cb90"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb90-1"><a href="#cb90-1" aria-hidden="true" tabindex="-1"></a>ax <span class="op">=</span> (df.groupby(level<span class="op">=</span><span class="st">&quot;Year released&quot;</span>)</span>
<span id="cb90-2"><a href="#cb90-2" aria-hidden="true" tabindex="-1"></a>        [<span class="st">&quot;mean_resid&quot;</span>]</span>
<span id="cb90-3"><a href="#cb90-3" aria-hidden="true" tabindex="-1"></a>        .mean()</span>
<span id="cb90-4"><a href="#cb90-4" aria-hidden="true" tabindex="-1"></a>        .plot(c<span class="op">=</span><span class="st">&#39;k&#39;</span>, label<span class="op">=</span><span class="st">&quot;Year average&quot;</span>))<span class="op">;</span></span>
<span id="cb90-5"><a href="#cb90-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb90-6"><a href="#cb90-6" aria-hidden="true" tabindex="-1"></a>strip_ax <span class="op">=</span> ax.twiny()</span>
<span id="cb90-7"><a href="#cb90-7" aria-hidden="true" tabindex="-1"></a>sns.stripplot(x<span class="op">=</span><span class="st">&quot;Year released&quot;</span>, y<span class="op">=</span><span class="st">&quot;mean_resid&quot;</span>,</span>
<span id="cb90-8"><a href="#cb90-8" aria-hidden="true" tabindex="-1"></a>              data<span class="op">=</span>df.reset_index(),</span>
<span id="cb90-9"><a href="#cb90-9" aria-hidden="true" tabindex="-1"></a>              jitter<span class="op">=</span><span class="fl">1.5</span>,</span>
<span id="cb90-10"><a href="#cb90-10" aria-hidden="true" tabindex="-1"></a>              color<span class="op">=</span><span class="st">&#39;C0&#39;</span>, alpha<span class="op">=</span><span class="fl">0.1</span>,</span>
<span id="cb90-11"><a href="#cb90-11" aria-hidden="true" tabindex="-1"></a>              ax<span class="op">=</span>strip_ax)<span class="op">;</span></span>
<span id="cb90-12"><a href="#cb90-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb90-13"><a href="#cb90-13" aria-hidden="true" tabindex="-1"></a>strip_ax.set_axis_off()<span class="op">;</span></span>
<span id="cb90-14"><a href="#cb90-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb90-15"><a href="#cb90-15" aria-hidden="true" tabindex="-1"></a>ax.set_ylim(<span class="op">-</span><span class="dv">2</span>, <span class="dv">2</span>)<span class="op">;</span></span>
<span id="cb90-16"><a href="#cb90-16" aria-hidden="true" tabindex="-1"></a>ax.set_ylabel(<span class="st">&quot;Log RRP residual (2021 $)&quot;</span>)<span class="op">;</span></span>
<span id="cb90-17"><a href="#cb90-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb90-18"><a href="#cb90-18" aria-hidden="true" tabindex="-1"></a>ax.legend(loc<span class="op">=</span><span class="st">&#39;upper left&#39;</span>)<span class="op">;</span></span></code></pre></div>
<center>
<img src="/resources/lego_pymc3_files/lego_pymc3_125_0.png" title="fig:" alt="png" />
</center>
<h3 id="time-varying-model">Time-varying model</h3>
<p>We address this issue with the residuals by adding a time-varying component to <span class="math inline">\(\beta_0\)</span>. First we build <code>t</code>, which indicates the number of years after the data begins in 1980 that the set was released.</p>
<div class="sourceCode" id="cb91"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb91-1"><a href="#cb91-1" aria-hidden="true" tabindex="-1"></a>year <span class="op">=</span> df.index.get_level_values(<span class="st">&quot;Year released&quot;</span>).year.values</span>
<span id="cb91-2"><a href="#cb91-2" aria-hidden="true" tabindex="-1"></a>t <span class="op">=</span> year <span class="op">-</span> year.<span class="bu">min</span>()</span>
<span id="cb91-3"><a href="#cb91-3" aria-hidden="true" tabindex="-1"></a>t_ <span class="op">=</span> shared(t)</span>
<span id="cb91-4"><a href="#cb91-4" aria-hidden="true" tabindex="-1"></a>n_year <span class="op">=</span> <span class="bu">int</span>(t.<span class="bu">max</span>() <span class="op">+</span> <span class="dv">1</span>)</span></code></pre></div>
<p>The prior on <span class="math inline">\(\beta_j\)</span> stays the same as in the mean model, but we add a Gaussian random walk term, <span class="math inline">\(\beta_{0, t}\)</span> to the intercept, <span class="math inline">\(\beta_0\)</span>. We use the priors</p>
<p><span class="math display">\[
\begin{align*}
    \mu_{\beta_{0, pieces}}, \gamma_{\beta_{0, pieces}}
        &amp; \sim N(0, 2.5^2) \\
    \sigma_{\beta_{0, pieces}}
        &amp; \sim \textrm{HalfNormal}(2.5^2) \\
    \Delta_{\beta_{0, i}}
        &amp; \sim N(0, 0.25^2) \\
    \beta_{0, t}
        &amp; \sim \sum_{i = 1}^t \Delta_{\beta_{0, i}} \\
    \beta_{0, j, t}
        &amp; \sim N\left(\mu_{\beta_0} + \beta_{0, t} + \gamma_{\beta, 0} \cdot \bar{\tilde{x}}_j, \sigma_{\beta_0}^2\right).
\end{align*}
\]</span></p>
<p>We see that the time-varying factor <span class="math inline">\(\beta_{0, t}\)</span> is constant across themes in order to reduce the computational burden when sampling from this model.</p>
<div class="sourceCode" id="cb92"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb92-1"><a href="#cb92-1" aria-hidden="true" tabindex="-1"></a><span class="cf">with</span> pm.Model() <span class="im">as</span> time_model:</span>
<span id="cb92-2"><a href="#cb92-2" aria-hidden="true" tabindex="-1"></a>    Δ_β<span class="dv">0</span><span class="er">_t</span> <span class="op">=</span> pm.Normal(<span class="st">&quot;Δ_β0_t&quot;</span>, <span class="fl">0.</span>, <span class="fl">0.25</span>, shape<span class="op">=</span>n_year)</span>
<span id="cb92-3"><a href="#cb92-3" aria-hidden="true" tabindex="-1"></a>    β<span class="dv">0</span><span class="er">_t</span> <span class="op">=</span> pm.Deterministic(<span class="st">&quot;β0_t&quot;</span>, Δ_β<span class="dv">0</span><span class="er">_t</span>.cumsum())</span>
<span id="cb92-4"><a href="#cb92-4" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb92-5"><a href="#cb92-5" aria-hidden="true" tabindex="-1"></a>    β<span class="dv">0</span><span class="er">_theme</span> <span class="op">=</span> hierarchical_normal_with_mean(</span>
<span id="cb92-6"><a href="#cb92-6" aria-hidden="true" tabindex="-1"></a>        <span class="st">&quot;β0_theme&quot;</span>, at.constant(theme_mean_std_log_pieces),</span>
<span id="cb92-7"><a href="#cb92-7" aria-hidden="true" tabindex="-1"></a>        n_theme</span>
<span id="cb92-8"><a href="#cb92-8" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb92-9"><a href="#cb92-9" aria-hidden="true" tabindex="-1"></a>    β<span class="dv">0</span><span class="er">_i</span> <span class="op">=</span> β<span class="dv">0</span><span class="er">_t</span>[t_] <span class="op">+</span> β<span class="dv">0</span><span class="er">_theme</span>[theme_id_]</span>
<span id="cb92-10"><a href="#cb92-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb92-11"><a href="#cb92-11" aria-hidden="true" tabindex="-1"></a>    β_pieces <span class="op">=</span> hierarchical_normal_with_mean(</span>
<span id="cb92-12"><a href="#cb92-12" aria-hidden="true" tabindex="-1"></a>        <span class="st">&quot;β_pieces&quot;</span>, at.constant(theme_mean_std_log_pieces),</span>
<span id="cb92-13"><a href="#cb92-13" aria-hidden="true" tabindex="-1"></a>        n_theme</span>
<span id="cb92-14"><a href="#cb92-14" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb92-15"><a href="#cb92-15" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb92-16"><a href="#cb92-16" aria-hidden="true" tabindex="-1"></a>    σ <span class="op">=</span> pm.HalfNormal(<span class="st">&quot;σ&quot;</span>, <span class="fl">5.</span>)</span>
<span id="cb92-17"><a href="#cb92-17" aria-hidden="true" tabindex="-1"></a>    μ <span class="op">=</span> β<span class="dv">0</span><span class="er">_i</span> <span class="op">+</span> β_pieces[theme_id_] <span class="op">*</span> std_log_pieces_ <span class="op">-</span> <span class="fl">0.5</span> <span class="op">*</span> σ<span class="op">**</span><span class="dv">2</span></span>
<span id="cb92-18"><a href="#cb92-18" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb92-19"><a href="#cb92-19" aria-hidden="true" tabindex="-1"></a>    obs <span class="op">=</span> pm.Normal(<span class="st">&quot;obs&quot;</span>, μ, σ, observed<span class="op">=</span>log_rrp2021)</span></code></pre></div>
<p>We now sample from this model.</p>
<div class="sourceCode" id="cb93"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb93-1"><a href="#cb93-1" aria-hidden="true" tabindex="-1"></a><span class="cf">with</span> time_model:</span>
<span id="cb93-2"><a href="#cb93-2" aria-hidden="true" tabindex="-1"></a>    time_trace <span class="op">=</span> pm.sample(<span class="op">**</span>SAMPLE_KWARGS)</span></code></pre></div>
<pre><code>Auto-assigning NUTS sampler...
Initializing NUTS using jitter+adapt_diag...
Multiprocess sampling (3 chains in 3 jobs)
NUTS: [Δ_β0_t, γ_β0_theme, μ_β0_theme, Δ_β0_theme, σ_β0_theme, γ_β_pieces, μ_β_pieces, Δ_β_pieces, σ_β_pieces, σ]</code></pre>
<div>
<style>
/* Turns off some styling */
progress {
/* gets rid of default border in Firefox and Opera. */
border: none;
/* Needs to be in here for Safari polyfill so background images work as expected. */
background-size: auto;
}
.progress-bar-interrupted, .progress-bar-interrupted::-webkit-progress-bar {
background: #F44336;
}
</style>
<progress value="6000" class max="6000" style="width:300px; height:20px; vertical-align: middle;">
</progress>
<p>100.00% [6000/6000 17:36&lt;00:00 Sampling 3 chains, 0 divergences]</p>
</div>
<pre><code>Sampling 3 chains for 1_000 tune and 1_000 draw iterations (3_000 + 3_000 draws total) took 1056 seconds.
The number of effective samples is smaller than 25% for some parameters.</code></pre>
<p>Once again the sampling diagnostics show no cause for concern.</p>
<div class="sourceCode" id="cb96"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb96-1"><a href="#cb96-1" aria-hidden="true" tabindex="-1"></a>make_diagnostic_plots(time_trace)<span class="op">;</span></span></code></pre></div>
<center>
<img src="/resources/lego_pymc3_files/lego_pymc3_133_0.png" title="fig:" alt="png" />
</center>
<p>We see that the time-varying model performs noticeably better than the other models in terms of PSIS-LOO score.</p>
<div class="sourceCode" id="cb97"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb97-1"><a href="#cb97-1" aria-hidden="true" tabindex="-1"></a>traces[<span class="st">&quot;Partially pooled with mean and time&quot;</span>] <span class="op">=</span> time_trace</span></code></pre></div>
<div class="sourceCode" id="cb98"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb98-1"><a href="#cb98-1" aria-hidden="true" tabindex="-1"></a>comp_df <span class="op">=</span> az.compare(traces)</span></code></pre></div>
<div class="sourceCode" id="cb99"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb99-1"><a href="#cb99-1" aria-hidden="true" tabindex="-1"></a>comp_df.loc[:, :<span class="st">&quot;weight&quot;</span>]</span></code></pre></div>
<center>
<div>
<style scoped>
.dataframe tbody tr th:only-of-type {
vertical-align: middle;
}

.dataframe tbody tr th {
vertical-align: top;
}

.dataframe thead th {
text-align: right;
}
</style>
<table border="1" class="dataframe">
<thead>
<tr style="text-align: right;">
<th>
</th>
<th>
rank
</th>
<th>
loo
</th>
<th>
p_loo
</th>
<th>
d_loo
</th>
<th>
weight
</th>
</tr>
</thead>
<tbody>
<tr>
<th>
Partially pooled with mean and time
</th>
<td>
0
</td>
<td>
-2058.373203
</td>
<td>
245.239325
</td>
<td>
0.000000
</td>
<td>
9.205189e-01
</td>
</tr>
<tr>
<th>
Partially pooled
</th>
<td>
1
</td>
<td>
-2315.578245
</td>
<td>
190.594364
</td>
<td>
257.205042
</td>
<td>
4.565283e-02
</td>
</tr>
<tr>
<th>
Partially pooled with mean
</th>
<td>
2
</td>
<td>
-2316.840059
</td>
<td>
187.512592
</td>
<td>
258.466855
</td>
<td>
1.857221e-12
</td>
</tr>
<tr>
<th>
Unpooled
</th>
<td>
3
</td>
<td>
-5133.311893
</td>
<td>
4.871287
</td>
<td>
3074.938690
</td>
<td>
3.382830e-02
</td>
</tr>
</tbody>
</table>
</div>
</center>
<p><br></p>
<div class="sourceCode" id="cb100"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb100-1"><a href="#cb100-1" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots(figsize<span class="op">=</span>(<span class="dv">12</span>, <span class="dv">6</span>))</span>
<span id="cb100-2"><a href="#cb100-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb100-3"><a href="#cb100-3" aria-hidden="true" tabindex="-1"></a>az.plot_compare(comp_df, plot_ic_diff<span class="op">=</span><span class="va">False</span>, ax<span class="op">=</span>ax)<span class="op">;</span></span></code></pre></div>
<center>
<img src="/resources/lego_pymc3_files/lego_pymc3_138_0.png" title="fig:" alt="png" />
</center>
<p>The residuals for this model are similar to those of the previous one when plotted against the number of pieces in the set.</p>
<div class="sourceCode" id="cb101"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb101-1"><a href="#cb101-1" aria-hidden="true" tabindex="-1"></a><span class="cf">with</span> time_model:</span>
<span id="cb101-2"><a href="#cb101-2" aria-hidden="true" tabindex="-1"></a>    pp_time_data <span class="op">=</span> pm.sample_posterior_predictive(time_trace)</span>
<span id="cb101-3"><a href="#cb101-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-4"><a href="#cb101-4" aria-hidden="true" tabindex="-1"></a>df[<span class="st">&quot;time_resid&quot;</span>] <span class="op">=</span> (log_rrp2021 <span class="op">-</span> pp_time_data[<span class="st">&quot;obs&quot;</span>]).mean(axis<span class="op">=</span><span class="dv">0</span>)</span></code></pre></div>
<div>
<style>
/* Turns off some styling */
progress {
/* gets rid of default border in Firefox and Opera. */
border: none;
/* Needs to be in here for Safari polyfill so background images work as expected. */
background-size: auto;
}
.progress-bar-interrupted, .progress-bar-interrupted::-webkit-progress-bar {
background: #F44336;
}
</style>
<progress value="3000" class max="3000" style="width:300px; height:20px; vertical-align: middle;">
</progress>
<p>100.00% [3000/3000 00:02&lt;00:00]</p>
</div>
<div class="sourceCode" id="cb102"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb102-1"><a href="#cb102-1" aria-hidden="true" tabindex="-1"></a>fig, axes <span class="op">=</span> plt.subplots(ncols<span class="op">=</span><span class="dv">2</span>, sharex<span class="op">=</span><span class="va">True</span>, sharey<span class="op">=</span><span class="va">True</span>,</span>
<span id="cb102-2"><a href="#cb102-2" aria-hidden="true" tabindex="-1"></a>                         figsize<span class="op">=</span>(<span class="dv">14</span>, <span class="dv">6</span>))</span>
<span id="cb102-3"><a href="#cb102-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb102-4"><a href="#cb102-4" aria-hidden="true" tabindex="-1"></a>sns.scatterplot(x<span class="op">=</span><span class="st">&quot;Pieces&quot;</span>, y<span class="op">=</span><span class="st">&quot;mean_resid&quot;</span>, data<span class="op">=</span>df,</span>
<span id="cb102-5"><a href="#cb102-5" aria-hidden="true" tabindex="-1"></a>                alpha<span class="op">=</span><span class="fl">0.1</span>, ax<span class="op">=</span>axes[<span class="dv">0</span>])<span class="op">;</span></span>
<span id="cb102-6"><a href="#cb102-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb102-7"><a href="#cb102-7" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>].set_xscale(<span class="st">&#39;log&#39;</span>)<span class="op">;</span></span>
<span id="cb102-8"><a href="#cb102-8" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>].set_xlabel(<span class="st">&quot;Pieces&quot;</span>)<span class="op">;</span></span>
<span id="cb102-9"><a href="#cb102-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb102-10"><a href="#cb102-10" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>].set_ylabel(<span class="st">&quot;Log RRP residual (2021 $)&quot;</span>)<span class="op">;</span></span>
<span id="cb102-11"><a href="#cb102-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb102-12"><a href="#cb102-12" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>].set_title(<span class="st">&quot;Partially pooled mean model&quot;</span>)<span class="op">;</span></span>
<span id="cb102-13"><a href="#cb102-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb102-14"><a href="#cb102-14" aria-hidden="true" tabindex="-1"></a>sns.scatterplot(x<span class="op">=</span><span class="st">&quot;Pieces&quot;</span>, y<span class="op">=</span><span class="st">&quot;time_resid&quot;</span>, data<span class="op">=</span>df,</span>
<span id="cb102-15"><a href="#cb102-15" aria-hidden="true" tabindex="-1"></a>                alpha<span class="op">=</span><span class="fl">0.1</span>, ax<span class="op">=</span>axes[<span class="dv">1</span>])<span class="op">;</span></span>
<span id="cb102-16"><a href="#cb102-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb102-17"><a href="#cb102-17" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>].set_xscale(<span class="st">&#39;log&#39;</span>)<span class="op">;</span></span>
<span id="cb102-18"><a href="#cb102-18" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>].set_xlabel(<span class="st">&quot;Pieces&quot;</span>)<span class="op">;</span></span>
<span id="cb102-19"><a href="#cb102-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb102-20"><a href="#cb102-20" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>].set_ylabel(<span class="st">&quot;Log RRP residual (2021 $)&quot;</span>)<span class="op">;</span></span>
<span id="cb102-21"><a href="#cb102-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb102-22"><a href="#cb102-22" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>].set_title(<span class="st">&quot;Partially pooled mean model with time&quot;</span>)<span class="op">;</span></span>
<span id="cb102-23"><a href="#cb102-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb102-24"><a href="#cb102-24" aria-hidden="true" tabindex="-1"></a>fig.tight_layout()<span class="op">;</span></span></code></pre></div>
<center>
<img src="/resources/lego_pymc3_files/lego_pymc3_141_0.png" title="fig:" alt="png" />
</center>
<p>The following plot shows that this model has significantly reduced the amount of time-dependence in the residuals.</p>
<div class="sourceCode" id="cb103"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb103-1"><a href="#cb103-1" aria-hidden="true" tabindex="-1"></a>ax <span class="op">=</span> (df.groupby(level<span class="op">=</span><span class="st">&quot;Year released&quot;</span>)</span>
<span id="cb103-2"><a href="#cb103-2" aria-hidden="true" tabindex="-1"></a>        [<span class="st">&quot;time_resid&quot;</span>]</span>
<span id="cb103-3"><a href="#cb103-3" aria-hidden="true" tabindex="-1"></a>        .mean()</span>
<span id="cb103-4"><a href="#cb103-4" aria-hidden="true" tabindex="-1"></a>        .plot(c<span class="op">=</span><span class="st">&#39;k&#39;</span>, label<span class="op">=</span><span class="st">&quot;Year average&quot;</span>))<span class="op">;</span></span>
<span id="cb103-5"><a href="#cb103-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb103-6"><a href="#cb103-6" aria-hidden="true" tabindex="-1"></a>strip_ax <span class="op">=</span> ax.twiny()</span>
<span id="cb103-7"><a href="#cb103-7" aria-hidden="true" tabindex="-1"></a>sns.stripplot(x<span class="op">=</span><span class="st">&quot;Year released&quot;</span>, y<span class="op">=</span><span class="st">&quot;time_resid&quot;</span>,</span>
<span id="cb103-8"><a href="#cb103-8" aria-hidden="true" tabindex="-1"></a>              data<span class="op">=</span>df.reset_index(),</span>
<span id="cb103-9"><a href="#cb103-9" aria-hidden="true" tabindex="-1"></a>              jitter<span class="op">=</span><span class="fl">1.5</span>,</span>
<span id="cb103-10"><a href="#cb103-10" aria-hidden="true" tabindex="-1"></a>              color<span class="op">=</span><span class="st">&#39;C0&#39;</span>, alpha<span class="op">=</span><span class="fl">0.1</span>,</span>
<span id="cb103-11"><a href="#cb103-11" aria-hidden="true" tabindex="-1"></a>              ax<span class="op">=</span>strip_ax)<span class="op">;</span></span>
<span id="cb103-12"><a href="#cb103-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb103-13"><a href="#cb103-13" aria-hidden="true" tabindex="-1"></a>strip_ax.set_axis_off()<span class="op">;</span></span>
<span id="cb103-14"><a href="#cb103-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb103-15"><a href="#cb103-15" aria-hidden="true" tabindex="-1"></a>ax.set_ylim(<span class="op">-</span><span class="dv">2</span>, <span class="dv">2</span>)<span class="op">;</span></span>
<span id="cb103-16"><a href="#cb103-16" aria-hidden="true" tabindex="-1"></a>ax.set_ylabel(<span class="st">&quot;Log RRP residual (2021 $)&quot;</span>)<span class="op">;</span></span>
<span id="cb103-17"><a href="#cb103-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb103-18"><a href="#cb103-18" aria-hidden="true" tabindex="-1"></a>ax.legend(loc<span class="op">=</span><span class="st">&#39;upper left&#39;</span>)<span class="op">;</span></span></code></pre></div>
<center>
<img src="/resources/lego_pymc3_files/lego_pymc3_143_0.png" title="fig:" alt="png" />
</center>
<p>Again, there is more variation in the varying intercepts (<span class="math inline">\(\beta_{0, j}\)</span>) than the varying slopes (<span class="math inline">\(\beta_j\)</span>), since <span class="math inline">\(\sigma_{\beta_0}\)</span> has a larger posterior expected value than <span class="math inline">\(\sigma_{\beta}\)</span>.</p>
<div class="sourceCode" id="cb104"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb104-1"><a href="#cb104-1" aria-hidden="true" tabindex="-1"></a>az.plot_posterior(time_trace,</span>
<span id="cb104-2"><a href="#cb104-2" aria-hidden="true" tabindex="-1"></a>                  var_names<span class="op">=</span>[</span>
<span id="cb104-3"><a href="#cb104-3" aria-hidden="true" tabindex="-1"></a>                      <span class="st">&quot;μ_β0_theme&quot;</span>, <span class="st">&quot;μ_β_pieces&quot;</span>,</span>
<span id="cb104-4"><a href="#cb104-4" aria-hidden="true" tabindex="-1"></a>                      <span class="st">&quot;σ_β0_theme&quot;</span>, <span class="st">&quot;σ_β_pieces&quot;</span></span>
<span id="cb104-5"><a href="#cb104-5" aria-hidden="true" tabindex="-1"></a>                  ],</span>
<span id="cb104-6"><a href="#cb104-6" aria-hidden="true" tabindex="-1"></a>                  grid<span class="op">=</span>(<span class="dv">2</span>, <span class="dv">2</span>))<span class="op">;</span></span></code></pre></div>
<center>
<img src="/resources/lego_pymc3_files/lego_pymc3_145_0.png" title="fig:" alt="png" />
</center>
<p>We now revisit the question of whether or not Darth Vader’s Meditation Chamber is fairly priced. In the previous post in this series, we compared the price per piece of this set to all sets, all Star Wars sets, and all sets currently in my collection. We found that it was in or near the first quartile of price per piece among all sets and Star Wars sets, and near the median priece per piece in my collection. With this model in hand, we can ask where the adjusted recommended retail price falls in the predicted distribution of posterior predicted prices for a Star Wars set with 663 pieces.</p>
<div class="sourceCode" id="cb105"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb105-1"><a href="#cb105-1" aria-hidden="true" tabindex="-1"></a>VADER_MEDITATION <span class="op">=</span> <span class="st">&quot;75296-1&quot;</span></span>
<span id="cb105-2"><a href="#cb105-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb105-3"><a href="#cb105-3" aria-hidden="true" tabindex="-1"></a>vader_info <span class="op">=</span> df.xs(VADER_MEDITATION, level<span class="op">=</span><span class="st">&quot;Set number&quot;</span>)</span>
<span id="cb105-4"><a href="#cb105-4" aria-hidden="true" tabindex="-1"></a>vader_iloc <span class="op">=</span> (df.index</span>
<span id="cb105-5"><a href="#cb105-5" aria-hidden="true" tabindex="-1"></a>                .get_level_values(<span class="st">&quot;Set number&quot;</span>)</span>
<span id="cb105-6"><a href="#cb105-6" aria-hidden="true" tabindex="-1"></a>                .isin([VADER_MEDITATION])</span>
<span id="cb105-7"><a href="#cb105-7" aria-hidden="true" tabindex="-1"></a>                .argmax())</span></code></pre></div>
<div class="sourceCode" id="cb106"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb106-1"><a href="#cb106-1" aria-hidden="true" tabindex="-1"></a>(vader_info[<span class="st">&quot;RRP2021&quot;</span>].values[<span class="dv">0</span>] <span class="op">\</span></span>
<span id="cb106-2"><a href="#cb106-2" aria-hidden="true" tabindex="-1"></a>    <span class="op">&gt;=</span> np.exp(pp_trace_data[<span class="st">&quot;obs&quot;</span>][:, vader_iloc])).mean()</span></code></pre></div>
<pre><code>0.2816666666666667</code></pre>
<p>The set falls in towards the bottom of the second quartile of predicted prices for such a set, which is consistent with the empirical price per piece analysis of the previous post. This model can also answer some counterfactual questions about my collection. We see that my sets are highly concentrated in the Star Wars theme, with a smattering of other themes represented as well.</p>
<div class="sourceCode" id="cb108"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb108-1"><a href="#cb108-1" aria-hidden="true" tabindex="-1"></a>(df[df[<span class="st">&quot;austin&quot;</span>] <span class="op">==</span> <span class="va">True</span>]</span>
<span id="cb108-2"><a href="#cb108-2" aria-hidden="true" tabindex="-1"></a>   [<span class="st">&quot;Theme&quot;</span>]</span>
<span id="cb108-3"><a href="#cb108-3" aria-hidden="true" tabindex="-1"></a>   .value_counts(ascending<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb108-4"><a href="#cb108-4" aria-hidden="true" tabindex="-1"></a>   .plot.barh())<span class="op">;</span></span></code></pre></div>
<center>
<img src="/resources/lego_pymc3_files/lego_pymc3_150_0.png" title="fig:" alt="png" />
</center>
<p>This preponderance of Star Wars sets is even stronger than it initially appears because all but one of my BrickHeadz sets are Star Wars characters. The single exception are the adorable German Shepherds (<a href="https://www.lego.com/en-us/product/german-shepherd-40440">40440</a>).</p>
<center>
<img src="https://www.lego.com/cdn/cs/set/assets/blt5e9ef14c0a074aa4/40440.jpg" width=500>
</center>
<p>In particular, we can compare the actual cost of my collection to the predicted expected cost of my collection conditioned on the piece count and theme of the sets.</p>
<div class="sourceCode" id="cb109"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb109-1"><a href="#cb109-1" aria-hidden="true" tabindex="-1"></a>coll_value <span class="op">=</span> (df[df[<span class="st">&quot;austin&quot;</span>] <span class="op">==</span> <span class="va">True</span>]</span>
<span id="cb109-2"><a href="#cb109-2" aria-hidden="true" tabindex="-1"></a>                [<span class="st">&quot;RRP2021&quot;</span>]</span>
<span id="cb109-3"><a href="#cb109-3" aria-hidden="true" tabindex="-1"></a>                .<span class="bu">sum</span>())</span></code></pre></div>
<div class="sourceCode" id="cb110"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb110-1"><a href="#cb110-1" aria-hidden="true" tabindex="-1"></a>coll_value</span></code></pre></div>
<pre><code>3206.3933684401236</code></pre>
<div class="sourceCode" id="cb112"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb112-1"><a href="#cb112-1" aria-hidden="true" tabindex="-1"></a>(np.exp(pp_trace_data[<span class="st">&quot;obs&quot;</span>])</span>
<span id="cb112-2"><a href="#cb112-2" aria-hidden="true" tabindex="-1"></a>                     [:, df[<span class="st">&quot;austin&quot;</span>] <span class="op">==</span> <span class="va">True</span>]</span>
<span id="cb112-3"><a href="#cb112-3" aria-hidden="true" tabindex="-1"></a>                     .mean(axis<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb112-4"><a href="#cb112-4" aria-hidden="true" tabindex="-1"></a>                     .<span class="bu">sum</span>())</span></code></pre></div>
<pre><code>3826.537853977332</code></pre>
<p>So my collection cost about 20% less than expected conditioned on piece count and theme. (This figure actually understates my frugality as I have received several sets as gifts, notably the massive Super Star Destroyer (<a href="https://brickset.com/sets/10221-1/Super-Star-Destroyer">10221</a>).) We can easily check where my collection’s actual value falls in the posterior predictive distribution of its possible values.</p>
<div class="sourceCode" id="cb114"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb114-1"><a href="#cb114-1" aria-hidden="true" tabindex="-1"></a>pp_coll_value <span class="op">=</span> (np.exp(pp_trace_data[<span class="st">&quot;obs&quot;</span>])</span>
<span id="cb114-2"><a href="#cb114-2" aria-hidden="true" tabindex="-1"></a>                   [:, df[<span class="st">&quot;austin&quot;</span>] <span class="op">==</span> <span class="va">True</span>]</span>
<span id="cb114-3"><a href="#cb114-3" aria-hidden="true" tabindex="-1"></a>                   .<span class="bu">sum</span>(axis<span class="op">=</span><span class="dv">1</span>))</span></code></pre></div>
<div class="sourceCode" id="cb115"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb115-1"><a href="#cb115-1" aria-hidden="true" tabindex="-1"></a>ax, <span class="op">=</span> (sns.displot(pp_coll_value, kind<span class="op">=</span><span class="st">&#39;kde&#39;</span>,</span>
<span id="cb115-2"><a href="#cb115-2" aria-hidden="true" tabindex="-1"></a>                   height<span class="op">=</span><span class="dv">6</span>, aspect<span class="op">=</span><span class="dv">8</span> <span class="op">/</span> <span class="dv">6</span>,</span>
<span id="cb115-3"><a href="#cb115-3" aria-hidden="true" tabindex="-1"></a>                   label<span class="op">=</span><span class="st">&quot;Posterior predictive distribution&quot;</span>)</span>
<span id="cb115-4"><a href="#cb115-4" aria-hidden="true" tabindex="-1"></a>          .axes.flatten())</span>
<span id="cb115-5"><a href="#cb115-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb115-6"><a href="#cb115-6" aria-hidden="true" tabindex="-1"></a>ax.axvline(coll_value, c<span class="op">=</span><span class="st">&#39;k&#39;</span>, ls<span class="op">=</span><span class="st">&#39;--&#39;</span>,</span>
<span id="cb115-7"><a href="#cb115-7" aria-hidden="true" tabindex="-1"></a>           label<span class="op">=</span><span class="st">&quot;Actual value&quot;</span>)<span class="op">;</span></span>
<span id="cb115-8"><a href="#cb115-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb115-9"><a href="#cb115-9" aria-hidden="true" tabindex="-1"></a>ax.xaxis.set_major_formatter(dollar_formatter)<span class="op">;</span></span>
<span id="cb115-10"><a href="#cb115-10" aria-hidden="true" tabindex="-1"></a>ax.set_xlabel(<span class="st">&quot;Collection value (2021 $)&quot;</span>)<span class="op">;</span></span>
<span id="cb115-11"><a href="#cb115-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb115-12"><a href="#cb115-12" aria-hidden="true" tabindex="-1"></a>ax.set_yticks([])<span class="op">;</span></span>
<span id="cb115-13"><a href="#cb115-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb115-14"><a href="#cb115-14" aria-hidden="true" tabindex="-1"></a>ax.legend(loc<span class="op">=</span><span class="st">&#39;upper right&#39;</span>)<span class="op">;</span></span></code></pre></div>
<center>
<img src="/resources/lego_pymc3_files/lego_pymc3_158_0.png" title="fig:" alt="png" />
</center>
<div class="sourceCode" id="cb116"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb116-1"><a href="#cb116-1" aria-hidden="true" tabindex="-1"></a>(coll_value <span class="op">&gt;</span> pp_coll_value).mean()</span></code></pre></div>
<pre><code>0.007</code></pre>
<p>My collection’s actual value is in the first percentile of the posterior predictive distribution of possible collection values; according to this model, I really am quite cheap!</p>
<p>It is worth noting that in this post we have modeled log price directly, not price per piece as in the last model. Those familiar with offset terms in offsets in generalizedl linear models will notice that the model we have specified can be equivalent to an model of (log) price per piece if we fix <span class="math inline">\(\beta_j = 1\)</span>, since <span class="math inline">\(\log\left(\frac{x}{y}\right) = \log x - \log y.\)</span> The following plot shows how far outside the high density area of the posterior distribution of <span class="math inline">\(\mu_{\beta_0}\)</span> the value one is.</p>
<div class="sourceCode" id="cb118"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb118-1"><a href="#cb118-1" aria-hidden="true" tabindex="-1"></a>az.plot_posterior(time_trace, var_names<span class="op">=</span>[<span class="st">&quot;μ_β0_theme&quot;</span>], ref_val<span class="op">=</span><span class="fl">1.</span>)<span class="op">;</span></span></code></pre></div>
<center>
<img src="/resources/lego_pymc3_files/lego_pymc3_161_0.png" title="fig:" alt="png" />
</center>
<p>Due to this fact, we prefer to model (log) price directly over using an offset model that includes (log) piece count on both sides of the equal sign.</p>
<p>Future posts will explore further inferences from this model and develop extended models using other attributes of each set available via Brickset.</p>
<p>This post is available as a Jupyter notebook <a href="https://nbviewer.jupyter.org/gist/AustinRochford/f75d687d383b0a884c7782af1419bcf9">here</a>.</p>
<div class="sourceCode" id="cb119"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb119-1"><a href="#cb119-1" aria-hidden="true" tabindex="-1"></a><span class="op">%</span>load_ext watermark</span>
<span id="cb119-2"><a href="#cb119-2" aria-hidden="true" tabindex="-1"></a><span class="op">%</span>watermark <span class="op">-</span>n <span class="op">-</span>u <span class="op">-</span>v <span class="op">-</span>iv</span></code></pre></div>
<pre><code>Last updated: Thu Jun 10 2021

Python implementation: CPython
Python version       : 3.8.8
IPython version      : 7.22.0

pandas    : 1.2.3
aesara    : 2.0.10
pymc3     : 4.0
scipy     : 1.6.2
seaborn   : 0.11.1
matplotlib: 3.4.1
arviz     : 0.11.2
numpy     : 1.20.2</code></pre>
<section class="footnotes" role="doc-endnotes">
<hr />
<ol>
<li id="fn1" role="doc-endnote"><p>Vehtari, A., Gelman, A., &amp; Gabry, J. (2017). <a href="https://arxiv.org/abs/1507.04544">Practical Bayesian model evaluation using leave-one-out cross-validation and WAIC.</a> (PSIS-LOO) to compare them.) <em>Statistics and computing</em>, 27(5), 1413-1432.<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2" role="doc-endnote"><p>Bafumi, J., &amp; Gelman, A. E. (2006). <a href="http://www.stat.columbia.edu/~gelman/research/unpublished/Bafumi_Gelman_Midwest06.pdf">Fitting multilevel models when predictors and group effects correlate.</a><a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>
