<meta name="title" content="Modeling Shark Attacks in Python with PyMC3" />
<meta name="tags" content="Sharks, PyMC3, Bayesian Statistics" />
<meta name="date" content="2021-06-27" />
<meta name="has_math" content="true" /><p>On a recent visit to <a href="https://www.capemay.com/">Cape May, New Jersey</a> I bought and read <a href="https://www.amazon.com/dp/B085N5K6BQ"><em>Shark Attacks of the Jersey Shore: A History</em></a>, which is an interesting account of verified shark attacks in New Jersey since the nineteenth century.</p>
<center>
<img src="https://img.thriftbooks.com/api/images/i/l/B0471B8D82576AC3D1ADE7F48D84273FE9A59A19.jpg">
</center>
<p>While I was reading the book, I grew curious about modeling the frequency of shark attacks and went on the hunt for relevant data. There have not been many recent shark attacks in New Jersey, so I broadened my search and found the <a href="http://www.sharkattackfile.net/">Global Shark Attack File</a> (GSAF). The GSAF provides a fairly detailed <a href="http://www.sharkattackfile.net/incidentlog.htm">incident log</a> which appears to be updated every few days. This post presents an analysis of the GSAF data in Python using PyMC3. (It is worth mentioning that I am not a shark biologist, and I am sure specialists have produced much more useful and accurate models of shark attacks. Still, this seems like a fun small project as long as we don’t take the results too seriously.)</p>
<p>First we make some Python imports and do a bit of housekeeping.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="op">%</span>matplotlib inline</span></code></pre></div>
<div class="sourceCode" id="cb2"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> functools <span class="im">import</span> <span class="bu">reduce</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> warnings <span class="im">import</span> filterwarnings</span></code></pre></div>
<div class="sourceCode" id="cb3"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> aesara <span class="im">import</span> tensor <span class="im">as</span> at</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> arviz <span class="im">as</span> az</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> matplotlib <span class="im">import</span> pyplot <span class="im">as</span> plt</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pandas <span class="im">as</span> pd</span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pymc3 <span class="im">as</span> pm</span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> seaborn <span class="im">as</span> sns</span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> us</span></code></pre></div>
<pre><code>You are running the v4 development version of PyMC3 which currently still lacks key features. You probably want to use the stable v3 instead which you can either install via conda or find on the v3 GitHub branch: https://github.com/pymc-devs/pymc3/tree/v3</code></pre>
<div class="sourceCode" id="cb5"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a>filterwarnings(<span class="st">&#39;ignore&#39;</span>, category<span class="op">=</span><span class="pp">UserWarning</span>, module<span class="op">=</span><span class="st">&#39;aesara&#39;</span>)</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>filterwarnings(<span class="st">&#39;ignore&#39;</span>, category<span class="op">=</span><span class="pp">UserWarning</span>, module<span class="op">=</span><span class="st">&#39;arviz&#39;</span>)</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>filterwarnings(<span class="st">&#39;ignore&#39;</span>, category<span class="op">=</span><span class="pp">UserWarning</span>, module<span class="op">=</span><span class="st">&#39;pandas&#39;</span>)</span></code></pre></div>
<div class="sourceCode" id="cb6"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a>plt.rcParams[<span class="st">&#39;figure.figsize&#39;</span>] <span class="op">=</span> (<span class="dv">8</span>, <span class="dv">6</span>)</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>sns.<span class="bu">set</span>(color_codes<span class="op">=</span><span class="va">True</span>)</span></code></pre></div>
<h2 id="load-and-transform-the-data">Load and Transform the Data</h2>
<p>We begin by downloading the data from the GSAF and loading the relevant columns into a Pandas data frame.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="op">%%</span>bash</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>DATA_URL<span class="op">=</span>http:<span class="op">//</span>www.sharkattackfile.net<span class="op">/</span>spreadsheets<span class="op">/</span>GSAF5.xls</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>DATA_DEST<span class="op">=</span>.<span class="op">/</span>data<span class="op">/</span>GSAF5.xls</span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> [[ <span class="op">!</span> <span class="op">-</span>e $DATA_DEST ]]<span class="op">;</span></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>then</span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>    wget <span class="op">-</span>q <span class="op">-</span>O $DATA_DEST $DATA_URL</span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a>fi</span></code></pre></div>
<div class="sourceCode" id="cb8"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a>full_df <span class="op">=</span> pd.read_excel(<span class="st">&#39;./data/GSAF5.xls&#39;</span>,</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>                        usecols<span class="op">=</span>[</span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>                           <span class="st">&quot;Case Number&quot;</span>, <span class="st">&quot;Date&quot;</span>, <span class="st">&quot;Type&quot;</span>,</span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>                           <span class="st">&quot;Country&quot;</span>, <span class="st">&quot;Area&quot;</span>, <span class="st">&quot;Location&quot;</span>,</span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>                           <span class="st">&quot;Fatal (Y/N)&quot;</span></span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a>                        ],</span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a>                        index_col<span class="op">=</span><span class="st">&quot;Case Number&quot;</span>)</span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a>full_df[<span class="st">&quot;Date&quot;</span>] <span class="op">=</span> full_df[<span class="st">&quot;Date&quot;</span>].<span class="bu">apply</span>(pd.to_datetime, errors<span class="op">=</span><span class="st">&#39;coerce&#39;</span>)</span></code></pre></div>
<div class="sourceCode" id="cb9"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a>full_df.head()</span></code></pre></div>
<center>
<div>
<style scoped>
.dataframe tbody tr th:only-of-type {
vertical-align: middle;
}

.dataframe tbody tr th {
vertical-align: top;
}

.dataframe thead th {
text-align: right;
}
</style>
<table border="1" class="dataframe">
<thead>
<tr style="text-align: right;">
<th>
</th>
<th>
Date
</th>
<th>
Type
</th>
<th>
Country
</th>
<th>
Area
</th>
<th>
Location
</th>
<th>
Fatal (Y/N)
</th>
</tr>
<tr>
<th>
Case Number
</th>
<th>
</th>
<th>
</th>
<th>
</th>
<th>
</th>
<th>
</th>
<th>
</th>
</tr>
</thead>
<tbody>
<tr>
<th>
2021.06.14.b
</th>
<td>
2021-06-14
</td>
<td>
Unprovoked
</td>
<td>
USA
</td>
<td>
Florida
</td>
<td>
New Smyrna Beach, Volusia County
</td>
<td>
N
</td>
</tr>
<tr>
<th>
2021.06.14.a
</th>
<td>
2021-06-14
</td>
<td>
Unprovoked
</td>
<td>
USA
</td>
<td>
Florida
</td>
<td>
New Smyrna Beach, Volusia County
</td>
<td>
N
</td>
</tr>
<tr>
<th>
2021.06.12
</th>
<td>
2021-06-12
</td>
<td>
Provoked
</td>
<td>
ENGLAND
</td>
<td>
West Sussex
</td>
<td>
Littlehampton
</td>
<td>
N
</td>
</tr>
<tr>
<th>
2021.06.11
</th>
<td>
2021-06-11
</td>
<td>
Unprovoked
</td>
<td>
AUSTRALIA
</td>
<td>
Western Australia
</td>
<td>
Five Fingers Reef
</td>
<td>
N
</td>
</tr>
<tr>
<th>
2021.05.23
</th>
<td>
2021-05-23
</td>
<td>
Unprovoked
</td>
<td>
USA
</td>
<td>
South Carolina
</td>
<td>
Burkes Beach, Hilton Head, Beaufort County
</td>
<td>
N
</td>
</tr>
</tbody>
</table>
</div>
</center>
<p><br></p>
<div class="sourceCode" id="cb10"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a>full_df.tail()</span></code></pre></div>
<center>
<div>
<style scoped>
.dataframe tbody tr th:only-of-type {
vertical-align: middle;
}

.dataframe tbody tr th {
vertical-align: top;
}

.dataframe thead th {
text-align: right;
}
</style>
<table border="1" class="dataframe">
<thead>
<tr style="text-align: right;">
<th>
</th>
<th>
Date
</th>
<th>
Type
</th>
<th>
Country
</th>
<th>
Area
</th>
<th>
Location
</th>
<th>
Fatal (Y/N)
</th>
</tr>
<tr>
<th>
Case Number
</th>
<th>
</th>
<th>
</th>
<th>
</th>
<th>
</th>
<th>
</th>
<th>
</th>
</tr>
</thead>
<tbody>
<tr>
<th>
NaN
</th>
<td>
NaT
</td>
<td>
NaN
</td>
<td>
NaN
</td>
<td>
NaN
</td>
<td>
NaN
</td>
<td>
NaN
</td>
</tr>
<tr>
<th>
NaN
</th>
<td>
NaT
</td>
<td>
NaN
</td>
<td>
NaN
</td>
<td>
NaN
</td>
<td>
NaN
</td>
<td>
NaN
</td>
</tr>
<tr>
<th>
NaN
</th>
<td>
NaT
</td>
<td>
NaN
</td>
<td>
NaN
</td>
<td>
NaN
</td>
<td>
NaN
</td>
<td>
NaN
</td>
</tr>
<tr>
<th>
NaN
</th>
<td>
NaT
</td>
<td>
NaN
</td>
<td>
NaN
</td>
<td>
NaN
</td>
<td>
NaN
</td>
<td>
NaN
</td>
</tr>
<tr>
<th>
xx
</th>
<td>
NaT
</td>
<td>
NaN
</td>
<td>
NaN
</td>
<td>
NaN
</td>
<td>
NaN
</td>
<td>
NaN
</td>
</tr>
</tbody>
</table>
</div>
</center>
<p><br></p>
<p>We can already see by inspecting the data frame that there will be quite a bit of missing data to handle.</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a>full_df.index.isnull().mean()</span></code></pre></div>
<pre><code>0.6595373706846449</code></pre>
<div class="sourceCode" id="cb13"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a>full_df.isnull().mean()</span></code></pre></div>
<pre><code>Date           0.775621
Type           0.742880
Country        0.744391
Area           0.760587
Location       0.763726
Fatal (Y/N)    0.763842
dtype: float64</code></pre>
<p>We begin by filtering out rows with missing data in important columns.</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a>FILTERS <span class="op">=</span> [</span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>    <span class="op">~</span>full_df.index.isnull(),</span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a>    <span class="op">~</span>full_df[<span class="st">&quot;Date&quot;</span>].isnull(),</span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">~</span>full_df[<span class="st">&quot;Type&quot;</span>].isnull()</span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a>]</span></code></pre></div>
<div class="sourceCode" id="cb16"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a>(full_df[<span class="bu">reduce</span>(np.logical_and, FILTERS)]</span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a>        .isnull()</span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a>        .mean())</span></code></pre></div>
<pre><code>Date           0.000000
Type           0.000000
Country        0.004843
Area           0.052413
Location       0.061927
Fatal (Y/N)    0.079398
dtype: float64</code></pre>
<p>We see now that there is significantly less missing data, so we proceed to examine various aspects of the data.</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a>ax <span class="op">=</span> (full_df[<span class="bu">reduce</span>(np.logical_and, FILTERS)]</span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a>             [<span class="st">&quot;Type&quot;</span>]</span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a>             .value_counts()</span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a>             .plot(kind<span class="op">=</span><span class="st">&#39;barh&#39;</span>))</span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true" tabindex="-1"></a>ax.set_xscale(<span class="st">&#39;log&#39;</span>)<span class="op">;</span></span>
<span id="cb18-7"><a href="#cb18-7" aria-hidden="true" tabindex="-1"></a>ax.set_xlabel(<span class="st">&quot;Number of attacks&quot;</span>)<span class="op">;</span></span>
<span id="cb18-8"><a href="#cb18-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-9"><a href="#cb18-9" aria-hidden="true" tabindex="-1"></a>ax.invert_yaxis()<span class="op">;</span></span>
<span id="cb18-10"><a href="#cb18-10" aria-hidden="true" tabindex="-1"></a>ax.set_ylabel(<span class="st">&quot;Type of attack&quot;</span>)<span class="op">;</span></span></code></pre></div>
<center>
<img src="/resources/sharks_pycm3_files/sharks_pycm3_19_0.png" title="fig:" alt="png" />
</center>
<p>Unprovoked attacks are by far the most common. We will focus our analysis on this type of attack.</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a>FILTERS.append(full_df[<span class="st">&quot;Type&quot;</span>] <span class="op">==</span> <span class="st">&quot;Unprovoked&quot;</span>)</span></code></pre></div>
<div class="sourceCode" id="cb20"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a>ax <span class="op">=</span> (full_df[<span class="bu">reduce</span>(np.logical_and, FILTERS)]</span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a>             [<span class="st">&quot;Country&quot;</span>]</span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a>             .value_counts()</span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a>             .plot(kind<span class="op">=</span><span class="st">&#39;barh&#39;</span>, figsize<span class="op">=</span>(<span class="dv">8</span>, <span class="dv">30</span>)))</span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-6"><a href="#cb20-6" aria-hidden="true" tabindex="-1"></a>ax.set_xscale(<span class="st">&#39;log&#39;</span>)<span class="op">;</span></span>
<span id="cb20-7"><a href="#cb20-7" aria-hidden="true" tabindex="-1"></a>ax.set_xlabel(<span class="st">&quot;Number of unprovoked attacks&quot;</span>)<span class="op">;</span></span>
<span id="cb20-8"><a href="#cb20-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-9"><a href="#cb20-9" aria-hidden="true" tabindex="-1"></a>ax.invert_yaxis()<span class="op">;</span></span>
<span id="cb20-10"><a href="#cb20-10" aria-hidden="true" tabindex="-1"></a>ax.set_ylabel(<span class="st">&quot;Country&quot;</span>)<span class="op">;</span></span></code></pre></div>
<center>
<img src="/resources/sharks_pycm3_files/sharks_pycm3_22_0.png" title="fig:" alt="png" />
</center>
<p>While the data contain information about attacks in many countries, we will focus on the United States. This focus is due partially to the fact that I was in New Jersey when considering this problem, and partially due to the fact that finding standardized data across countries can be more challenging than within different regions of a single country.</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a>FILTERS.append(full_df[<span class="st">&quot;Country&quot;</span>] <span class="op">==</span> <span class="st">&quot;USA&quot;</span>)</span></code></pre></div>
<div class="sourceCode" id="cb22"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a>ax <span class="op">=</span> (full_df[<span class="bu">reduce</span>(np.logical_and, FILTERS)]</span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a>[<span class="st">&quot;Area&quot;</span>]</span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a>.value_counts()</span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true" tabindex="-1"></a>.plot(kind<span class="op">=</span><span class="st">&#39;barh&#39;</span>, figsize<span class="op">=</span>(<span class="dv">8</span>, <span class="dv">12</span>)))</span>
<span id="cb22-5"><a href="#cb22-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-6"><a href="#cb22-6" aria-hidden="true" tabindex="-1"></a>ax.set_xscale(<span class="st">&#39;log&#39;</span>)<span class="op">;</span></span>
<span id="cb22-7"><a href="#cb22-7" aria-hidden="true" tabindex="-1"></a>ax.set_xlabel(<span class="st">&quot;Number of unprovoked attacks&quot;</span>)<span class="op">;</span></span>
<span id="cb22-8"><a href="#cb22-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-9"><a href="#cb22-9" aria-hidden="true" tabindex="-1"></a>ax.invert_yaxis()<span class="op">;</span></span>
<span id="cb22-10"><a href="#cb22-10" aria-hidden="true" tabindex="-1"></a>ax.set_ylabel(<span class="st">&quot;Country&quot;</span>)<span class="op">;</span></span></code></pre></div>
<center>
<img src="/resources/sharks_pycm3_files/sharks_pycm3_25_0.png" title="fig:" alt="png" />
</center>
<p>We see that for unprovoked attacks in the United States, <code>Area</code> roughly corresponds to state, with some territories included as well. Since most of the territories appear very rarely, we restrict our analysis to states so that it is easier to find information about them.</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a>FILTERS.append(</span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a>full_df[<span class="st">&quot;Area&quot;</span>].isin([</span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true" tabindex="-1"></a>state.name <span class="cf">for</span> state <span class="kw">in</span> us.states.STATES</span>
<span id="cb23-4"><a href="#cb23-4" aria-hidden="true" tabindex="-1"></a>])</span>
<span id="cb23-5"><a href="#cb23-5" aria-hidden="true" tabindex="-1"></a>)</span></code></pre></div>
<p>Finally we look at how the number of shark attacks has changed over time.</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a>ax <span class="op">=</span> (full_df.assign(Year<span class="op">=</span>full_df[<span class="st">&quot;Date&quot;</span>].dt.year)</span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a>             [<span class="bu">reduce</span>(np.logical_and, FILTERS)]</span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true" tabindex="-1"></a>             [<span class="st">&quot;Year&quot;</span>]</span>
<span id="cb24-4"><a href="#cb24-4" aria-hidden="true" tabindex="-1"></a>             .value_counts()</span>
<span id="cb24-5"><a href="#cb24-5" aria-hidden="true" tabindex="-1"></a>             .sort_index()</span>
<span id="cb24-6"><a href="#cb24-6" aria-hidden="true" tabindex="-1"></a>             .plot())</span>
<span id="cb24-7"><a href="#cb24-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-8"><a href="#cb24-8" aria-hidden="true" tabindex="-1"></a>ax.set_xlabel(<span class="st">&quot;Year&quot;</span>)<span class="op">;</span></span>
<span id="cb24-9"><a href="#cb24-9" aria-hidden="true" tabindex="-1"></a>ax.set_ylabel(<span class="st">&quot;Unprovoked shark attacks</span><span class="ch">\n</span><span class="st">in the United States&quot;</span>)<span class="op">;</span></span></code></pre></div>
<center>
<img src="/resources/sharks_pycm3_files/sharks_pycm3_29_0.png" title="fig:" alt="png" />
</center>
<p>We see that the number of shark attacks has increased over time. This phenomenon is likely partially due to population growth and partially due to improved reporting mechanisms for shark attacks. We willk keep a relatively modern focus an analysze shark attacks between 1960 and 2020.</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a>YEAR_RANGE <span class="op">=</span> (<span class="dv">1960</span>, <span class="dv">2020</span>)</span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true" tabindex="-1"></a>FILTERS.append(full_df[<span class="st">&quot;Date&quot;</span>].dt.year.between(<span class="op">*</span>YEAR_RANGE))</span></code></pre></div>
<p>Now that we have defined the set of attacks we will model, we produce another data frame including only these attacks and make some light transformations of the data.</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a>df <span class="op">=</span> (full_df[<span class="bu">reduce</span>(np.logical_and, FILTERS)]</span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a>             .copy()</span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true" tabindex="-1"></a>             .rename(columns<span class="op">=</span>{<span class="st">&quot;Area&quot;</span>: <span class="st">&quot;State&quot;</span>}))</span>
<span id="cb26-4"><a href="#cb26-4" aria-hidden="true" tabindex="-1"></a>df[<span class="st">&quot;Year&quot;</span>] <span class="op">=</span> df[<span class="st">&quot;Date&quot;</span>].dt.year</span></code></pre></div>
<div class="sourceCode" id="cb27"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a>df.head()</span></code></pre></div>
<center>
<div>
<style scoped>
.dataframe tbody tr th:only-of-type {
vertical-align: middle;
}

.dataframe tbody tr th {
vertical-align: top;
}

.dataframe thead th {
text-align: right;
}
</style>
<table border="1" class="dataframe">
<thead>
<tr style="text-align: right;">
<th>
</th>
<th>
Date
</th>
<th>
Type
</th>
<th>
Country
</th>
<th>
State
</th>
<th>
Location
</th>
<th>
Fatal (Y/N)
</th>
<th>
Year
</th>
</tr>
<tr>
<th>
Case Number
</th>
<th>
</th>
<th>
</th>
<th>
</th>
<th>
</th>
<th>
</th>
<th>
</th>
<th>
</th>
</tr>
</thead>
<tbody>
<tr>
<th>
2020.12.30
</th>
<td>
2020-12-30
</td>
<td>
Unprovoked
</td>
<td>
USA
</td>
<td>
California
</td>
<td>
Coronado, San Diego County
</td>
<td>
N
</td>
<td>
2020
</td>
</tr>
<tr>
<th>
2020.12.08
</th>
<td>
2020-12-08
</td>
<td>
Unprovoked
</td>
<td>
USA
</td>
<td>
Hawaii
</td>
<td>
Honolua Bay
</td>
<td>
Y
</td>
<td>
2020
</td>
</tr>
<tr>
<th>
2020.12.06.b
</th>
<td>
2020-12-06
</td>
<td>
Unprovoked
</td>
<td>
USA
</td>
<td>
Oregon
</td>
<td>
Seaside Cove, Clatsop County
</td>
<td>
N
</td>
<td>
2020
</td>
</tr>
<tr>
<th>
2020.11.26
</th>
<td>
2020-11-26
</td>
<td>
Unprovoked
</td>
<td>
USA
</td>
<td>
Hawaii
</td>
<td>
Maui
</td>
<td>
N
</td>
<td>
2020
</td>
</tr>
<tr>
<th>
2020.10.31
</th>
<td>
2020-10-31
</td>
<td>
Unprovoked
</td>
<td>
USA
</td>
<td>
Florida
</td>
<td>
Ormond Beach
</td>
<td>
N
</td>
<td>
2020
</td>
</tr>
</tbody>
</table>
</div>
</center>
<p><br></p>
<div class="sourceCode" id="cb28"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a>df.tail()</span></code></pre></div>
<center>
<div>
<style scoped>
.dataframe tbody tr th:only-of-type {
vertical-align: middle;
}

.dataframe tbody tr th {
vertical-align: top;
}

.dataframe thead th {
text-align: right;
}
</style>
<table border="1" class="dataframe">
<thead>
<tr style="text-align: right;">
<th>
</th>
<th>
Date
</th>
<th>
Type
</th>
<th>
Country
</th>
<th>
State
</th>
<th>
Location
</th>
<th>
Fatal (Y/N)
</th>
<th>
Year
</th>
</tr>
<tr>
<th>
Case Number
</th>
<th>
</th>
<th>
</th>
<th>
</th>
<th>
</th>
<th>
</th>
<th>
</th>
<th>
</th>
</tr>
</thead>
<tbody>
<tr>
<th>
1904.00.00.a
</th>
<td>
1970-01-01 00:00:00.000001904
</td>
<td>
Unprovoked
</td>
<td>
USA
</td>
<td>
Hawaii
</td>
<td>
Off Diamond Head, Honolulu, O’ahu
</td>
<td>
Y
</td>
<td>
1970
</td>
</tr>
<tr>
<th>
1896.00.00.b
</th>
<td>
1970-01-01 00:00:00.000001896
</td>
<td>
Unprovoked
</td>
<td>
USA
</td>
<td>
Florida
</td>
<td>
NaN
</td>
<td>
Y
</td>
<td>
1970
</td>
</tr>
<tr>
<th>
1883.00.00.a
</th>
<td>
1970-01-01 00:00:00.000001883
</td>
<td>
Unprovoked
</td>
<td>
USA
</td>
<td>
South Carolina
</td>
<td>
NaN
</td>
<td>
Y
</td>
<td>
1970
</td>
</tr>
<tr>
<th>
1882.00.00.b
</th>
<td>
1970-01-01 00:00:00.000001882
</td>
<td>
Unprovoked
</td>
<td>
USA
</td>
<td>
Florida
</td>
<td>
In the bay near the naval yard at Pensacola, E…
</td>
<td>
N
</td>
<td>
1970
</td>
</tr>
<tr>
<th>
1852.00.00
</th>
<td>
1970-01-01 00:00:00.000001852
</td>
<td>
Unprovoked
</td>
<td>
USA
</td>
<td>
South Carolina
</td>
<td>
Mount Pleasant, Charleston County
</td>
<td>
Y
</td>
<td>
1970
</td>
</tr>
</tbody>
</table>
</div>
</center>
<p><br></p>
<div class="sourceCode" id="cb29"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a>df.shape</span></code></pre></div>
<pre><code>(1514, 7)</code></pre>
<p>After applying these filters, just over 1,500 attacks remain. This analysis will focus on the number of shark attacks in a state in a given year. Subsequent posts may analyze other aspects of this data. First we count the number of attacks in a given state in a given year. (We will shorten the phrase “unprovoked shark attacks in the United States between 1960 and 2020” to “attacks” for the remainder of the post.)</p>
<div class="sourceCode" id="cb31"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a>attacks_nz <span class="op">=</span> (df.groupby([<span class="st">&quot;State&quot;</span>, <span class="st">&quot;Year&quot;</span>])</span>
<span id="cb31-2"><a href="#cb31-2" aria-hidden="true" tabindex="-1"></a>                .size()</span>
<span id="cb31-3"><a href="#cb31-3" aria-hidden="true" tabindex="-1"></a>                .rename(<span class="st">&quot;Attacks&quot;</span>))</span></code></pre></div>
<div class="sourceCode" id="cb32"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a>attacks_nz.describe()</span></code></pre></div>
<pre><code>count    333.000000
mean       4.546547
std        6.527174
min        1.000000
25%        1.000000
50%        2.000000
75%        5.000000
max       38.000000
Name: Attacks, dtype: float64</code></pre>
<p>The series <code>attacks_nz</code> includes a row only when there was at least one attack in that state in that year. We also want to include zero entries for state/year combinations that saw now attacks, which we do now by reindexing <code>attacks_nz</code>.</p>
<div class="sourceCode" id="cb34"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a>attacks_index <span class="op">=</span> (pd.MultiIndex.from_product((</span>
<span id="cb34-2"><a href="#cb34-2" aria-hidden="true" tabindex="-1"></a>                        attacks_nz.index</span>
<span id="cb34-3"><a href="#cb34-3" aria-hidden="true" tabindex="-1"></a>                                  .get_level_values(<span class="st">&quot;State&quot;</span>)</span>
<span id="cb34-4"><a href="#cb34-4" aria-hidden="true" tabindex="-1"></a>                                  .unique(),</span>
<span id="cb34-5"><a href="#cb34-5" aria-hidden="true" tabindex="-1"></a>                        YEAR_RANGE[<span class="dv">0</span>] <span class="op">+</span> np.arange(attacks_nz.index</span>
<span id="cb34-6"><a href="#cb34-6" aria-hidden="true" tabindex="-1"></a>                                                            .get_level_values(<span class="st">&quot;Year&quot;</span>)</span>
<span id="cb34-7"><a href="#cb34-7" aria-hidden="true" tabindex="-1"></a>                                                            .values</span>
<span id="cb34-8"><a href="#cb34-8" aria-hidden="true" tabindex="-1"></a>                                                            .ptp())))</span>
<span id="cb34-9"><a href="#cb34-9" aria-hidden="true" tabindex="-1"></a>                   .rename(<span class="st">&quot;Year&quot;</span>, level<span class="op">=</span><span class="dv">1</span>))</span>
<span id="cb34-10"><a href="#cb34-10" aria-hidden="true" tabindex="-1"></a>attacks_df <span class="op">=</span> (attacks_nz.reindex(attacks_index, fill_value<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb34-11"><a href="#cb34-11" aria-hidden="true" tabindex="-1"></a>                        .astype(np.int64)</span>
<span id="cb34-12"><a href="#cb34-12" aria-hidden="true" tabindex="-1"></a>                        .to_frame())</span></code></pre></div>
<div class="sourceCode" id="cb35"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true" tabindex="-1"></a>attacks_df.head()</span></code></pre></div>
<div>
<style scoped>
.dataframe tbody tr th:only-of-type {
vertical-align: middle;
}

.dataframe tbody tr th {
vertical-align: top;
}

.dataframe thead th {
text-align: right;
}
</style>
<table border="1" class="dataframe">
<thead>
<tr style="text-align: right;">
<th>
</th>
<th>
</th>
<th>
Attacks
</th>
</tr>
<tr>
<th>
State
</th>
<th>
Year
</th>
<th>
</th>
</tr>
</thead>
<tbody>
<tr>
<th rowspan="5" valign="top">
Alabama
</th>
<th>
1960
</th>
<td>
0
</td>
</tr>
<tr>
<th>
1961
</th>
<td>
0
</td>
</tr>
<tr>
<th>
1962
</th>
<td>
0
</td>
</tr>
<tr>
<th>
1963
</th>
<td>
0
</td>
</tr>
<tr>
<th>
1964
</th>
<td>
0
</td>
</tr>
</tbody>
</table>
</div>
</center>
<p><br></p>
<div class="sourceCode" id="cb36"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true" tabindex="-1"></a>attacks_df.tail()</span></code></pre></div>
<center>
<div>
<style scoped>
.dataframe tbody tr th:only-of-type {
vertical-align: middle;
}

.dataframe tbody tr th {
vertical-align: top;
}

.dataframe thead th {
text-align: right;
}
</style>
<table border="1" class="dataframe">
<thead>
<tr style="text-align: right;">
<th>
</th>
<th>
</th>
<th>
Attacks
</th>
</tr>
<tr>
<th>
State
</th>
<th>
Year
</th>
<th>
</th>
</tr>
</thead>
<tbody>
<tr>
<th rowspan="5" valign="top">
Washington
</th>
<th>
2015
</th>
<td>
0
</td>
</tr>
<tr>
<th>
2016
</th>
<td>
0
</td>
</tr>
<tr>
<th>
2017
</th>
<td>
1
</td>
</tr>
<tr>
<th>
2018
</th>
<td>
0
</td>
</tr>
<tr>
<th>
2019
</th>
<td>
0
</td>
</tr>
</tbody>
</table>
</div>
</center>
<p><br></p>
<h2 id="modeling">Modeling</h2>
<p>We now turn to modeling the data.</p>
<div class="sourceCode" id="cb37"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true" tabindex="-1"></a>ax <span class="op">=</span> attacks_df[<span class="st">&quot;Attacks&quot;</span>].hist(bins<span class="op">=</span>attacks_df[<span class="st">&quot;Attacks&quot;</span>].<span class="bu">max</span>() <span class="op">+</span> <span class="dv">1</span>)</span>
<span id="cb37-2"><a href="#cb37-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-3"><a href="#cb37-3" aria-hidden="true" tabindex="-1"></a>ax.set_xlabel(<span class="st">&quot;Number of attacks&quot;</span>)<span class="op">;</span></span>
<span id="cb37-4"><a href="#cb37-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-5"><a href="#cb37-5" aria-hidden="true" tabindex="-1"></a>ax.set_yscale(<span class="st">&#39;log&#39;</span>)<span class="op">;</span></span>
<span id="cb37-6"><a href="#cb37-6" aria-hidden="true" tabindex="-1"></a>ax.set_ylabel(<span class="st">&quot;Number of state-years&quot;</span>)<span class="op">;</span></span></code></pre></div>
<center>
<img src="/resources/sharks_pycm3_files/sharks_pycm3_46_0.png" title="fig:" alt="png" />
</center>
<p>We see that the vast majority of state-years have no shark attacks, and that when there is at least one attack, there are rarely very many. We see that the <a href="https://en.wikipedia.org/wiki/Index_of_dispersion">index of dispersion</a> is significantly larger than one, so the data shows overdispersion.</p>
<div class="sourceCode" id="cb38"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb38-1"><a href="#cb38-1" aria-hidden="true" tabindex="-1"></a>attacks_df.var() <span class="op">/</span> attacks_df.mean()</span></code></pre></div>
<pre><code>Attacks    12.729978
dtype: float64</code></pre>
<h3 id="negative-binomial">Negative Binomial</h3>
<p>Due to this overdispersion, we begin with a <a href="https://en.wikipedia.org/wiki/Negative_binomial_distribution">Negative Binomial</a> model.</p>
<p>Let <span class="math inline">\(y_{i, t}\)</span> represent the number of attacks in the <span class="math inline">\(i\)</span>-th state in year <span class="math inline">\(t\)</span>. We use the priors</p>
<p><span class="math display">\[ 
\begin{align*}
    \mu
        &amp; \sim \operatorname{Lognormal}(0, 2.5^2) \\
    \alpha
        &amp; \sim \operatorname{Half}-N(2.5^2).
\end{align*}
\]</span></p>
<div class="sourceCode" id="cb40"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb40-1"><a href="#cb40-1" aria-hidden="true" tabindex="-1"></a><span class="cf">with</span> pm.Model() <span class="im">as</span> nb_model:</span>
<span id="cb40-2"><a href="#cb40-2" aria-hidden="true" tabindex="-1"></a>    μ <span class="op">=</span> pm.Lognormal(<span class="st">&quot;μ&quot;</span>, <span class="fl">0.</span>, <span class="fl">2.5</span>)</span>
<span id="cb40-3"><a href="#cb40-3" aria-hidden="true" tabindex="-1"></a>    α <span class="op">=</span> pm.HalfNormal(<span class="st">&quot;α&quot;</span>, <span class="fl">2.5</span>)</span></code></pre></div>
<p>We now let <span class="math inline">\(y_{i, t} \sim NB(\mu, \alpha)\)</span></p>
<div class="sourceCode" id="cb41"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb41-1"><a href="#cb41-1" aria-hidden="true" tabindex="-1"></a>y <span class="op">=</span> attacks_df[<span class="st">&quot;Attacks&quot;</span>].values</span></code></pre></div>
<div class="sourceCode" id="cb42"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb42-1"><a href="#cb42-1" aria-hidden="true" tabindex="-1"></a><span class="cf">with</span> nb_model:</span>
<span id="cb42-2"><a href="#cb42-2" aria-hidden="true" tabindex="-1"></a>    obs <span class="op">=</span> pm.NegativeBinomial(<span class="st">&quot;obs&quot;</span>, μ, α, observed<span class="op">=</span>y)</span></code></pre></div>
<p>We use <a href="https://docs.pymc.io/"><code>pymc3</code></a> to sample from the posterior distribution of this model.</p>
<div class="sourceCode" id="cb43"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb43-1"><a href="#cb43-1" aria-hidden="true" tabindex="-1"></a>CHAINS <span class="op">=</span> <span class="dv">3</span></span>
<span id="cb43-2"><a href="#cb43-2" aria-hidden="true" tabindex="-1"></a>SEED <span class="op">=</span> <span class="dv">12345</span></span>
<span id="cb43-3"><a href="#cb43-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb43-4"><a href="#cb43-4" aria-hidden="true" tabindex="-1"></a>SAMPLE_KWARGS <span class="op">=</span> {</span>
<span id="cb43-5"><a href="#cb43-5" aria-hidden="true" tabindex="-1"></a>    <span class="st">&#39;cores&#39;</span>: CHAINS,</span>
<span id="cb43-6"><a href="#cb43-6" aria-hidden="true" tabindex="-1"></a>    <span class="st">&#39;random_seed&#39;</span>: [SEED <span class="op">+</span> i <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(CHAINS)],</span>
<span id="cb43-7"><a href="#cb43-7" aria-hidden="true" tabindex="-1"></a>    <span class="st">&#39;return_inferencedata&#39;</span>: <span class="va">True</span></span>
<span id="cb43-8"><a href="#cb43-8" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<div class="sourceCode" id="cb44"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb44-1"><a href="#cb44-1" aria-hidden="true" tabindex="-1"></a><span class="cf">with</span> nb_model:</span>
<span id="cb44-2"><a href="#cb44-2" aria-hidden="true" tabindex="-1"></a>    nb_trace <span class="op">=</span> pm.sample(<span class="op">**</span>SAMPLE_KWARGS)</span></code></pre></div>
<pre><code>Auto-assigning NUTS sampler...
Initializing NUTS using jitter+adapt_diag...
Multiprocess sampling (3 chains in 3 jobs)
NUTS: [μ, α]</code></pre>
<div>
<style>
/* Turns off some styling */
progress {
/* gets rid of default border in Firefox and Opera. */
border: none;
/* Needs to be in here for Safari polyfill so background images work as expected. */
background-size: auto;
}
.progress-bar-interrupted, .progress-bar-interrupted::-webkit-progress-bar {
background: #F44336;
}
</style>
<progress value="6000" class max="6000" style="width:300px; height:20px; vertical-align: middle;">
</progress>
<p>100.00% [6000/6000 00:15&lt;00:00 Sampling 3 chains, 0 divergences]</p>
</div>
<pre><code>Sampling 3 chains for 1_000 tune and 1_000 draw iterations (3_000 + 3_000 draws total) took 20 seconds.</code></pre>
<p>The standard sampling diagnostics (energy plots, BFMI, and <span class="math inline">\(\hat{R}\)</span>) show no cause for concern.</p>
<div class="sourceCode" id="cb47"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb47-1"><a href="#cb47-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> make_diagnostic_plots(trace, axes<span class="op">=</span><span class="va">None</span>, min_mult<span class="op">=</span><span class="fl">0.995</span>, max_mult<span class="op">=</span><span class="fl">1.005</span>):</span>
<span id="cb47-2"><a href="#cb47-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> axes <span class="kw">is</span> <span class="va">None</span>:</span>
<span id="cb47-3"><a href="#cb47-3" aria-hidden="true" tabindex="-1"></a>        fig, axes <span class="op">=</span> plt.subplots(ncols<span class="op">=</span><span class="dv">2</span>,</span>
<span id="cb47-4"><a href="#cb47-4" aria-hidden="true" tabindex="-1"></a>                                 sharex<span class="op">=</span><span class="va">False</span>, sharey<span class="op">=</span><span class="va">False</span>,</span>
<span id="cb47-5"><a href="#cb47-5" aria-hidden="true" tabindex="-1"></a>                                 figsize<span class="op">=</span>(<span class="dv">16</span>, <span class="dv">6</span>))</span>
<span id="cb47-6"><a href="#cb47-6" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb47-7"><a href="#cb47-7" aria-hidden="true" tabindex="-1"></a>    az.plot_energy(trace, ax<span class="op">=</span>axes[<span class="dv">0</span>])</span>
<span id="cb47-8"><a href="#cb47-8" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb47-9"><a href="#cb47-9" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb47-10"><a href="#cb47-10" aria-hidden="true" tabindex="-1"></a>    rhat <span class="op">=</span> az.rhat(trace).<span class="bu">max</span>()</span>
<span id="cb47-11"><a href="#cb47-11" aria-hidden="true" tabindex="-1"></a>    axes[<span class="dv">1</span>].barh(np.arange(<span class="bu">len</span>(rhat.variables)), rhat.to_array(),</span>
<span id="cb47-12"><a href="#cb47-12" aria-hidden="true" tabindex="-1"></a>                 tick_label<span class="op">=</span><span class="bu">list</span>(rhat.variables.keys()))</span>
<span id="cb47-13"><a href="#cb47-13" aria-hidden="true" tabindex="-1"></a>    axes[<span class="dv">1</span>].axvline(<span class="dv">1</span>, c<span class="op">=</span><span class="st">&#39;k&#39;</span>, ls<span class="op">=</span><span class="st">&#39;--&#39;</span>)</span>
<span id="cb47-14"><a href="#cb47-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb47-15"><a href="#cb47-15" aria-hidden="true" tabindex="-1"></a>    axes[<span class="dv">1</span>].set_xlim(</span>
<span id="cb47-16"><a href="#cb47-16" aria-hidden="true" tabindex="-1"></a>        min_mult <span class="op">*</span> <span class="bu">min</span>(rhat.<span class="bu">min</span>().to_array().<span class="bu">min</span>(), <span class="dv">1</span>),</span>
<span id="cb47-17"><a href="#cb47-17" aria-hidden="true" tabindex="-1"></a>        max_mult <span class="op">*</span> <span class="bu">max</span>(rhat.<span class="bu">max</span>().to_array().<span class="bu">max</span>(), <span class="dv">1</span>)</span>
<span id="cb47-18"><a href="#cb47-18" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb47-19"><a href="#cb47-19" aria-hidden="true" tabindex="-1"></a>    axes[<span class="dv">1</span>].set_xlabel(<span class="vs">r&quot;$\hat</span><span class="sc">{R}</span><span class="vs">$&quot;</span>)</span>
<span id="cb47-20"><a href="#cb47-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb47-21"><a href="#cb47-21" aria-hidden="true" tabindex="-1"></a>    axes[<span class="dv">1</span>].set_ylabel(<span class="st">&quot;Variable&quot;</span>)</span>
<span id="cb47-22"><a href="#cb47-22" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb47-23"><a href="#cb47-23" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> fig, axes</span></code></pre></div>
<div class="sourceCode" id="cb48"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb48-1"><a href="#cb48-1" aria-hidden="true" tabindex="-1"></a>make_diagnostic_plots(nb_trace)<span class="op">;</span></span></code></pre></div>
<center>
<img src="/resources/sharks_pycm3_files/sharks_pycm3_59_0.png" title="fig:" alt="png" />
</center>
<p>Examining the posterior distribution for <span class="math inline">\(\mu\)</span> shows that the model will predicts more than one shark attack per year on average.</p>
<div class="sourceCode" id="cb49"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb49-1"><a href="#cb49-1" aria-hidden="true" tabindex="-1"></a>az.plot_posterior(nb_trace, var_names<span class="op">=</span>[<span class="st">&quot;μ&quot;</span>])<span class="op">;</span></span></code></pre></div>
<center>
<img src="/resources/sharks_pycm3_files/sharks_pycm3_61_0.png" title="fig:" alt="png" />
</center>
<p>This prediction of about one shark attack per state per year captures nationwide average well enough, but is clearly not very useful at the state level. We see specifically how bad it is by examining the posterior predictions of the model.</p>
<div class="sourceCode" id="cb50"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb50-1"><a href="#cb50-1" aria-hidden="true" tabindex="-1"></a><span class="cf">with</span> nb_model:</span>
<span id="cb50-2"><a href="#cb50-2" aria-hidden="true" tabindex="-1"></a>    nb_pp_trace <span class="op">=</span> pm.sample_posterior_predictive(nb_trace)</span></code></pre></div>
<div>
<style>
/* Turns off some styling */
progress {
/* gets rid of default border in Firefox and Opera. */
border: none;
/* Needs to be in here for Safari polyfill so background images work as expected. */
background-size: auto;
}
.progress-bar-interrupted, .progress-bar-interrupted::-webkit-progress-bar {
background: #F44336;
}
</style>
<progress value="3000" class max="3000" style="width:300px; height:20px; vertical-align: middle;">
</progress>
<p>100.00% [3000/3000 00:05&lt;00:00]</p>
</div>
<p>First we produce a long data frame where each row represents a single posterior predictive sample from the distribution of the number of attacks in a given state-year. This data frame will be the basis for all of our posterior predictive plots.</p>
<div class="sourceCode" id="cb51"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb51-1"><a href="#cb51-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> make_pp_full_df(pp_obs):</span>
<span id="cb51-2"><a href="#cb51-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> (pd.DataFrame(</span>
<span id="cb51-3"><a href="#cb51-3" aria-hidden="true" tabindex="-1"></a>                {i: samples <span class="cf">for</span> i, samples <span class="kw">in</span> <span class="bu">enumerate</span>(pp_obs)},</span>
<span id="cb51-4"><a href="#cb51-4" aria-hidden="true" tabindex="-1"></a>                index<span class="op">=</span>attacks_df.index</span>
<span id="cb51-5"><a href="#cb51-5" aria-hidden="true" tabindex="-1"></a>              )</span>
<span id="cb51-6"><a href="#cb51-6" aria-hidden="true" tabindex="-1"></a>              .reset_index()</span>
<span id="cb51-7"><a href="#cb51-7" aria-hidden="true" tabindex="-1"></a>              .melt(id_vars<span class="op">=</span>[<span class="st">&quot;State&quot;</span>, <span class="st">&quot;Year&quot;</span>],</span>
<span id="cb51-8"><a href="#cb51-8" aria-hidden="true" tabindex="-1"></a>                    var_name<span class="op">=</span><span class="st">&quot;Sample&quot;</span>)</span>
<span id="cb51-9"><a href="#cb51-9" aria-hidden="true" tabindex="-1"></a>              .set_index([<span class="st">&quot;State&quot;</span>, <span class="st">&quot;Year&quot;</span>, <span class="st">&quot;Sample&quot;</span>]))</span></code></pre></div>
<div class="sourceCode" id="cb52"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb52-1"><a href="#cb52-1" aria-hidden="true" tabindex="-1"></a>nb_pp_full_df <span class="op">=</span> make_pp_full_df(nb_pp_trace[<span class="st">&quot;obs&quot;</span>])</span></code></pre></div>
<div class="sourceCode" id="cb53"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb53-1"><a href="#cb53-1" aria-hidden="true" tabindex="-1"></a>nb_pp_full_df.head()</span></code></pre></div>
<center>
<div>
<style scoped>
.dataframe tbody tr th:only-of-type {
vertical-align: middle;
}

.dataframe tbody tr th {
vertical-align: top;
}

.dataframe thead th {
text-align: right;
}
</style>
<table border="1" class="dataframe">
<thead>
<tr style="text-align: right;">
<th>
</th>
<th>
</th>
<th>
</th>
<th>
value
</th>
</tr>
<tr>
<th>
State
</th>
<th>
Year
</th>
<th>
Sample
</th>
<th>
</th>
</tr>
</thead>
<tbody>
<tr>
<th rowspan="5" valign="top">
Alabama
</th>
<th>
1960
</th>
<th>
0
</th>
<td>
1
</td>
</tr>
<tr>
<th>
1961
</th>
<th>
0
</th>
<td>
0
</td>
</tr>
<tr>
<th>
1962
</th>
<th>
0
</th>
<td>
0
</td>
</tr>
<tr>
<th>
1963
</th>
<th>
0
</th>
<td>
0
</td>
</tr>
<tr>
<th>
1964
</th>
<th>
0
</th>
<td>
0
</td>
</tr>
</tbody>
</table>
</div>
</center>
<p><br></p>
<div class="sourceCode" id="cb54"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb54-1"><a href="#cb54-1" aria-hidden="true" tabindex="-1"></a>ALPHA <span class="op">=</span> <span class="fl">0.05</span></span></code></pre></div>
<div class="sourceCode" id="cb55"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb55-1"><a href="#cb55-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> summarize_pp_df(pp_full_df, level<span class="op">=</span><span class="va">None</span>, alpha<span class="op">=</span>ALPHA):</span>
<span id="cb55-2"><a href="#cb55-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> level <span class="kw">is</span> <span class="va">None</span>:</span>
<span id="cb55-3"><a href="#cb55-3" aria-hidden="true" tabindex="-1"></a>        level <span class="op">=</span> [<span class="st">&quot;State&quot;</span>, <span class="st">&quot;Year&quot;</span>]</span>
<span id="cb55-4"><a href="#cb55-4" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb55-5"><a href="#cb55-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> (pp_full_df.groupby(level<span class="op">=</span>level)</span>
<span id="cb55-6"><a href="#cb55-6" aria-hidden="true" tabindex="-1"></a>                      [<span class="st">&quot;value&quot;</span>]</span>
<span id="cb55-7"><a href="#cb55-7" aria-hidden="true" tabindex="-1"></a>                      .agg(</span>
<span id="cb55-8"><a href="#cb55-8" aria-hidden="true" tabindex="-1"></a>                          mean<span class="op">=</span><span class="st">&#39;mean&#39;</span>,</span>
<span id="cb55-9"><a href="#cb55-9" aria-hidden="true" tabindex="-1"></a>                          <span class="bu">sum</span><span class="op">=</span><span class="st">&#39;sum&#39;</span>,</span>
<span id="cb55-10"><a href="#cb55-10" aria-hidden="true" tabindex="-1"></a>                          low<span class="op">=</span><span class="kw">lambda</span> s: s.quantile(alpha <span class="op">/</span> <span class="fl">2.</span>),</span>
<span id="cb55-11"><a href="#cb55-11" aria-hidden="true" tabindex="-1"></a>                          high<span class="op">=</span><span class="kw">lambda</span> s: s.quantile(<span class="fl">1.</span> <span class="op">-</span> alpha <span class="op">/</span> <span class="fl">2.</span>),</span>
<span id="cb55-12"><a href="#cb55-12" aria-hidden="true" tabindex="-1"></a>                      )</span>
<span id="cb55-13"><a href="#cb55-13" aria-hidden="true" tabindex="-1"></a>                      .assign(attacks<span class="op">=</span>attacks_df[<span class="st">&quot;Attacks&quot;</span>]</span>
<span id="cb55-14"><a href="#cb55-14" aria-hidden="true" tabindex="-1"></a>                                                .groupby(level<span class="op">=</span>level)</span>
<span id="cb55-15"><a href="#cb55-15" aria-hidden="true" tabindex="-1"></a>                                                .<span class="bu">sum</span>()))</span></code></pre></div>
<div class="sourceCode" id="cb56"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb56-1"><a href="#cb56-1" aria-hidden="true" tabindex="-1"></a>nb_pp_df <span class="op">=</span> summarize_pp_df(nb_pp_full_df)</span></code></pre></div>
<div class="sourceCode" id="cb57"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb57-1"><a href="#cb57-1" aria-hidden="true" tabindex="-1"></a>nb_pp_df.head()</span></code></pre></div>
<center>
<div>
<style scoped>
.dataframe tbody tr th:only-of-type {
vertical-align: middle;
}

.dataframe tbody tr th {
vertical-align: top;
}

.dataframe thead th {
text-align: right;
}
</style>
<table border="1" class="dataframe">
<thead>
<tr style="text-align: right;">
<th>
</th>
<th>
</th>
<th>
mean
</th>
<th>
sum
</th>
<th>
low
</th>
<th>
high
</th>
<th>
attacks
</th>
</tr>
<tr>
<th>
State
</th>
<th>
Year
</th>
<th>
</th>
<th>
</th>
<th>
</th>
<th>
</th>
<th>
</th>
</tr>
</thead>
<tbody>
<tr>
<th rowspan="5" valign="top">
Alabama
</th>
<th>
1960
</th>
<td>
1.231000
</td>
<td>
3693
</td>
<td>
0
</td>
<td>
12.000
</td>
<td>
0
</td>
</tr>
<tr>
<th>
1961
</th>
<td>
1.212667
</td>
<td>
3638
</td>
<td>
0
</td>
<td>
12.000
</td>
<td>
0
</td>
</tr>
<tr>
<th>
1962
</th>
<td>
1.206000
</td>
<td>
3618
</td>
<td>
0
</td>
<td>
11.025
</td>
<td>
0
</td>
</tr>
<tr>
<th>
1963
</th>
<td>
1.232000
</td>
<td>
3696
</td>
<td>
0
</td>
<td>
12.000
</td>
<td>
0
</td>
</tr>
<tr>
<th>
1964
</th>
<td>
1.177667
</td>
<td>
3533
</td>
<td>
0
</td>
<td>
11.000
</td>
<td>
0
</td>
</tr>
</tbody>
</table>
</div>
</center>
<p><br></p>
<p>The data frame <code>nb_pp_df</code> contains the posterior predictive mean and posterior predictive quantiles for each state-year combination. We now plot the predictions and actual data, broken down by state.</p>
<div class="sourceCode" id="cb58"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb58-1"><a href="#cb58-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> plot_pp_over_time(data<span class="op">=</span><span class="va">None</span>, y<span class="op">=</span><span class="st">&quot;mean&quot;</span>, <span class="op">*</span>args, <span class="op">**</span>kwargs):</span>
<span id="cb58-2"><a href="#cb58-2" aria-hidden="true" tabindex="-1"></a>    pp_df <span class="op">=</span> data</span>
<span id="cb58-3"><a href="#cb58-3" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb58-4"><a href="#cb58-4" aria-hidden="true" tabindex="-1"></a>    ax <span class="op">=</span> plt.gca()</span>
<span id="cb58-5"><a href="#cb58-5" aria-hidden="true" tabindex="-1"></a>    (pp_df.plot(<span class="st">&quot;Year&quot;</span>, y,</span>
<span id="cb58-6"><a href="#cb58-6" aria-hidden="true" tabindex="-1"></a>                c<span class="op">=</span><span class="st">&#39;k&#39;</span>, label<span class="op">=</span><span class="st">&quot;Posterior expected value&quot;</span>,</span>
<span id="cb58-7"><a href="#cb58-7" aria-hidden="true" tabindex="-1"></a>                ax<span class="op">=</span>ax))</span>
<span id="cb58-8"><a href="#cb58-8" aria-hidden="true" tabindex="-1"></a>    (pp_df.reset_index()</span>
<span id="cb58-9"><a href="#cb58-9" aria-hidden="true" tabindex="-1"></a>          .plot(<span class="st">&quot;Year&quot;</span>, <span class="st">&quot;attacks&quot;</span>,</span>
<span id="cb58-10"><a href="#cb58-10" aria-hidden="true" tabindex="-1"></a>                kind<span class="op">=</span><span class="st">&#39;scatter&#39;</span>, c<span class="op">=</span><span class="st">&#39;k&#39;</span>, zorder<span class="op">=</span><span class="dv">5</span>,</span>
<span id="cb58-11"><a href="#cb58-11" aria-hidden="true" tabindex="-1"></a>                label<span class="op">=</span><span class="st">&quot;Actual&quot;</span>, ax<span class="op">=</span>ax))</span>
<span id="cb58-12"><a href="#cb58-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-13"><a href="#cb58-13" aria-hidden="true" tabindex="-1"></a>    ax.fill_between(pp_df[<span class="st">&quot;Year&quot;</span>], pp_df[<span class="st">&quot;low&quot;</span>], pp_df[<span class="st">&quot;high&quot;</span>],</span>
<span id="cb58-14"><a href="#cb58-14" aria-hidden="true" tabindex="-1"></a>                    color<span class="op">=</span><span class="st">&#39;C0&#39;</span>, alpha<span class="op">=</span><span class="fl">0.5</span>,</span>
<span id="cb58-15"><a href="#cb58-15" aria-hidden="true" tabindex="-1"></a>                    label<span class="op">=</span><span class="st">&quot;95% posterior credible interval&quot;</span>)</span>
<span id="cb58-16"><a href="#cb58-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-17"><a href="#cb58-17" aria-hidden="true" tabindex="-1"></a>    ax.set_ylabel(<span class="st">&quot;Number of shark attacks&quot;</span>)</span>
<span id="cb58-18"><a href="#cb58-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-19"><a href="#cb58-19" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> ax</span></code></pre></div>
<div class="sourceCode" id="cb59"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb59-1"><a href="#cb59-1" aria-hidden="true" tabindex="-1"></a>grid <span class="op">=</span> sns.FacetGrid(nb_pp_df.reset_index(), col<span class="op">=</span><span class="st">&quot;State&quot;</span>,</span>
<span id="cb59-2"><a href="#cb59-2" aria-hidden="true" tabindex="-1"></a>                     col_wrap<span class="op">=</span><span class="dv">2</span>, sharey<span class="op">=</span><span class="va">False</span>, aspect<span class="op">=</span><span class="fl">1.5</span>)</span>
<span id="cb59-3"><a href="#cb59-3" aria-hidden="true" tabindex="-1"></a>grid.map_dataframe(plot_pp_over_time)<span class="op">;</span></span>
<span id="cb59-4"><a href="#cb59-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb59-5"><a href="#cb59-5" aria-hidden="true" tabindex="-1"></a>grid.axes[<span class="dv">0</span>].legend(loc<span class="op">=</span><span class="st">&quot;upper left&quot;</span>)<span class="op">;</span></span>
<span id="cb59-6"><a href="#cb59-6" aria-hidden="true" tabindex="-1"></a>grid.set_titles(<span class="st">&quot;</span><span class="sc">{col_name}</span><span class="st">&quot;</span>)<span class="op">;</span></span>
<span id="cb59-7"><a href="#cb59-7" aria-hidden="true" tabindex="-1"></a>grid.fig.tight_layout()<span class="op">;</span></span></code></pre></div>
<center>
<img src="/resources/sharks_pycm3_files/sharks_pycm3_74_0.png" title="fig:" alt="png" />
</center>
<p>We see that the predictions for each state are indeed the same (ignoring some slight Monte Carlo variation), and therefore vastly overpredict shark attacks for most states while massively underpredicting shark attacks for some states.</p>
<p>The plot below which does not include a time axis further reinforces this point.</p>
<div class="sourceCode" id="cb60"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb60-1"><a href="#cb60-1" aria-hidden="true" tabindex="-1"></a>nb_pp_state_df <span class="op">=</span> summarize_pp_df(nb_pp_full_df, level<span class="op">=</span><span class="st">&quot;State&quot;</span>)</span>
<span id="cb60-2"><a href="#cb60-2" aria-hidden="true" tabindex="-1"></a>ax <span class="op">=</span> (nb_pp_state_df.reset_index()</span>
<span id="cb60-3"><a href="#cb60-3" aria-hidden="true" tabindex="-1"></a>                    .plot.scatter(<span class="st">&quot;mean&quot;</span>, <span class="st">&quot;State&quot;</span>, color<span class="op">=</span><span class="st">&#39;C0&#39;</span>,</span>
<span id="cb60-4"><a href="#cb60-4" aria-hidden="true" tabindex="-1"></a>                                  xerr<span class="op">=</span>nb_pp_state_df[[<span class="st">&quot;low&quot;</span>, <span class="st">&quot;high&quot;</span>]]</span>
<span id="cb60-5"><a href="#cb60-5" aria-hidden="true" tabindex="-1"></a>                                                     .sub(nb_pp_state_df[<span class="st">&quot;mean&quot;</span>],</span>
<span id="cb60-6"><a href="#cb60-6" aria-hidden="true" tabindex="-1"></a>                                                          axis<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb60-7"><a href="#cb60-7" aria-hidden="true" tabindex="-1"></a>                                                     .<span class="bu">abs</span>()</span>
<span id="cb60-8"><a href="#cb60-8" aria-hidden="true" tabindex="-1"></a>                                                     .values.T,</span>
<span id="cb60-9"><a href="#cb60-9" aria-hidden="true" tabindex="-1"></a>                                  zorder<span class="op">=</span><span class="dv">5</span>,</span>
<span id="cb60-10"><a href="#cb60-10" aria-hidden="true" tabindex="-1"></a>                                  label<span class="op">=</span><span class="st">&quot;Posterior predictive mean&quot;</span>))</span>
<span id="cb60-11"><a href="#cb60-11" aria-hidden="true" tabindex="-1"></a>(attacks_df.reset_index()</span>
<span id="cb60-12"><a href="#cb60-12" aria-hidden="true" tabindex="-1"></a>           .plot.scatter(<span class="st">&quot;Attacks&quot;</span>, <span class="st">&quot;State&quot;</span>,</span>
<span id="cb60-13"><a href="#cb60-13" aria-hidden="true" tabindex="-1"></a>                         color<span class="op">=</span><span class="st">&#39;k&#39;</span>, alpha<span class="op">=</span><span class="fl">0.5</span>,</span>
<span id="cb60-14"><a href="#cb60-14" aria-hidden="true" tabindex="-1"></a>                         label<span class="op">=</span><span class="st">&quot;Actual&quot;</span>, ax<span class="op">=</span>ax))<span class="op">;</span></span>
<span id="cb60-15"><a href="#cb60-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb60-16"><a href="#cb60-16" aria-hidden="true" tabindex="-1"></a>ax.set_xlabel(<span class="st">&quot;Number of shark Attacks&quot;</span>)<span class="op">;</span></span>
<span id="cb60-17"><a href="#cb60-17" aria-hidden="true" tabindex="-1"></a>ax.invert_yaxis()<span class="op">;</span></span></code></pre></div>
<center>
<img src="/resources/sharks_pycm3_files/sharks_pycm3_76_0.png" title="fig:" alt="png" />
</center>
<p>The predictions from this model are particularly bad for states like California, Florida, Hawaii, and the Carolinas, where years with many shark attacks are relatively more common than they are for other states.</p>
<h3 id="negative-binomial-regression">Negative Binomial Regression</h3>
<p>California, Florida, and to a lesser extent the Carolinas are similar in that they have relatively large populations. All of these states are similar in that their population is relatively concentrated on the coast.</p>
<p>The table below shows that overdispersion is still quite prevalent when we condition on state, so will use <a href="https://en.wikipedia.org/wiki/Poisson_regression#Overdispersion_and_zero_inflation">negative binomial regression</a> to account for the effect of state-level factors on the number of attacks.</p>
<div class="sourceCode" id="cb61"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb61-1"><a href="#cb61-1" aria-hidden="true" tabindex="-1"></a>(attacks_df.groupby(level<span class="op">=</span><span class="st">&quot;State&quot;</span>)</span>
<span id="cb61-2"><a href="#cb61-2" aria-hidden="true" tabindex="-1"></a>           .var()</span>
<span id="cb61-3"><a href="#cb61-3" aria-hidden="true" tabindex="-1"></a>           .div(attacks_df.groupby(<span class="st">&quot;State&quot;</span>)</span>
<span id="cb61-4"><a href="#cb61-4" aria-hidden="true" tabindex="-1"></a>                          .mean()))</span></code></pre></div>
<center>
<div>
<style scoped>
.dataframe tbody tr th:only-of-type {
vertical-align: middle;
}

.dataframe tbody tr th {
vertical-align: top;
}

.dataframe thead th {
text-align: right;
}
</style>
<table border="1" class="dataframe">
<thead>
<tr style="text-align: right;">
<th>
</th>
<th>
Attacks
</th>
</tr>
<tr>
<th>
State
</th>
<th>
</th>
</tr>
</thead>
<tbody>
<tr>
<th>
Alabama
</th>
<td>
1.090395
</td>
</tr>
<tr>
<th>
California
</th>
<td>
1.408464
</td>
</tr>
<tr>
<th>
Connecticut
</th>
<td>
1.000000
</td>
</tr>
<tr>
<th>
Delaware
</th>
<td>
0.966102
</td>
</tr>
<tr>
<th>
Florida
</th>
<td>
8.373881
</td>
</tr>
<tr>
<th>
Georgia
</th>
<td>
1.090395
</td>
</tr>
<tr>
<th>
Hawaii
</th>
<td>
3.457544
</td>
</tr>
<tr>
<th>
Louisiana
</th>
<td>
0.915254
</td>
</tr>
<tr>
<th>
Maine
</th>
<td>
1.000000
</td>
</tr>
<tr>
<th>
Massachusetts
</th>
<td>
1.254237
</td>
</tr>
<tr>
<th>
Mississippi
</th>
<td>
1.000000
</td>
</tr>
<tr>
<th>
New Jersey
</th>
<td>
1.457627
</td>
</tr>
<tr>
<th>
New York
</th>
<td>
2.000000
</td>
</tr>
<tr>
<th>
North Carolina
</th>
<td>
2.342930
</td>
</tr>
<tr>
<th>
Oregon
</th>
<td>
1.156634
</td>
</tr>
<tr>
<th>
Rhode Island
</th>
<td>
1.000000
</td>
</tr>
<tr>
<th>
South Carolina
</th>
<td>
2.382694
</td>
</tr>
<tr>
<th>
Texas
</th>
<td>
1.917465
</td>
</tr>
<tr>
<th>
Virginia
</th>
<td>
0.881356
</td>
</tr>
<tr>
<th>
Washington
</th>
<td>
0.983051
</td>
</tr>
</tbody>
</table>
</div>
</center>
<p><br></p>
<p>First we load state-leve population and coastline data from Wikipedia.</p>
<div class="sourceCode" id="cb62"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb62-1"><a href="#cb62-1" aria-hidden="true" tabindex="-1"></a>POP_URL <span class="op">=</span> <span class="st">&quot;https://en.wikipedia.org/wiki/List_of_U.S._states_and_territories_by_historical_population&quot;</span></span>
<span id="cb62-2"><a href="#cb62-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb62-3"><a href="#cb62-3" aria-hidden="true" tabindex="-1"></a>population <span class="op">=</span> (pd.read_html(POP_URL)[<span class="dv">3</span>]</span>
<span id="cb62-4"><a href="#cb62-4" aria-hidden="true" tabindex="-1"></a>                .iloc[:<span class="op">-</span><span class="dv">1</span>]</span>
<span id="cb62-5"><a href="#cb62-5" aria-hidden="true" tabindex="-1"></a>                .melt(id_vars<span class="op">=</span><span class="st">&quot;Name&quot;</span>,</span>
<span id="cb62-6"><a href="#cb62-6" aria-hidden="true" tabindex="-1"></a>                      var_name<span class="op">=</span><span class="st">&quot;Year&quot;</span>,</span>
<span id="cb62-7"><a href="#cb62-7" aria-hidden="true" tabindex="-1"></a>                      value_name<span class="op">=</span><span class="st">&quot;Population&quot;</span>)</span>
<span id="cb62-8"><a href="#cb62-8" aria-hidden="true" tabindex="-1"></a>                .rename(columns<span class="op">=</span>{<span class="st">&quot;Name&quot;</span>: <span class="st">&quot;State&quot;</span>})</span>
<span id="cb62-9"><a href="#cb62-9" aria-hidden="true" tabindex="-1"></a>                .fillna(<span class="dv">0</span>)</span>
<span id="cb62-10"><a href="#cb62-10" aria-hidden="true" tabindex="-1"></a>                .astype({</span>
<span id="cb62-11"><a href="#cb62-11" aria-hidden="true" tabindex="-1"></a>                    <span class="st">&quot;Year&quot;</span>: np.int64,</span>
<span id="cb62-12"><a href="#cb62-12" aria-hidden="true" tabindex="-1"></a>                    <span class="st">&quot;Population&quot;</span>: np.float64</span>
<span id="cb62-13"><a href="#cb62-13" aria-hidden="true" tabindex="-1"></a>                })</span>
<span id="cb62-14"><a href="#cb62-14" aria-hidden="true" tabindex="-1"></a>                .set_index([<span class="st">&quot;State&quot;</span>, <span class="st">&quot;Year&quot;</span>])</span>
<span id="cb62-15"><a href="#cb62-15" aria-hidden="true" tabindex="-1"></a>                .sort_index()</span>
<span id="cb62-16"><a href="#cb62-16" aria-hidden="true" tabindex="-1"></a>                [<span class="st">&quot;Population&quot;</span>])</span></code></pre></div>
<div class="sourceCode" id="cb63"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb63-1"><a href="#cb63-1" aria-hidden="true" tabindex="-1"></a>population.head()</span></code></pre></div>
<pre><code>State    Year
Alabama  1960    3266740.0
         1970    3444165.0
         1980    3893888.0
         1990    4040587.0
         2000    4447100.0
Name: Population, dtype: float64</code></pre>
<div class="sourceCode" id="cb65"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb65-1"><a href="#cb65-1" aria-hidden="true" tabindex="-1"></a>population.tail()</span></code></pre></div>
<pre><code>State    Year
Wyoming  1980    469557.0
         1990    453588.0
         2000    493782.0
         2010    563626.0
         2020    576851.0
Name: Population, dtype: float64</code></pre>
<p>The series <code>population</code> contains the population of each state according to the United States census conducted every ten years.</p>
<div class="sourceCode" id="cb67"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb67-1"><a href="#cb67-1" aria-hidden="true" tabindex="-1"></a>COAST_URL <span class="op">=</span> <span class="st">&quot;https://en.wikipedia.org/wiki/List_of_U.S._states_and_territories_by_coastline&quot;</span></span>
<span id="cb67-2"><a href="#cb67-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb67-3"><a href="#cb67-3" aria-hidden="true" tabindex="-1"></a>coast_df, _ <span class="op">=</span> pd.read_html(COAST_URL)</span>
<span id="cb67-4"><a href="#cb67-4" aria-hidden="true" tabindex="-1"></a>coast_df <span class="op">=</span> (coast_df[[<span class="st">&quot;State or territory&quot;</span>, <span class="st">&quot;Method 1 (CRS)&quot;</span>, <span class="st">&quot;Coast/area ratio (ft/mi2)&quot;</span>]]</span>
<span id="cb67-5"><a href="#cb67-5" aria-hidden="true" tabindex="-1"></a>                    .iloc[:<span class="op">-</span><span class="dv">1</span>])</span>
<span id="cb67-6"><a href="#cb67-6" aria-hidden="true" tabindex="-1"></a>coast_df.columns <span class="op">=</span> coast_df.columns.droplevel(<span class="dv">0</span>)</span>
<span id="cb67-7"><a href="#cb67-7" aria-hidden="true" tabindex="-1"></a>coast_df <span class="op">=</span> coast_df.drop([<span class="st">&quot;Rank&quot;</span>, <span class="st">&quot;Method 2&quot;</span>], axis<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb67-8"><a href="#cb67-8" aria-hidden="true" tabindex="-1"></a>coast_df <span class="op">=</span> (coast_df.rename(columns<span class="op">=</span>{</span>
<span id="cb67-9"><a href="#cb67-9" aria-hidden="true" tabindex="-1"></a>                        <span class="st">&quot;State or territory&quot;</span>: <span class="st">&quot;State&quot;</span>,</span>
<span id="cb67-10"><a href="#cb67-10" aria-hidden="true" tabindex="-1"></a>                        <span class="st">&quot;Method 1&quot;</span>: <span class="st">&quot;Coastline to area&quot;</span></span>
<span id="cb67-11"><a href="#cb67-11" aria-hidden="true" tabindex="-1"></a>                    })</span>
<span id="cb67-12"><a href="#cb67-12" aria-hidden="true" tabindex="-1"></a>                    .set_index(<span class="st">&quot;State&quot;</span>)</span>
<span id="cb67-13"><a href="#cb67-13" aria-hidden="true" tabindex="-1"></a>                    .sort_index())</span></code></pre></div>
<div class="sourceCode" id="cb68"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb68-1"><a href="#cb68-1" aria-hidden="true" tabindex="-1"></a>coast_df.head()</span></code></pre></div>
<center>
<div>
<style scoped>
.dataframe tbody tr th:only-of-type {
vertical-align: middle;
}

.dataframe tbody tr th {
vertical-align: top;
}

.dataframe thead th {
text-align: right;
}
</style>
<table border="1" class="dataframe">
<thead>
<tr style="text-align: right;">
<th>
</th>
<th>
Coastline
</th>
<th>
Coastline to area
</th>
</tr>
<tr>
<th>
State
</th>
<th>
</th>
<th>
</th>
</tr>
</thead>
<tbody>
<tr>
<th>
Alabama
</th>
<td>
53 mi (85 km)
</td>
<td>
5.3
</td>
</tr>
<tr>
<th>
Alaska
</th>
<td>
6,640 mi (10,690 km)
</td>
<td>
53
</td>
</tr>
<tr>
<th>
American Samoa
</th>
<td>
–
</td>
<td>
–
</td>
</tr>
<tr>
<th>
California
</th>
<td>
840 mi (1,350 km)
</td>
<td>
27
</td>
</tr>
<tr>
<th>
Connecticut
</th>
<td>
96 mi (154 km)
</td>
<td>
91
</td>
</tr>
</tbody>
</table>
</div>
</center>
<p><br></p>
<div class="sourceCode" id="cb69"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb69-1"><a href="#cb69-1" aria-hidden="true" tabindex="-1"></a>coast_df[<span class="st">&quot;Coastline&quot;</span>] <span class="op">=</span> (</span>
<span id="cb69-2"><a href="#cb69-2" aria-hidden="true" tabindex="-1"></a>    coast_df[<span class="st">&quot;Coastline&quot;</span>]</span>
<span id="cb69-3"><a href="#cb69-3" aria-hidden="true" tabindex="-1"></a>            .<span class="bu">str</span>.split(expand<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb69-4"><a href="#cb69-4" aria-hidden="true" tabindex="-1"></a>            .iloc[:, <span class="dv">0</span>]</span>
<span id="cb69-5"><a href="#cb69-5" aria-hidden="true" tabindex="-1"></a>            .<span class="bu">str</span>.replace(<span class="st">&quot;,&quot;</span>, <span class="st">&quot;&quot;</span>)</span>
<span id="cb69-6"><a href="#cb69-6" aria-hidden="true" tabindex="-1"></a>            .<span class="bu">str</span>.replace(<span class="st">&quot;[–—]&quot;</span>, <span class="st">&quot;0&quot;</span>, regex<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb69-7"><a href="#cb69-7" aria-hidden="true" tabindex="-1"></a>            .astype(np.float64)</span>
<span id="cb69-8"><a href="#cb69-8" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb69-9"><a href="#cb69-9" aria-hidden="true" tabindex="-1"></a>coast_df[<span class="st">&quot;Coastline to area&quot;</span>] <span class="op">=</span> (</span>
<span id="cb69-10"><a href="#cb69-10" aria-hidden="true" tabindex="-1"></a>    coast_df[<span class="st">&quot;Coastline to area&quot;</span>]</span>
<span id="cb69-11"><a href="#cb69-11" aria-hidden="true" tabindex="-1"></a>            .astype(<span class="bu">str</span>)</span>
<span id="cb69-12"><a href="#cb69-12" aria-hidden="true" tabindex="-1"></a>            .<span class="bu">str</span>.replace(<span class="st">&quot;[–—]&quot;</span>, <span class="st">&quot;-1&quot;</span>, regex<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb69-13"><a href="#cb69-13" aria-hidden="true" tabindex="-1"></a>            .astype(np.float64)</span>
<span id="cb69-14"><a href="#cb69-14" aria-hidden="true" tabindex="-1"></a>            .replace(<span class="op">-</span><span class="dv">1</span>, np.nan)</span>
<span id="cb69-15"><a href="#cb69-15" aria-hidden="true" tabindex="-1"></a>)</span></code></pre></div>
<div class="sourceCode" id="cb70"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb70-1"><a href="#cb70-1" aria-hidden="true" tabindex="-1"></a>coast_df.head()</span></code></pre></div>
<center>
<div>
<style scoped>
.dataframe tbody tr th:only-of-type {
vertical-align: middle;
}

.dataframe tbody tr th {
vertical-align: top;
}

.dataframe thead th {
text-align: right;
}
</style>
<table border="1" class="dataframe">
<thead>
<tr style="text-align: right;">
<th>
</th>
<th>
Coastline
</th>
<th>
Coastline to area
</th>
</tr>
<tr>
<th>
State
</th>
<th>
</th>
<th>
</th>
</tr>
</thead>
<tbody>
<tr>
<th>
Alabama
</th>
<td>
53.0
</td>
<td>
5.3
</td>
</tr>
<tr>
<th>
Alaska
</th>
<td>
6640.0
</td>
<td>
53.0
</td>
</tr>
<tr>
<th>
American Samoa
</th>
<td>
0.0
</td>
<td>
NaN
</td>
</tr>
<tr>
<th>
California
</th>
<td>
840.0
</td>
<td>
27.0
</td>
</tr>
<tr>
<th>
Connecticut
</th>
<td>
96.0
</td>
<td>
91.0
</td>
</tr>
</tbody>
</table>
</div>
</center>
<p><br></p>
<div class="sourceCode" id="cb71"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb71-1"><a href="#cb71-1" aria-hidden="true" tabindex="-1"></a>coast_df.tail()</span></code></pre></div>
<center>
<div>
<style scoped>
.dataframe tbody tr th:only-of-type {
vertical-align: middle;
}

.dataframe tbody tr th {
vertical-align: top;
}

.dataframe thead th {
text-align: right;
}
</style>
<table border="1" class="dataframe">
<thead>
<tr style="text-align: right;">
<th>
</th>
<th>
Coastline
</th>
<th>
Coastline to area
</th>
</tr>
<tr>
<th>
State
</th>
<th>
</th>
<th>
</th>
</tr>
</thead>
<tbody>
<tr>
<th>
U.S. Minor Outlying Islands
</th>
<td>
0.0
</td>
<td>
NaN
</td>
</tr>
<tr>
<th>
U.S. Virgin Islands
</th>
<td>
0.0
</td>
<td>
NaN
</td>
</tr>
<tr>
<th>
Virginia
</th>
<td>
112.0
</td>
<td>
14.0
</td>
</tr>
<tr>
<th>
Washington
</th>
<td>
157.0
</td>
<td>
12.0
</td>
</tr>
<tr>
<th>
Wisconsin
</th>
<td>
0.0
</td>
<td>
NaN
</td>
</tr>
</tbody>
</table>
</div>
</center>
<p><br></p>
<p>The data frame <code>coast_df</code> contains the length of a state’s coastline (in miles) as well as the ratio of its coastline to area (in square miles).</p>
<p>We now combine <code>attacks</code>, <code>population</code>, and <code>coast_df</code> into a single data frame.</p>
<div class="sourceCode" id="cb72"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb72-1"><a href="#cb72-1" aria-hidden="true" tabindex="-1"></a>attacks_df <span class="op">=</span> (attacks_df.merge(coast_df,</span>
<span id="cb72-2"><a href="#cb72-2" aria-hidden="true" tabindex="-1"></a>                               left_index<span class="op">=</span><span class="va">True</span>, right_index<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb72-3"><a href="#cb72-3" aria-hidden="true" tabindex="-1"></a>                        .merge(population, how<span class="op">=</span><span class="st">&#39;left&#39;</span>,</span>
<span id="cb72-4"><a href="#cb72-4" aria-hidden="true" tabindex="-1"></a>                               left_index<span class="op">=</span><span class="va">True</span>, right_index<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb72-5"><a href="#cb72-5" aria-hidden="true" tabindex="-1"></a>                        .fillna(method<span class="op">=</span><span class="st">&#39;ffill&#39;</span>))</span></code></pre></div>
<div class="sourceCode" id="cb73"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb73-1"><a href="#cb73-1" aria-hidden="true" tabindex="-1"></a>attacks_df[<span class="st">&quot;Population to coastline&quot;</span>] <span class="op">=</span> attacks_df[<span class="st">&quot;Population&quot;</span>] <span class="op">/</span> attacks_df[<span class="st">&quot;Coastline&quot;</span>]</span></code></pre></div>
<div class="sourceCode" id="cb74"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb74-1"><a href="#cb74-1" aria-hidden="true" tabindex="-1"></a>attacks_df.head()</span></code></pre></div>
<center>
<div>
<style scoped>
.dataframe tbody tr th:only-of-type {
vertical-align: middle;
}

.dataframe tbody tr th {
vertical-align: top;
}

.dataframe thead th {
text-align: right;
}
</style>
<table border="1" class="dataframe">
<thead>
<tr style="text-align: right;">
<th>
</th>
<th>
</th>
<th>
Attacks
</th>
<th>
Coastline
</th>
<th>
Coastline to area
</th>
<th>
Population
</th>
<th>
Population to coastline
</th>
</tr>
<tr>
<th>
State
</th>
<th>
Year
</th>
<th>
</th>
<th>
</th>
<th>
</th>
<th>
</th>
<th>
</th>
</tr>
</thead>
<tbody>
<tr>
<th rowspan="5" valign="top">
Alabama
</th>
<th>
1960
</th>
<td>
0
</td>
<td>
53.0
</td>
<td>
5.3
</td>
<td>
3266740.0
</td>
<td>
61636.603774
</td>
</tr>
<tr>
<th>
1961
</th>
<td>
0
</td>
<td>
53.0
</td>
<td>
5.3
</td>
<td>
3266740.0
</td>
<td>
61636.603774
</td>
</tr>
<tr>
<th>
1962
</th>
<td>
0
</td>
<td>
53.0
</td>
<td>
5.3
</td>
<td>
3266740.0
</td>
<td>
61636.603774
</td>
</tr>
<tr>
<th>
1963
</th>
<td>
0
</td>
<td>
53.0
</td>
<td>
5.3
</td>
<td>
3266740.0
</td>
<td>
61636.603774
</td>
</tr>
<tr>
<th>
1964
</th>
<td>
0
</td>
<td>
53.0
</td>
<td>
5.3
</td>
<td>
3266740.0
</td>
<td>
61636.603774
</td>
</tr>
</tbody>
</table>
</div>
</center>
<p><br></p>
<div class="sourceCode" id="cb75"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb75-1"><a href="#cb75-1" aria-hidden="true" tabindex="-1"></a>attacks_df.tail()</span></code></pre></div>
<center>
<div>
<style scoped>
.dataframe tbody tr th:only-of-type {
vertical-align: middle;
}

.dataframe tbody tr th {
vertical-align: top;
}

.dataframe thead th {
text-align: right;
}
</style>
<table border="1" class="dataframe">
<thead>
<tr style="text-align: right;">
<th>
</th>
<th>
</th>
<th>
Attacks
</th>
<th>
Coastline
</th>
<th>
Coastline to area
</th>
<th>
Population
</th>
<th>
Population to coastline
</th>
</tr>
<tr>
<th>
State
</th>
<th>
Year
</th>
<th>
</th>
<th>
</th>
<th>
</th>
<th>
</th>
<th>
</th>
</tr>
</thead>
<tbody>
<tr>
<th rowspan="5" valign="top">
Washington
</th>
<th>
2015
</th>
<td>
0
</td>
<td>
157.0
</td>
<td>
12.0
</td>
<td>
6724540.0
</td>
<td>
42831.464968
</td>
</tr>
<tr>
<th>
2016
</th>
<td>
0
</td>
<td>
157.0
</td>
<td>
12.0
</td>
<td>
6724540.0
</td>
<td>
42831.464968
</td>
</tr>
<tr>
<th>
2017
</th>
<td>
1
</td>
<td>
157.0
</td>
<td>
12.0
</td>
<td>
6724540.0
</td>
<td>
42831.464968
</td>
</tr>
<tr>
<th>
2018
</th>
<td>
0
</td>
<td>
157.0
</td>
<td>
12.0
</td>
<td>
6724540.0
</td>
<td>
42831.464968
</td>
</tr>
<tr>
<th>
2019
</th>
<td>
0
</td>
<td>
157.0
</td>
<td>
12.0
</td>
<td>
6724540.0
</td>
<td>
42831.464968
</td>
</tr>
</tbody>
</table>
</div>
</center>
<p>Here the population data is from the most recent United States census prior to the year in question (thanks to <code>fillna(method='ffill')</code>. Below we plot the relationship between the four explanatory variables and the number of attacks.</p>
<div class="sourceCode" id="cb76"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb76-1"><a href="#cb76-1" aria-hidden="true" tabindex="-1"></a>fig, axes <span class="op">=</span> plt.subplots(ncols<span class="op">=</span><span class="dv">2</span>, nrows<span class="op">=</span><span class="dv">2</span>, sharey<span class="op">=</span><span class="va">True</span>,</span>
<span id="cb76-2"><a href="#cb76-2" aria-hidden="true" tabindex="-1"></a>                         figsize<span class="op">=</span>(<span class="dv">12</span>, <span class="dv">9</span>))</span>
<span id="cb76-3"><a href="#cb76-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb76-4"><a href="#cb76-4" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> col, ax <span class="kw">in</span> <span class="bu">zip</span>(attacks_df.columns[<span class="dv">1</span>:], axes.ravel()):</span>
<span id="cb76-5"><a href="#cb76-5" aria-hidden="true" tabindex="-1"></a>    attacks_df.plot.scatter(col, <span class="st">&quot;Attacks&quot;</span>,</span>
<span id="cb76-6"><a href="#cb76-6" aria-hidden="true" tabindex="-1"></a>                            color<span class="op">=</span><span class="st">&#39;C0&#39;</span>, alpha<span class="op">=</span><span class="fl">0.5</span>,</span>
<span id="cb76-7"><a href="#cb76-7" aria-hidden="true" tabindex="-1"></a>                            ax<span class="op">=</span>ax)<span class="op">;</span></span>
<span id="cb76-8"><a href="#cb76-8" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb76-9"><a href="#cb76-9" aria-hidden="true" tabindex="-1"></a>    ax.set_xscale(<span class="st">&#39;log&#39;</span>)<span class="op">;</span></span>
<span id="cb76-10"><a href="#cb76-10" aria-hidden="true" tabindex="-1"></a>    ax.set_yscale(<span class="st">&#39;log&#39;</span>)<span class="op">;</span></span>
<span id="cb76-11"><a href="#cb76-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb76-12"><a href="#cb76-12" aria-hidden="true" tabindex="-1"></a>fig.tight_layout()<span class="op">;</span></span></code></pre></div>
<center>
<img src="/resources/sharks_pycm3_files/sharks_pycm3_97_0.png" title="fig:" alt="png" />
</center>
<p>The top two and bottom two plots are very similar. We choose to use coastline length (in miles) and population as our predictors since those relationships seem to be a bit more linear on the log-log scale.</p>
<p>We standardize the logarithms of coastline length and population before using them as predictors.</p>
<div class="sourceCode" id="cb77"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb77-1"><a href="#cb77-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> standardize(x):</span>
<span id="cb77-2"><a href="#cb77-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> (x <span class="op">-</span> x.mean()) <span class="op">/</span> x.std()</span></code></pre></div>
<div class="sourceCode" id="cb78"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb78-1"><a href="#cb78-1" aria-hidden="true" tabindex="-1"></a>log_coast <span class="op">=</span> np.log(attacks_df[<span class="st">&quot;Coastline&quot;</span>].values)</span>
<span id="cb78-2"><a href="#cb78-2" aria-hidden="true" tabindex="-1"></a>x_coast <span class="op">=</span> at.constant(standardize(log_coast))</span></code></pre></div>
<div class="sourceCode" id="cb79"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb79-1"><a href="#cb79-1" aria-hidden="true" tabindex="-1"></a>log_pop <span class="op">=</span> np.log(attacks_df[<span class="st">&quot;Population&quot;</span>].values)</span>
<span id="cb79-2"><a href="#cb79-2" aria-hidden="true" tabindex="-1"></a>x_pop <span class="op">=</span> at.constant(standardize(log_pop))</span></code></pre></div>
<p>We use the priors <span class="math inline">\(\beta_0, \beta_{\text{coast}}, \beta_{\text{pop}} \sim N(0, 2.5^2)\)</span> on the regression coefficients and set</p>
<p><span class="math display">\[\eta_{i, t} = \beta_0 + \beta_{\text{coast}} \cdot x_{\text{coast}, i} + \beta_{\text{pop}} \cdot x_{\text{pop}, i, t}.\]</span> The mean is then <span class="math inline">\(\mu_{i, t} = \exp \eta_{i, t}.\)</span></p>
<div class="sourceCode" id="cb80"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb80-1"><a href="#cb80-1" aria-hidden="true" tabindex="-1"></a><span class="cf">with</span> pm.Model() <span class="im">as</span> nb_reg_model:</span>
<span id="cb80-2"><a href="#cb80-2" aria-hidden="true" tabindex="-1"></a>    β<span class="dv">0</span> <span class="op">=</span> pm.Normal(<span class="st">&quot;β0&quot;</span>, <span class="fl">0.</span>, <span class="fl">2.5</span>)</span>
<span id="cb80-3"><a href="#cb80-3" aria-hidden="true" tabindex="-1"></a>    β_coast <span class="op">=</span> pm.Normal(<span class="st">&quot;β_coast&quot;</span>, <span class="fl">0.</span>, <span class="fl">2.5</span>)</span>
<span id="cb80-4"><a href="#cb80-4" aria-hidden="true" tabindex="-1"></a>    β_pop <span class="op">=</span> pm.Normal(<span class="st">&quot;β_pop&quot;</span>, <span class="fl">0.</span>, <span class="fl">2.5</span>)</span>
<span id="cb80-5"><a href="#cb80-5" aria-hidden="true" tabindex="-1"></a>    η <span class="op">=</span> β<span class="dv">0</span> <span class="op">+</span> β_coast <span class="op">*</span> x_coast <span class="op">+</span> β_pop <span class="op">*</span> x_pop</span>
<span id="cb80-6"><a href="#cb80-6" aria-hidden="true" tabindex="-1"></a>    μ <span class="op">=</span> at.exp(η)</span></code></pre></div>
<p>As in the previous model, <span class="math inline">\(\alpha \sim \operatorname{Half}-N(2.5^2)\)</span> and <span class="math inline">\(y_{i, t} \sim NB(\mu_{i, t}, \alpha)\)</span>.</p>
<div class="sourceCode" id="cb81"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb81-1"><a href="#cb81-1" aria-hidden="true" tabindex="-1"></a><span class="cf">with</span> nb_reg_model:</span>
<span id="cb81-2"><a href="#cb81-2" aria-hidden="true" tabindex="-1"></a>    α <span class="op">=</span> pm.HalfNormal(<span class="st">&quot;α&quot;</span>, <span class="fl">2.5</span>)</span>
<span id="cb81-3"><a href="#cb81-3" aria-hidden="true" tabindex="-1"></a>    obs <span class="op">=</span> pm.NegativeBinomial(<span class="st">&quot;obs&quot;</span>, μ, α, observed<span class="op">=</span>y)</span></code></pre></div>
<p>We again sample from the posterior distribution of the model.</p>
<div class="sourceCode" id="cb82"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb82-1"><a href="#cb82-1" aria-hidden="true" tabindex="-1"></a><span class="cf">with</span> nb_reg_model:</span>
<span id="cb82-2"><a href="#cb82-2" aria-hidden="true" tabindex="-1"></a>    nb_reg_trace <span class="op">=</span> pm.sample(<span class="op">**</span>SAMPLE_KWARGS)</span></code></pre></div>
<pre><code>Auto-assigning NUTS sampler...
Initializing NUTS using jitter+adapt_diag...
Multiprocess sampling (3 chains in 3 jobs)
NUTS: [β0, β_coast, β_pop, α]</code></pre>
<div>
<style>
/* Turns off some styling */
progress {
/* gets rid of default border in Firefox and Opera. */
border: none;
/* Needs to be in here for Safari polyfill so background images work as expected. */
background-size: auto;
}
.progress-bar-interrupted, .progress-bar-interrupted::-webkit-progress-bar {
background: #F44336;
}
</style>
<progress value="6000" class max="6000" style="width:300px; height:20px; vertical-align: middle;">
</progress>
<p>100.00% [6000/6000 00:24&lt;00:00 Sampling 3 chains, 0 divergences]</p>
</div>
<pre><code>Sampling 3 chains for 1_000 tune and 1_000 draw iterations (3_000 + 3_000 draws total) took 25 seconds.</code></pre>
<p>As before, the standard sampling diagnostics show no cause for concern.</p>
<div class="sourceCode" id="cb85"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb85-1"><a href="#cb85-1" aria-hidden="true" tabindex="-1"></a>make_diagnostic_plots(nb_reg_trace)<span class="op">;</span></span></code></pre></div>
<center>
<img src="/resources/sharks_pycm3_files/sharks_pycm3_109_0.png" title="fig:" alt="png" />
</center>
<p>To see if the inclusion of these predictors has improved the model fit, we sample from and plot the posterior predictive distributions per state-year.</p>
<div class="sourceCode" id="cb86"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb86-1"><a href="#cb86-1" aria-hidden="true" tabindex="-1"></a><span class="cf">with</span> nb_reg_model:</span>
<span id="cb86-2"><a href="#cb86-2" aria-hidden="true" tabindex="-1"></a>    nb_reg_pp_trace <span class="op">=</span> pm.sample_posterior_predictive(nb_reg_trace)</span></code></pre></div>
<div>
<style>
/* Turns off some styling */
progress {
/* gets rid of default border in Firefox and Opera. */
border: none;
/* Needs to be in here for Safari polyfill so background images work as expected. */
background-size: auto;
}
.progress-bar-interrupted, .progress-bar-interrupted::-webkit-progress-bar {
background: #F44336;
}
</style>
<progress value="3000" class max="3000" style="width:300px; height:20px; vertical-align: middle;">
</progress>
<p>100.00% [3000/3000 00:02&lt;00:00]</p>
</div>
<div class="sourceCode" id="cb87"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb87-1"><a href="#cb87-1" aria-hidden="true" tabindex="-1"></a>nb_reg_pp_full_df <span class="op">=</span> make_pp_full_df(nb_reg_pp_trace[<span class="st">&quot;obs&quot;</span>])</span></code></pre></div>
<div class="sourceCode" id="cb88"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb88-1"><a href="#cb88-1" aria-hidden="true" tabindex="-1"></a>nb_reg_pp_df <span class="op">=</span> summarize_pp_df(nb_reg_pp_full_df)</span>
<span id="cb88-2"><a href="#cb88-2" aria-hidden="true" tabindex="-1"></a>grid <span class="op">=</span> sns.FacetGrid(nb_reg_pp_df.reset_index(), col<span class="op">=</span><span class="st">&quot;State&quot;</span>,</span>
<span id="cb88-3"><a href="#cb88-3" aria-hidden="true" tabindex="-1"></a>                     col_wrap<span class="op">=</span><span class="dv">2</span>, sharey<span class="op">=</span><span class="va">False</span>, aspect<span class="op">=</span><span class="fl">1.5</span>)</span>
<span id="cb88-4"><a href="#cb88-4" aria-hidden="true" tabindex="-1"></a>grid.map_dataframe(plot_pp_over_time)<span class="op">;</span></span>
<span id="cb88-5"><a href="#cb88-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb88-6"><a href="#cb88-6" aria-hidden="true" tabindex="-1"></a>grid.axes[<span class="dv">0</span>].legend(loc<span class="op">=</span><span class="st">&quot;upper left&quot;</span>)<span class="op">;</span></span>
<span id="cb88-7"><a href="#cb88-7" aria-hidden="true" tabindex="-1"></a>grid.set_titles(<span class="st">&quot;</span><span class="sc">{col_name}</span><span class="st">&quot;</span>)<span class="op">;</span></span>
<span id="cb88-8"><a href="#cb88-8" aria-hidden="true" tabindex="-1"></a>grid.fig.tight_layout()<span class="op">;</span></span></code></pre></div>
<center>
<img src="/resources/sharks_pycm3_files/sharks_pycm3_113_0.png" title="fig:" alt="png" />
</center>
<div class="sourceCode" id="cb89"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb89-1"><a href="#cb89-1" aria-hidden="true" tabindex="-1"></a>nb_reg_pp_state_df <span class="op">=</span> summarize_pp_df(nb_reg_pp_full_df, level<span class="op">=</span><span class="st">&quot;State&quot;</span>)</span>
<span id="cb89-2"><a href="#cb89-2" aria-hidden="true" tabindex="-1"></a>ax <span class="op">=</span> (nb_reg_pp_state_df.reset_index()</span>
<span id="cb89-3"><a href="#cb89-3" aria-hidden="true" tabindex="-1"></a>                    .plot.scatter(<span class="st">&quot;mean&quot;</span>, <span class="st">&quot;State&quot;</span>, color<span class="op">=</span><span class="st">&#39;C0&#39;</span>,</span>
<span id="cb89-4"><a href="#cb89-4" aria-hidden="true" tabindex="-1"></a>                                  xerr<span class="op">=</span>nb_reg_pp_state_df[[<span class="st">&quot;low&quot;</span>, <span class="st">&quot;high&quot;</span>]]</span>
<span id="cb89-5"><a href="#cb89-5" aria-hidden="true" tabindex="-1"></a>                                                     .sub(nb_reg_pp_state_df[<span class="st">&quot;mean&quot;</span>],</span>
<span id="cb89-6"><a href="#cb89-6" aria-hidden="true" tabindex="-1"></a>                                                          axis<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb89-7"><a href="#cb89-7" aria-hidden="true" tabindex="-1"></a>                                                     .<span class="bu">abs</span>()</span>
<span id="cb89-8"><a href="#cb89-8" aria-hidden="true" tabindex="-1"></a>                                                     .values.T,</span>
<span id="cb89-9"><a href="#cb89-9" aria-hidden="true" tabindex="-1"></a>                                  zorder<span class="op">=</span><span class="dv">5</span>,</span>
<span id="cb89-10"><a href="#cb89-10" aria-hidden="true" tabindex="-1"></a>                                  label<span class="op">=</span><span class="st">&quot;Posterior predictive mean&quot;</span>))</span>
<span id="cb89-11"><a href="#cb89-11" aria-hidden="true" tabindex="-1"></a>(attacks_df.reset_index()</span>
<span id="cb89-12"><a href="#cb89-12" aria-hidden="true" tabindex="-1"></a>           .plot.scatter(<span class="st">&quot;Attacks&quot;</span>, <span class="st">&quot;State&quot;</span>,</span>
<span id="cb89-13"><a href="#cb89-13" aria-hidden="true" tabindex="-1"></a>                         color<span class="op">=</span><span class="st">&#39;k&#39;</span>, alpha<span class="op">=</span><span class="fl">0.5</span>,</span>
<span id="cb89-14"><a href="#cb89-14" aria-hidden="true" tabindex="-1"></a>                         label<span class="op">=</span><span class="st">&quot;Actual&quot;</span>, ax<span class="op">=</span>ax))<span class="op">;</span></span>
<span id="cb89-15"><a href="#cb89-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb89-16"><a href="#cb89-16" aria-hidden="true" tabindex="-1"></a>ax.set_xlabel(<span class="st">&quot;Number of shark Attacks&quot;</span>)<span class="op">;</span></span>
<span id="cb89-17"><a href="#cb89-17" aria-hidden="true" tabindex="-1"></a>ax.invert_yaxis()<span class="op">;</span></span></code></pre></div>
<center>
<img src="/resources/sharks_pycm3_files/sharks_pycm3_114_0.png" title="fig:" alt="png" />
</center>
<p>These predictions certainly appear visually better than those from the regular negative binomial model without predictors, but still leave significant room for improvement, espescially in states like Florida, California, Hawaii, and the Carolinas.</p>
<p>We use <a href="https://arxiv.org/abs/1507.04544">Pareto-smoothed importance sampling leave-one-out cross-validation</a> (PSIS-LOO) to quantify the improvement of this model over the basic negative binomial model.</p>
<div class="sourceCode" id="cb90"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb90-1"><a href="#cb90-1" aria-hidden="true" tabindex="-1"></a>traces <span class="op">=</span> {</span>
<span id="cb90-2"><a href="#cb90-2" aria-hidden="true" tabindex="-1"></a>    <span class="st">&quot;NB&quot;</span>: nb_trace,</span>
<span id="cb90-3"><a href="#cb90-3" aria-hidden="true" tabindex="-1"></a>    <span class="st">&quot;NB regression&quot;</span>: nb_reg_trace</span>
<span id="cb90-4"><a href="#cb90-4" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<div class="sourceCode" id="cb91"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb91-1"><a href="#cb91-1" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots()</span>
<span id="cb91-2"><a href="#cb91-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb91-3"><a href="#cb91-3" aria-hidden="true" tabindex="-1"></a>comp_df <span class="op">=</span> az.compare(traces)</span>
<span id="cb91-4"><a href="#cb91-4" aria-hidden="true" tabindex="-1"></a>az.plot_compare(comp_df, plot_ic_diff<span class="op">=</span><span class="va">False</span>, ax<span class="op">=</span>ax)<span class="op">;</span></span></code></pre></div>
<center>
<img src="/resources/sharks_pycm3_files/sharks_pycm3_117_0.png" title="fig:" alt="png" />
</center>
<p>We see that the PSIS-LOO score of the regression model is significantly higher than that of the simple negative binomial model.</p>
<h3 id="mixed-effects">Mixed effects</h3>
<p>There are many factors about each state that we have not included as predictors (average water temperature, prevalence of beach tourism, etc.). To account for this these and other unmeasured differences between states, we now add state-level <a href="https://en.wikipedia.org/wiki/Mixed_model">mixed effects</a> to our model.</p>
<p>Let <span class="math inline">\(j = 1, 2, \ldots, n_{\text{state}}\)</span> denote the index of a state and <span class="math inline">\(j(i)\)</span> denoth the index of the state of the <span class="math inline">\(i\)</span>-th observation.</p>
<p>We place hierarchical normal priors on <span class="math inline">\(\beta_{0, j},\)</span> <span class="math inline">\(\beta_{\text{coast}, j},\)</span> and <span class="math inline">\(\beta_{\text{pop}, j}\)</span> and set</p>
<p><span class="math display">\[\eta_{i, t} = \beta_{0, j(i)} + \beta_{\text{coast}, j(i)} \cdot x_{\text{coast}, i} + \beta_{\text{pop}, j(i)} \cdot x_{\text{pop}, i, t}.\]</span> Again the mean is then <span class="math inline">\(\mu_{i, t} = \exp \eta_{i, t}.\)</span></p>
<p>The hierarchical prior for <span class="math inline">\(\beta_0\)</span> is equivalent to</p>
<p><span class="math display">\[
\begin{align*}
    \mu_{\beta_0}, \gamma_{0, \text{pop}}
        &amp; \sim N(0, 2.5^2) \\
    \sigma_{\beta_0}
        &amp; \sim \operatorname{Half}-N(2.5^2) \\
    \beta_{0, j}
        &amp; \sim N\left(\mu_{\beta_0} + \gamma_{0, \text{pop}} \cdot \bar{x}_{\text{pop}, j}, \sigma_{\beta_0}^2\right).
\end{align*}
\]</span></p>
<p>In reality, we implement this system of priors using a <a href="https://twiecki.io/blog/2017/02/08/bayesian-hierchical-non-centered/">non-centered parametrization</a> that is mathematically equivalent but often more computationally efficient. Note the inclusion of a term for <span class="math inline">\(\bar{x}_{\text{pop}, j}\)</span>, which is the average population for the <span class="math inline">\(j\)</span>-th state. We include this term to <a href="http://www.stat.columbia.edu/~gelman/research/unpublished/Bafumi_Gelman_Midwest06.pdf">avoid</a> violating the <a href="https://en.wikipedia.org/wiki/Gauss%E2%80%93Markov_theorem">Gauss-Markov assumptions</a>.</p>
<div class="sourceCode" id="cb92"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb92-1"><a href="#cb92-1" aria-hidden="true" tabindex="-1"></a>j_, state_map <span class="op">=</span> (attacks_df.index</span>
<span id="cb92-2"><a href="#cb92-2" aria-hidden="true" tabindex="-1"></a>                          .get_level_values(<span class="st">&quot;State&quot;</span>)</span>
<span id="cb92-3"><a href="#cb92-3" aria-hidden="true" tabindex="-1"></a>                          .factorize(sort<span class="op">=</span><span class="va">True</span>))</span>
<span id="cb92-4"><a href="#cb92-4" aria-hidden="true" tabindex="-1"></a>n_state <span class="op">=</span> state_map.size</span>
<span id="cb92-5"><a href="#cb92-5" aria-hidden="true" tabindex="-1"></a>j <span class="op">=</span> at.constant(j_)</span></code></pre></div>
<div class="sourceCode" id="cb93"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb93-1"><a href="#cb93-1" aria-hidden="true" tabindex="-1"></a>x_pop_bar <span class="op">=</span> at.constant(standardize(</span>
<span id="cb93-2"><a href="#cb93-2" aria-hidden="true" tabindex="-1"></a>    attacks_df.assign(x_pop<span class="op">=</span>x_pop.<span class="bu">eval</span>())</span>
<span id="cb93-3"><a href="#cb93-3" aria-hidden="true" tabindex="-1"></a>              .groupby(level<span class="op">=</span><span class="st">&quot;State&quot;</span>)</span>
<span id="cb93-4"><a href="#cb93-4" aria-hidden="true" tabindex="-1"></a>              [<span class="st">&quot;x_pop&quot;</span>]</span>
<span id="cb93-5"><a href="#cb93-5" aria-hidden="true" tabindex="-1"></a>              .mean()</span>
<span id="cb93-6"><a href="#cb93-6" aria-hidden="true" tabindex="-1"></a>              .values</span>
<span id="cb93-7"><a href="#cb93-7" aria-hidden="true" tabindex="-1"></a>))</span></code></pre></div>
<div class="sourceCode" id="cb94"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb94-1"><a href="#cb94-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> noncentered_normal(name, shape, μ<span class="op">=</span><span class="va">None</span>):</span>
<span id="cb94-2"><a href="#cb94-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> μ <span class="kw">is</span> <span class="va">None</span>:</span>
<span id="cb94-3"><a href="#cb94-3" aria-hidden="true" tabindex="-1"></a>        μ <span class="op">=</span> pm.Normal(<span class="ss">f&quot;μ_</span><span class="sc">{</span>name<span class="sc">}</span><span class="ss">&quot;</span>, <span class="fl">0.</span>, <span class="fl">2.5</span>)</span>
<span id="cb94-4"><a href="#cb94-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb94-5"><a href="#cb94-5" aria-hidden="true" tabindex="-1"></a>    Δ <span class="op">=</span> pm.Normal(<span class="ss">f&quot;Δ_</span><span class="sc">{</span>name<span class="sc">}</span><span class="ss">&quot;</span>, <span class="fl">0.</span>, <span class="fl">1.</span>, shape<span class="op">=</span>shape)</span>
<span id="cb94-6"><a href="#cb94-6" aria-hidden="true" tabindex="-1"></a>    σ <span class="op">=</span> pm.HalfNormal(<span class="ss">f&quot;σ_</span><span class="sc">{</span>name<span class="sc">}</span><span class="ss">&quot;</span>, <span class="fl">2.5</span>)</span>
<span id="cb94-7"><a href="#cb94-7" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb94-8"><a href="#cb94-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> pm.Deterministic(name, μ <span class="op">+</span> Δ <span class="op">*</span> σ)</span>
<span id="cb94-9"><a href="#cb94-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb94-10"><a href="#cb94-10" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> noncentered_normal_with_avg(name, avg_map, shape, μ<span class="op">=</span><span class="va">None</span>):</span>
<span id="cb94-11"><a href="#cb94-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> μ <span class="kw">is</span> <span class="va">None</span>:</span>
<span id="cb94-12"><a href="#cb94-12" aria-hidden="true" tabindex="-1"></a>        μ <span class="op">=</span> pm.Normal(<span class="ss">f&quot;μ_</span><span class="sc">{</span>name<span class="sc">}</span><span class="ss">&quot;</span>, <span class="fl">0.</span>, <span class="fl">2.5</span>)</span>
<span id="cb94-13"><a href="#cb94-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb94-14"><a href="#cb94-14" aria-hidden="true" tabindex="-1"></a>    avg_terms_sum <span class="op">=</span> <span class="fl">0.</span></span>
<span id="cb94-15"><a href="#cb94-15" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb94-16"><a href="#cb94-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> term_name, x_bar <span class="kw">in</span> avg_map.items():</span>
<span id="cb94-17"><a href="#cb94-17" aria-hidden="true" tabindex="-1"></a>        avg_terms_sum <span class="op">+=</span> pm.Normal(<span class="ss">f&quot;γ_</span><span class="sc">{</span>name<span class="sc">}</span><span class="ss">_</span><span class="sc">{</span>term_name<span class="sc">}</span><span class="ss">_bar&quot;</span>, <span class="fl">0.</span>, <span class="fl">2.5</span>) <span class="op">*</span> x_bar</span>
<span id="cb94-18"><a href="#cb94-18" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb94-19"><a href="#cb94-19" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> noncentered_normal(name, shape, μ<span class="op">=</span>μ <span class="op">+</span> avg_terms_sum)</span></code></pre></div>
<div class="sourceCode" id="cb95"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb95-1"><a href="#cb95-1" aria-hidden="true" tabindex="-1"></a><span class="cf">with</span> pm.Model() <span class="im">as</span> mixed_model:</span>
<span id="cb95-2"><a href="#cb95-2" aria-hidden="true" tabindex="-1"></a>    β<span class="dv">0</span> <span class="op">=</span> noncentered_normal_with_avg(</span>
<span id="cb95-3"><a href="#cb95-3" aria-hidden="true" tabindex="-1"></a>        <span class="st">&quot;β0&quot;</span>, {<span class="st">&quot;pop&quot;</span>: x_pop_bar}, n_state</span>
<span id="cb95-4"><a href="#cb95-4" aria-hidden="true" tabindex="-1"></a>    )</span></code></pre></div>
<p>The prior for <span class="math inline">\(\beta_{\text{coast}, j}\)</span> is</p>
<p><span class="math display">\[
\begin{align*}
    \mu_{\beta_\text{coast}}, \gamma_{\text{coast}^2}, \gamma_{\text{coast}, \text{pop}}
        &amp; \sim N(0, 2.5^2) \\
    \sigma_{\beta_{\text{coast}}}
        &amp; \sim \operatorname{Half}-N(2.5^2) \\
    \beta_{\text{coast}, j}
        &amp; \sim N\left(\mu_{\beta_\text{coast}} + \gamma_{\text{coast}^2} \cdot x_{\text{coast}, j} + \gamma_{\text{coast}, \text{pop}} \cdot \bar{x}_{\text{pop}, j}, \sigma_{\beta_0}^2\right)
\end{align*}
\]</span></p>
<p>Here <span class="math inline">\(\bar{x}_{\text{coast}, j} = x_{\text{coast}, j}\)</span> since the a state’s coastline does not change over time (we ignoring the effects of global warming here). Due to this fact, we do not include the term <span class="math inline">\(\gamma_{0, \text{coast}} \cdot x_{\text{coast}, j}\)</span> in the definition of <span class="math inline">\(\beta_0\)</span>, because this term would lead to <span class="math inline">\(\mu_{\beta_{\text{coast}}}\)</span> becoming unidentified. We use the analagous system of priors for <span class="math inline">\(\beta_{\text{pop}}.\)</span></p>
<div class="sourceCode" id="cb96"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb96-1"><a href="#cb96-1" aria-hidden="true" tabindex="-1"></a>log_state_coast <span class="op">=</span> np.log(coast_df[<span class="st">&quot;Coastline&quot;</span>]</span>
<span id="cb96-2"><a href="#cb96-2" aria-hidden="true" tabindex="-1"></a>                                 .loc[state_map]</span>
<span id="cb96-3"><a href="#cb96-3" aria-hidden="true" tabindex="-1"></a>                                 .values)</span>
<span id="cb96-4"><a href="#cb96-4" aria-hidden="true" tabindex="-1"></a>x_coast_bar <span class="op">=</span> at.constant(standardize(log_state_coast))</span></code></pre></div>
<div class="sourceCode" id="cb97"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb97-1"><a href="#cb97-1" aria-hidden="true" tabindex="-1"></a><span class="cf">with</span> mixed_model:</span>
<span id="cb97-2"><a href="#cb97-2" aria-hidden="true" tabindex="-1"></a>    β_coast <span class="op">=</span> noncentered_normal_with_avg(</span>
<span id="cb97-3"><a href="#cb97-3" aria-hidden="true" tabindex="-1"></a>        <span class="st">&quot;β_coast&quot;</span>,</span>
<span id="cb97-4"><a href="#cb97-4" aria-hidden="true" tabindex="-1"></a>        {<span class="st">&quot;pop&quot;</span>: x_pop_bar, <span class="st">&quot;coast&quot;</span>: x_coast_bar},</span>
<span id="cb97-5"><a href="#cb97-5" aria-hidden="true" tabindex="-1"></a>        n_state</span>
<span id="cb97-6"><a href="#cb97-6" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb97-7"><a href="#cb97-7" aria-hidden="true" tabindex="-1"></a>    β_pop <span class="op">=</span> noncentered_normal_with_avg(</span>
<span id="cb97-8"><a href="#cb97-8" aria-hidden="true" tabindex="-1"></a>        <span class="st">&quot;β_pop&quot;</span>,</span>
<span id="cb97-9"><a href="#cb97-9" aria-hidden="true" tabindex="-1"></a>        {<span class="st">&quot;pop&quot;</span>: x_pop_bar, <span class="st">&quot;coast&quot;</span>: x_coast_bar},</span>
<span id="cb97-10"><a href="#cb97-10" aria-hidden="true" tabindex="-1"></a>        n_state)</span></code></pre></div>
<p>The definitions of <span class="math inline">\(\eta_{i, t}\)</span>, <span class="math inline">\(\mu_{i, t}\)</span>, and <span class="math inline">\(\alpha\)</span> are similar to those in the previous model.</p>
<div class="sourceCode" id="cb98"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb98-1"><a href="#cb98-1" aria-hidden="true" tabindex="-1"></a><span class="cf">with</span> mixed_model:</span>
<span id="cb98-2"><a href="#cb98-2" aria-hidden="true" tabindex="-1"></a>    η <span class="op">=</span> β<span class="dv">0</span>[j] <span class="op">+</span> β_coast[j] <span class="op">*</span> x_coast <span class="op">+</span> β_pop[j] <span class="op">*</span> x_pop</span>
<span id="cb98-3"><a href="#cb98-3" aria-hidden="true" tabindex="-1"></a>    μ <span class="op">=</span> at.exp(η)</span>
<span id="cb98-4"><a href="#cb98-4" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb98-5"><a href="#cb98-5" aria-hidden="true" tabindex="-1"></a>    α <span class="op">=</span> pm.HalfNormal(<span class="st">&quot;α&quot;</span>, <span class="fl">2.5</span>)</span>
<span id="cb98-6"><a href="#cb98-6" aria-hidden="true" tabindex="-1"></a>    obs <span class="op">=</span> pm.NegativeBinomial(<span class="st">&quot;obs&quot;</span>, μ, α, observed<span class="op">=</span>y)</span></code></pre></div>
<p>We again sample from the posterior distribution of the model.</p>
<div class="sourceCode" id="cb99"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb99-1"><a href="#cb99-1" aria-hidden="true" tabindex="-1"></a><span class="cf">with</span> mixed_model:</span>
<span id="cb99-2"><a href="#cb99-2" aria-hidden="true" tabindex="-1"></a>    mixed_trace <span class="op">=</span> pm.sample(<span class="op">**</span>SAMPLE_KWARGS, target_accept<span class="op">=</span><span class="fl">0.95</span>)</span></code></pre></div>
<pre><code>Auto-assigning NUTS sampler...
Initializing NUTS using jitter+adapt_diag...
Multiprocess sampling (3 chains in 3 jobs)
NUTS: [μ_β0, γ_β0_pop_bar, Δ_β0, σ_β0, μ_β_coast, γ_β_coast_pop_bar, γ_β_coast_coast_bar, Δ_β_coast, σ_β_coast, μ_β_pop, γ_β_pop_pop_bar, γ_β_pop_coast_bar, Δ_β_pop, σ_β_pop, α]</code></pre>
<div>
<style>
/* Turns off some styling */
progress {
/* gets rid of default border in Firefox and Opera. */
border: none;
/* Needs to be in here for Safari polyfill so background images work as expected. */
background-size: auto;
}
.progress-bar-interrupted, .progress-bar-interrupted::-webkit-progress-bar {
background: #F44336;
}
</style>
<progress value="6000" class max="6000" style="width:300px; height:20px; vertical-align: middle;">
</progress>
<p>100.00% [6000/6000 24:00&lt;00:00 Sampling 3 chains, 3 divergences]</p>
</div>
<pre><code>Sampling 3 chains for 1_000 tune and 1_000 draw iterations (3_000 + 3_000 draws total) took 1441 seconds.
There was 1 divergence after tuning. Increase `target_accept` or reparameterize.
There were 2 divergences after tuning. Increase `target_accept` or reparameterize.</code></pre>
<p>The few divergences here could be eliminated by increasing <code>target_accept</code> and waiting longer, but we will proceed with our analysis (I’m impatient). As before, the standard sampling diagnostics show no cause for concern.</p>
<div class="sourceCode" id="cb102"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb102-1"><a href="#cb102-1" aria-hidden="true" tabindex="-1"></a>make_diagnostic_plots(mixed_trace)<span class="op">;</span></span></code></pre></div>
<center>
<img src="/resources/sharks_pycm3_files/sharks_pycm3_132_0.png" title="fig:" alt="png" />
</center>
<p>To see if the inclusion of mixed effects has improved the model fit, we sample from and plot the posterior predictive distributions per state-year.</p>
<div class="sourceCode" id="cb103"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb103-1"><a href="#cb103-1" aria-hidden="true" tabindex="-1"></a><span class="cf">with</span> mixed_model:</span>
<span id="cb103-2"><a href="#cb103-2" aria-hidden="true" tabindex="-1"></a>    mixed_pp_trace <span class="op">=</span> pm.sample_posterior_predictive(mixed_trace)</span></code></pre></div>
<div>
<style>
/* Turns off some styling */
progress {
/* gets rid of default border in Firefox and Opera. */
border: none;
/* Needs to be in here for Safari polyfill so background images work as expected. */
background-size: auto;
}
.progress-bar-interrupted, .progress-bar-interrupted::-webkit-progress-bar {
background: #F44336;
}
</style>
<progress value="3000" class max="3000" style="width:300px; height:20px; vertical-align: middle;">
</progress>
<p>100.00% [3000/3000 00:05&lt;00:00]</p>
</div>
<div class="sourceCode" id="cb104"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb104-1"><a href="#cb104-1" aria-hidden="true" tabindex="-1"></a>mixed_pp_full_df <span class="op">=</span> make_pp_full_df(mixed_pp_trace[<span class="st">&quot;obs&quot;</span>])</span></code></pre></div>
<div class="sourceCode" id="cb105"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb105-1"><a href="#cb105-1" aria-hidden="true" tabindex="-1"></a>mixed_pp_df <span class="op">=</span> summarize_pp_df(mixed_pp_full_df)</span>
<span id="cb105-2"><a href="#cb105-2" aria-hidden="true" tabindex="-1"></a>grid <span class="op">=</span> sns.FacetGrid(mixed_pp_df.reset_index(), col<span class="op">=</span><span class="st">&quot;State&quot;</span>,</span>
<span id="cb105-3"><a href="#cb105-3" aria-hidden="true" tabindex="-1"></a>                     col_wrap<span class="op">=</span><span class="dv">2</span>, sharey<span class="op">=</span><span class="va">False</span>, aspect<span class="op">=</span><span class="fl">1.5</span>)</span>
<span id="cb105-4"><a href="#cb105-4" aria-hidden="true" tabindex="-1"></a>grid.map_dataframe(plot_pp_over_time)<span class="op">;</span></span>
<span id="cb105-5"><a href="#cb105-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb105-6"><a href="#cb105-6" aria-hidden="true" tabindex="-1"></a>grid.axes[<span class="dv">0</span>].legend(loc<span class="op">=</span><span class="st">&quot;upper left&quot;</span>)<span class="op">;</span></span>
<span id="cb105-7"><a href="#cb105-7" aria-hidden="true" tabindex="-1"></a>grid.set_titles(<span class="st">&quot;</span><span class="sc">{col_name}</span><span class="st">&quot;</span>)<span class="op">;</span></span>
<span id="cb105-8"><a href="#cb105-8" aria-hidden="true" tabindex="-1"></a>grid.fig.tight_layout()<span class="op">;</span></span></code></pre></div>
<center>
<img src="/resources/sharks_pycm3_files/sharks_pycm3_136_0.png" title="fig:" alt="png" />
</center>
<div class="sourceCode" id="cb106"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb106-1"><a href="#cb106-1" aria-hidden="true" tabindex="-1"></a>mixed_pp_state_df <span class="op">=</span> summarize_pp_df(mixed_pp_full_df, level<span class="op">=</span><span class="st">&quot;State&quot;</span>)</span>
<span id="cb106-2"><a href="#cb106-2" aria-hidden="true" tabindex="-1"></a>ax <span class="op">=</span> (mixed_pp_state_df.reset_index()</span>
<span id="cb106-3"><a href="#cb106-3" aria-hidden="true" tabindex="-1"></a>                    .plot.scatter(<span class="st">&quot;mean&quot;</span>, <span class="st">&quot;State&quot;</span>, color<span class="op">=</span><span class="st">&#39;C0&#39;</span>,</span>
<span id="cb106-4"><a href="#cb106-4" aria-hidden="true" tabindex="-1"></a>                                  xerr<span class="op">=</span>mixed_pp_state_df[[<span class="st">&quot;low&quot;</span>, <span class="st">&quot;high&quot;</span>]]</span>
<span id="cb106-5"><a href="#cb106-5" aria-hidden="true" tabindex="-1"></a>                                                     .sub(mixed_pp_state_df[<span class="st">&quot;mean&quot;</span>],</span>
<span id="cb106-6"><a href="#cb106-6" aria-hidden="true" tabindex="-1"></a>                                                          axis<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb106-7"><a href="#cb106-7" aria-hidden="true" tabindex="-1"></a>                                                     .<span class="bu">abs</span>()</span>
<span id="cb106-8"><a href="#cb106-8" aria-hidden="true" tabindex="-1"></a>                                                     .values.T,</span>
<span id="cb106-9"><a href="#cb106-9" aria-hidden="true" tabindex="-1"></a>                                  zorder<span class="op">=</span><span class="dv">5</span>,</span>
<span id="cb106-10"><a href="#cb106-10" aria-hidden="true" tabindex="-1"></a>                                  label<span class="op">=</span><span class="st">&quot;Posterior predictive mean&quot;</span>))</span>
<span id="cb106-11"><a href="#cb106-11" aria-hidden="true" tabindex="-1"></a>(attacks_df.reset_index()</span>
<span id="cb106-12"><a href="#cb106-12" aria-hidden="true" tabindex="-1"></a>           .plot.scatter(<span class="st">&quot;Attacks&quot;</span>, <span class="st">&quot;State&quot;</span>,</span>
<span id="cb106-13"><a href="#cb106-13" aria-hidden="true" tabindex="-1"></a>                         color<span class="op">=</span><span class="st">&#39;k&#39;</span>, alpha<span class="op">=</span><span class="fl">0.5</span>,</span>
<span id="cb106-14"><a href="#cb106-14" aria-hidden="true" tabindex="-1"></a>                         label<span class="op">=</span><span class="st">&quot;Actual&quot;</span>, ax<span class="op">=</span>ax))<span class="op">;</span></span>
<span id="cb106-15"><a href="#cb106-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb106-16"><a href="#cb106-16" aria-hidden="true" tabindex="-1"></a>ax.set_xlabel(<span class="st">&quot;Number of shark Attacks&quot;</span>)<span class="op">;</span></span>
<span id="cb106-17"><a href="#cb106-17" aria-hidden="true" tabindex="-1"></a>ax.invert_yaxis()<span class="op">;</span></span></code></pre></div>
<center>
<img src="/resources/sharks_pycm3_files/sharks_pycm3_137_0.png" title="fig:" alt="png" />
</center>
<p>We see that the predictions for Florida, California, Hawaii, and the Carolinas are much better in this model.</p>
<div class="sourceCode" id="cb107"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb107-1"><a href="#cb107-1" aria-hidden="true" tabindex="-1"></a>traces[<span class="st">&quot;NB mixed&quot;</span>] <span class="op">=</span> mixed_trace</span></code></pre></div>
<div class="sourceCode" id="cb108"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb108-1"><a href="#cb108-1" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots()</span>
<span id="cb108-2"><a href="#cb108-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb108-3"><a href="#cb108-3" aria-hidden="true" tabindex="-1"></a>comp_df <span class="op">=</span> az.compare(traces)</span>
<span id="cb108-4"><a href="#cb108-4" aria-hidden="true" tabindex="-1"></a>az.plot_compare(comp_df, plot_ic_diff<span class="op">=</span><span class="va">False</span>, ax<span class="op">=</span>ax)<span class="op">;</span></span></code></pre></div>
<center>
<img src="/resources/sharks_pycm3_files/sharks_pycm3_140_0.png" title="fig:" alt="png" />
</center>
<p>As expected the PSIS-LOO score for this model is significantly better than the fixed effects negative binomial regression model.</p>
<p>It is interesting but not surprising that mixed effects are required to produce reasonable predictions of the number of shark attacks in each state over time. Future posts may investigate further explanatory variables and other aspects of this data set.</p>
<p>This post is available as a Jupyter notebook <a href="https://nbviewer.jupyter.org/gist/AustinRochford/ce87b0d4e77ad9879a46a1322ea5b141">here</a>.</p>
<div class="sourceCode" id="cb109"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb109-1"><a href="#cb109-1" aria-hidden="true" tabindex="-1"></a><span class="op">%</span>load_ext watermark</span>
<span id="cb109-2"><a href="#cb109-2" aria-hidden="true" tabindex="-1"></a><span class="op">%</span>watermark <span class="op">-</span>n <span class="op">-</span>u <span class="op">-</span>v <span class="op">-</span>iv</span></code></pre></div>
<pre><code>Last updated: Sun Jun 27 2021

Python implementation: CPython
Python version       : 3.8.8
IPython version      : 7.22.0

numpy     : 1.20.2
matplotlib: 3.4.1
pandas    : 1.2.3
us        : 2.0.2
seaborn   : 0.11.1
aesara    : 2.0.12
arviz     : 0.11.2
pymc3     : 4.0</code></pre>
